# 第一阶段

## A.Java入门概述

### 1.Java的特性

- Java重要特点

1. Java语言是面向对象的(OOP)

2. Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证//

   **强类型--垃圾处理--异常处理--解释性语言--跨平台**

3. Java语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]

   JVM可以支持java的程序在不同操作系统上运行--JVM包含在JDK中--一次编译随处运行

4. Java语言是解释型的[了解]

解释性语言：javascript，PHP，java

编译性语言: c /c++

区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行； 编译性语言编译后的代码，可以直接被机器执行,c /c+ +

<img src=".\Java入门markdown图片\Java跨平台特点.png" alt="Java跨平台特点" style="zoom:50%;" />

- JDK(Java Development Kit-Java开发工具包)

1. JDK = JRE + java开发工具(java-javac-javadoc-javap等)
2. JRE(Java Runtime Environment-Java运行环境) = JVM + Java核心类库--如果只需要运行java程序只需要JRE即可

![JDK包含的内容](.\Java入门markdown图片\JDK包含的内容.png)

<img src=".\Java入门markdown图片\JDK.png" alt="JDK" style="zoom:50%;" />

### 2.环境搭建

- 下载/安装JDK

https://www.oracle.com/cn/java/technologies/downloads/#java8-windows

- 配置环境变量--在任何目录都执行java/javac

1. 我的电脑--属性--高级系统设置--环境变量
2. 增加%JAVA HOME%环境变量，指向jdk的安装目录 d:\program\hspjdk8
3. 编辑path 环境变量，增加 %JAVA HOME%\bin
4. 打开DOS命令行，任意目录下敲入javac/java。如果出现javac 的参数信息，配置成功。

- 未配置环境变量/环境变量配置失败

![环境变量1](.\Java入门markdown图片\环境变量1.png)

![环境变量2](.\Java入门markdown图片\环境变量2.png)

- 环境变量补充说明

1. 用户变量--只有当前用户可以使用
2. 系统变量--所有用户都可以使用

### 3.Sublime的简单使用

- 选择汉字编码

1. 需要选择汉字编码--不然会报错--reopen with encode--Chinese

<img src=".\Java入门markdown图片\sublime编码1.png" alt="sublime编码1" style="zoom: 67%;" />

2. 因为控制台的编码为GBK--必须保持一致

<img src=".\Java入门markdown图片\sublime编码2.png" alt="sublime编码2" style="zoom:67%;" />

### 4.Java执行流程

Java执行流程--Java文件(源文件)--class文件(字节码文件)--结果

![Java执行流程](.\Java入门markdown图片\Java执行流程.png)

### 5.Java开发的注意事项和细节

- 注意事项和细节

1. Java源文件的基本组成部分是类(class)
2. Java程序的执行入口是main()方法
3. Java严格区分大小写
4. Java的方法是由一条一条的语句构成，以";"结尾
5. 如果源文件包含一个**public类**，则文件名必须按该类名命名
6. main()方法可以写在非public类--每一个类在编译的时候都会生成一个class文件

### 6.如何快速掌握知识点和技巧

需求分析--用现有(传统)技术能否解决-可以解决但是不完美->新技术的基本原理-基本语法-暂时不要考虑细节->快速入门-一个基本的程序->开始研究注意事项-使用规范和细节-优化问题

## B.入门知识点

### 1.转义字符

- 常见的转义字符

1. \t 制表符
2. \n 换行符
3. \ \ 一个\
4. \ " 一个"
5. \ ' 一个'
6. \ r 一个回车--回车和换行不一样--回车让光标**回到开头的位置**

```java
System.out.println("电子科大教育\r在光电学院");
// 输出 
// 在光电学院育
```

```java
// 代码演示
System.out.println("明天\t不上班");
System.out.println("天\n天\n向\n上");
System.out.println("输入一个斜杠\\");
System.out.println("输出两个斜杠\\\\");
System.out.println("老师说：\"学会Java\"");
```



### 2.注释(comment)：解释程序的文字

- 单行注释

```java
//注释文字
```

- 多行注释：多行注释内部不允许嵌套多行注释

```java
/*第一行注释文字
第二行注释文字
第三行文字*/
```

- 文本注释

1. 注释内容可以被JDK提供的工具 javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在**类前**
2. 可以配合JavaDoc标签一起使用

```java
/**
 * 文档注释标签
 * JavaDoc测试
 * @author ZYP
 * @version 1.0
 * 
 */
public class JavaDocTest{
	public static void main(String[] args){
		System.out.println("注释测试");
	}
}
```



### 3.代码规范

- 详细内容查看--Java代码规范

1. 类、方法的注释--用javadoc的方式写--文档注释
2. 非JavaDoc的注释提示维护者程序的作用，修改方式和注意的问题
3. 使用tab操作,实现缩进,默认整体向右边移动，时候用shift+tab整体向左移
4. 运算符号=两边习惯性各加一个空格。比如:2 + 4 * 5 + 345 - 89
5. 源文件使用utf-8编码(使用doc命令需要用GBK)
6. **行宽度不要超过80字符**

- 代码编写**次行风格**和**行尾风格**

1. 次行风格

```java
public ArrayList(int initialCapacity)
{
    if (initialCapacity > 0)
    {
		this.elementData = new object[initialCapacity];
    } else if (initialCapacity == 0)
    {
		this.elementData = EMPTY_ELEMENTDATA;
    } else
    {
		throw new ILLegalArgumentException("Illegal Capacity:" + initialCapacity);
    }
}
```

2. 行尾风格

```java
public ArrayList(int initialCapacity){
    if (initialCapacity > 0) {
		this.elementData = new object[initialCapacity];
    } else if (initialCapacity == 0) {
		this.elementData = EMPTY_ELEMENTDATA;
    } else {
		throw new ILLegalArgumentException("Illegal Capacity:" + initialCapacity);
    }
}
```



### 4.常见错误

- 初学者常见错误

1. 源文件不存在/文件名/路径错误
2. 主类名和文件名不一样
3. 缺少分号";"--大括号{}--引号""--语法单词错误
4. 编程问题
   - 1和l混淆(1和L的小写)
   - 0和o混淆
   - 中英文的符号混淆
   - 单词错误
5. 业务逻辑错误--环境错误

### 5.Dos命令

- 相对路径--绝对路径
- 常用命令

1. 查看当前目录-- dir -- dir 绝对路径
2. 切换路径
   - -- cd C:/ 
   - -- cd 绝对路径	
   - 上一级目录--cd ..	
   - 回到根目录-- cd \
3. 查看文件的所有子集目录-- tree
4. 清屏-- cls
5. 退出 -- exit
6. 创建文件 -- md

<img src=".\Java入门markdown图片\DOS1.png" alt="DOS1" style="zoom:50%;" />

7. 删除目录 -- rd

<img src=".\Java入门markdown图片\DOS2.png" alt="DOS2" style="zoom:50%;" />

8. 拷贝文件 -- copy

<img src=".\Java入门markdown图片\DOS3.png" alt="DOS3" style="zoom:50%;" />

9. 删除 -- del

10. 写入内容到文件 -- echo

11. 剪切 -- move 

### 6.变量

- 变量的基本概念

1. 变量是程序基本的组成单位--内存中的一个数据存储空间
2. 变量的三个基本要数：类型--名称--值

- **数据类型**：每一种数据都有明确的数据类型->分配不同(对应)的内存大小

1. 基本数据类型
2. **引用数据类型**

#### A.基本数据类型

##### 1.数值类型

###### 整数类型

- 类型

1. byte[1]
2. short[2]
3. int[4]

```java
int age = 20;
```

4. long[8]

![整数类型1](.\Java入门markdown图片\整数类型1.png)

注意：进制的第一位是0次方

- 使用细节

1. 整数类型的字节长度不受操作系统的限制--统一的
2. 默认为int类型--声明long型的整型，常量后加"l"或"L"

```java
long a = 100l;
```

![整数类型2](.\Java入门markdown图片\整数类型2.png)

3. int不能表示的大数才用long
4. byte-字节是基本存储单位--bit-位是最小存储单位

###### 浮点类型

- 类型

1. float[4]
2. double[8]

```java
double score =88.6;
```

- 浮点数表示方法

1. 浮点数=符号位+指数位+尾数位
2. N=r^E * M--通常r=2--E指数位--M尾数位
3. 尾数部分有精度损失

- 使用细节

1. 浮点类型的字节长度不受操作系统的限制--统一的
2. 默认为double类型--声明float型的浮点型，常量后加"f"或"F"

```java
float num1 = 1.1 // 对不对?错误
double num4 = 1.1f; //对--把小内存的数组放入大内存的数
```

![浮点类型1](.\Java入门markdown图片\浮点类型1.png)

3. 两种表示法:
   - 小数表示：2.12  5.123f；0.123可以写成.123
   - 科学计数法2.12e2   5.22E-1
4. 通常使用double--比float精度更高
5. 浮点类型的精度损失--可以用差值的绝对值是否在一个小范围内判断是否相等

```java
double a = 2.7;
double b = 8.1/3;
System.out.printIn(a)
System.out.println(b)
/* 输出
2.7
2.6999999999999997
*/
```

##### 2.字符类型

- 字符类型：表示单个字符

1. char[2]

```java
char gender = '男';
char c1 = 'a';
char c2 = '\t';
char c3 = '周'
char c4 = 97;
System.out.println(c1);
System.out.printIn(c2);
System.out.printIn(c3);
System.out.print1n(c4);
/*
输出
a
	
周
a
*/
```

字符类型可以存放数字--但是会显示数字Unicode码对应字符

- 使用细节

1. 字符类型-单引号' '括起来的单个字符--双引号表示字符串
2. 允许使用转义字符表示特殊的字符常量
3. char本质是整数--输出时->对应Unicode码的字符
4. char类型可以进行运算--运算时转换为int类型

```java
System.out.printn('a' + 20); // 输出 117

char c5 = 'a' + 20;
System.out.println(c5); // 输出u
System.out.println((int)c5); // 输出117

char c1 = '男';
char c2 = '女';
System.out.println(c1 + c2); // 输出52906
```

- 字符类型的本质

1. 计算机存储字符类型->字符->对应的Unicode码的数值->二进制->存储
2. 读取字符类型->二进制->码值->对应的Unicode码->显示

- 编码-介绍一下字符编码表--使用Sublime保存不同的编码格式可以看出字节大小不一样

1. ASCll(ASCII编码表一个字节，规定128个字符)
2. Unicode (Unicode编码表--包含所有的字符--固定大小的编码使用两个字节来表示字符，字母和汉字统一都是占用两个字节，这样浪费空间--Unicode码兼容Ascll码)
3. utf-8(utf-8编码表--Unicode码的改进，大小可变的编码字母使用1个字节，汉字使用3个字节)
4. gbk(可以表示汉字，而且范围广，字母使用1个字节，汉字2个字节)
5. gb2312(可以表示汉字，gb2312 <gbk)
6. big5码(繁体中文，台湾，香港)

##### 3.布尔类型

- 布尔类型--boolean--1个字符

1. 只允许为true或者false-不能为null

- 使用细节

1. 不可以用0或非0的整数替代false和true--不同于C和python

##### 4.数据转换

###### 自动转换

- 自动转换--从**低精度到高精度**

1. java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型
2. 数据类型精度--**记住**

![数据类型精度1](.\Java入门markdown图片\数据类型精度1.png)

```java
char c1 = (byte)100;
int i1 = 'a';
double d1 = (int)10;
System.out.println(c1);
System.out.println(i1);
System.out.println(d1);
/*
输出
d
97
10.0
*/
```

- 细节与注意

1. 有多种类型的数据混合运算时,系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。--取决于操作变量中精度最高的数据类型

```java
float d1 = n1 + 1.1 // 报错--右边自动转换为double类型
float d1 = n1 + 1.1F // 不会报错
```

2. 当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错,反之就会进行自动类型转换。

```java
int i2 = (int) 1.1; // 强制转换
int i2 = 1.1 // 报错
```

3. (byte, short)和char之间不会相互自动转换--可以强制转换

```java
byte b1 = 10; //对，-128-127
int n2 = 1; //n2 是int
byte b2 = n2; //如果是变量赋值，判断类型

byte b1 = 10;
char c2 = b1;
```

4. (byte, short)和char三者之间可以运算--先转化为int类型
5. **boolean类型不参与转换**

###### 强制转换

- 强制转换：从**高精度到低精度**--精度损失--数据溢出

```java
int n1 = (int)1.9;
System.out.println("n1=" + n1);
// 输出 n1=1
```

- 注意与细节

1. 从高精度到低精度
2. 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级

```java
int x = (int)1*3.5+6*1.5; // 出错
int x = (int)(10*3.5+6*1.5);
```

3. char类型可以保存。jnt的常量值,但不能保存int的变量值,需要强转

```java
char c1 = 100; //ok
int m = 100; //ok
char c2 = m; //错误
char c3 = (char)m; //ok
```

4. byte和short类型在进行运算时，当做int类型处理。

###### 基本数据类型和String的转换

- 转字符串->基本数据类型＋字符串->字符串

1. 基本数据类型 + ""
2. 案例演示

```java
// 试写出将String转换成double类型的语句,以及将char类型转换成String的语句,举例说明即可,写简单代码
String str ="18.8”; //注意 字符串要可以被转成 double
double d1 = Double.parseDouble(str);

char c1 = '韩';
String str2 = c1 + "";
```

- 字符串转基本数据类型->通过基本数据类型的包装类调用parseXXX方法

```java
Integer.parseInt("123");
Double.parseDouble("123.1");
Float.parseFloat("123.45");
Short.parseShort("12");
Long.parselLong("12345");
Boolean .parseBoolean("true")
Byte.parseByte("12");
// 字符类型
System.out.println(s5.charAt(1));
System.out.println(s5.charAt(0)); // 将s5的第一个字符转为字符类型
```

- 注意与细节

1. 把String转换为基本数据类型时--需要确保String能够转换为有效的数据
2. 格式不对程序会抛出异常--程序终止

```java
String str = "hello";
//转成int
int n1 = Integer.parseInt(str);
System.out.println(n1);
```

编译不报错--运行抛出异常

![类型转换异常1](.\Java入门markdown图片\类型转换异常1.png)

3. 字符串类型的转换需要使用包装类的方法

```java
int num1=(int)"18"; //错误 应该 Integer.parseInt("18”);
```

#### B.引用数据类型

##### 1.类：class

- String--在Java里面不是基本数据类型--是一个类

```java
String name = "jack";
```

##### 2.接口：interface

##### 3.数组：[]

#### C.程序中"+"的使用

1. 两边都是数值类型时--加法运算
2. 两边有一边为字符串时--拼接
3. 案例测试：运算顺序从左到右

```java
int a = 100;
int b = 99;
String str1 = "happy ending"
String str2 = "Today";
// System.out.printIn(a + b);
// System.out.println(a + " " + str1);
// System.out.printIn(a + b);
System.out.println(a + b + str1);
System.out.println(str2 + b + a);
/* 输出
199happy ending
Today99100
*/
```

#### D.变量使用的注意事项

1. 变量表示内存中的一个存储区域--不同类型的空间大小不同
2. 该区域有自己的名称和类型
3. 先声明-复制--后使用
4. 数据的值可能不断变化--数据类型通常不变

```java
int a = 5; //int
System.out .println(a);//50
//该区域的数据/值可以在同一类型范围内不断变化
a = "jack"; // x
```

5. 同一作用域的变量名不能重名

```java
//变量必须先声明，后使用，即有顺序
int a = 50;//int
System.out .println(a);//50
a= 88; //对
System.out .println(a);//88
//变量在同一个作用域内不能重名
int a = 77;//错误
```

6. 三要素--类型--名称--值

### 7.运算符

#### 算术运算符

- 简介

算术运算符是对数值类型的变量进行运算的，在java程序中使用的非常多。

![算术运算符](.\Java入门markdown图片\算术运算符.png)

```java
// 1.
System.out.println(10 / 4); //从数学来看是2.5，java中 2
System.out.println(10.0 / 4); //java是2.5
// 2. 
double d = 10 / 4; //java中10 / 4 = 2, 2=>2.0
/* 3.**取模的本质
% 的本质 看一个公式 a % b = a - a / b * b
-10 % 3 => -10 - (-10) / 3 * 3 = -10 + 9 = -1
10 % -3 = 1 - 10 / (-3) * (-3) = 10 - 9 = 1
-10 % -3 = (-10) - (-10) / (-3) * (-3) = -10 + 9 = -1
*/
System.out.println(10 % 3); //1
System.out.println(-10 % 3); // -1
System.out.println(10 % -3); //1
System.out.println(-10 % -3);//-1
// 4. a % b当a是小数时，公式 = a - (int)a / b* b
// 对a进行强制转换
// 5. ++ 和 --
// 独立使用时前++和后++都一样
int i = 10
i++;//自增 等价于 i = i + 1; => i = 11
++i;//自增 等价于 i = i + 1;=> i = 12
System.out.println("i=" + i);//12
int k1 = 8;
int k2 = 8;
int j1 = ++k1;
int j2 = k2++;
System.out.printIn("j1="+ j1 +'\t' + "k1=" + k1);//j1=9 k1=9
System.out.printIn("j2=" + j2 +'\t' + "k2=" + k2);//j2=8 k2=9
// 6. 浮点数参与运算的情况获得的值都是近似值
```

- 思考题

1.  int i=1;i=(i++);问: 结果是多少? 为什么?

```java
int i=1;
i=(i++); // (.)部分表示temp
//规则使用临时变量: (1) temp=i;(2) i=i+1;(3)i=temp;
System.out.println(i): //?
// 运算顺序
// 1. 先计算temp的表达式
// 2. i 再自增
// 3. 赋值给i
```

2. int i=1;i=(++i);问: 结果是多少? 为什么?

```java
int i=1;
i=++i; //规则使用临时变量: (1) i=i+1;(2) temp=i;(3)i=temp;
System.out.println(i); //?
```

#### 关系运算符/比较运算符

- 关系运算符的结果都是boolean型--true--false

![关系运算符](.\Java入门markdown图片\关系运算符.png)

注意：instranceof--在面向对象部分讲解

#### 逻辑运算符

![逻辑运算符](.\Java入门markdown图片\逻辑运算符.png)

- 第一组：短路型运算符-有一边可以判断就不在进行另一边

1. 短路与：&& 
2. 短路或：|| 
3. 取反：！

- 第二组：逻辑与--& 逻辑或--|| 逻辑异或--^



- &&和&使用区别--开发中**通常使用短路XX**--效率高

1. &&短路与:如果第一个条件为false，则第二个条件不会判断，最终结果为false效率高
2. &逻辑与:不管第一个条件是否为false,第二个条件都要判断，效率低3.开发中，我们使用的基本是短路与&&，效率高

```java
int a = 10;
if (a < 10 && a++ <= 50){
}
System.out.println(a);//10
if (a < 10 & a++ <= 50){
}
System.out.println(a);//11
```

- ||和|使用区别--与上面类似

```java
int a = 10;
if (a>=10 || a++<=50){
	System.out.printin(a);// 10
}
if (a>=10 | a++<=50) {
	System.out.println(a);// 11
}
```

- ^异或--不同为真--相同为假

#### 赋值运算符(assignOperator)

- 赋值运算符

1. +=
2.   -=
3. *=
4. /=
5. %=

- 基本说明

1. 运算顺序从右到左--先运算符号右边的表达式
2. 赋值运算符的左边只能是变量,右边可以是变量、表达式、常量值

```java
int num1 = 20;
int num2= 78 * 34 - 10;
int num3 =a;
```

3. 复合赋值运算符等价于下面的效果

```java
a+=3;等价于a=a+3;
```

4. 复合赋值运算符会进行类型转换

```java
byte b = 2;
b+=3;
b++;
// 等效于:b = (byte)b + 3 有一个类型的强制转换
```

#### 三元运算符

- 基本语法：条件表达式?表达式1:表达式2;

1. 如果条件表达式为true，运算后的结果是表达式1;(只执行表达式1)
2. 如果条件表达式为false，运算后的结果是表达式2;(只执行表达式2)

- 使用细节

1. 表达式1和表达式2要为可以赋给接收变量的类型(可以自动转换或强制转换)

```java
int a = 3;
int b = 8;
int c = a > b ? a : b;
```

2. 三元运算符可以转成if--else语句

```java
int n1 = 553;
int n2 = 33;
int n3 = 123;
int max1 = n1 > n2 ? n1 : n2;
int max2 = max1 > n3 ? max1 : n3;
System.out.println("最大数=" + max2);
int max = (n1 > n2 ? n1 : n2) > n3 ? (n1 > n2 ? n1 : n2) : n3;
System.out.println("最大数=" + max);
```

#### 运算符的优先级

1. 运算符有不同的优先级,所谓优先级就是表达式运算中的运算顺序。如表,上一行运算符总优先于下一行。
2. 只有单目运算符、赋值运算符是从右向左运算的。

![运算符优先级](.\Java入门markdown图片\运算符优先级.png)

#### 标识符的命名规则和规范

- 基本概念

1. Java对各种变量、方法和类等命名时使用的字符序列称为**标识符**
2. 凡是自己可以起名字的地方都叫标识符int num1 = 90;

- 命名规则

1. 由26个英文字母大小写,0-9,_或$组成
2. **不能**以**数字开头**。int 3ab = 1;
3. **不**可以使用**关键字和保留字**，但能包含关键字和保留字。
4. Java中**严格区分大小写**,长度无限制。int totalNum = 10; int n = 90;5．标识符不能包含空格。int a b = 90;

- 标识符命名规范

1. **包名**:多单词组成时所有字母都**小写**:aaa.bbb.ccc //比如com.hsp.crm
2. **类名、接口名**:多单词组成时,所有单词的首字母大写: XxxYyyZzz比如: TankShotGame(**大驼峰**)
3. **变量名、方法名**:多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写:xxxYyyZzz-比如: tankShotGame(**小驼峰**--简称驼峰)
4. **常量名**:所有字母都**大写**。多单词时每个单词用下划线连接:XXX_YYY_ZzZ比如:定义一个所得税率 TAX_RATE
5. 后面我们学习到类，包,接口，等时，我们的命名规范要这样遵守,更加详细的看文档.

#### 关键字

- 定义

被Java语言赋予了特殊含义,用做专门用途的字符串(单词)

- 特点

关键字中所有字母都为小写

![关键字](.\Java入门markdown图片\关键字.png)

#### 保留字

![保留字](.\Java入门markdown图片\保留字.png)

#### 键盘输入

- 在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java，需要一个扫描器(对象),就是Scanner
- 使用步骤

1. 导入该类的所在包， java.util.*  // java.util.Scanner
2. 创建该类对象(声明变量)
3. 调用里面的功能

```java
import java.util.Scanner;
public class InputTest {
	public static void main(String[] args){
        Scanner myScanner = new Scanner(System.in);
        System.out.printIn("请输入名字");
        String name = myScanner.next();
        System.out.println("请输入年龄")
        int age = myScanner.nextInt();
        System.out.printIn("请输入工资");
        double sal = myScanner.nextDouble();
    }
}
```

#### 进制

- 常用的进制

1. 二进制:0,1--满2进1--以0b或0B开头。
2. 十进制:0-9--满10进1。
3. 八进制:0-7，满8进1--以数字0开头表示。
4. 十六进制:0-9及A(10)-F(15),满16进1--以Ox或OX开头表示。此处的A-F不区分大小写。

- 进制的转换

1. 其他进制转十进制
2. 十进制转其他进制--短除法

​	![进制转换_短除法](.\Java入门markdown图片\进制转换_短除法.png)

3. 二进制转八进制-三位一组--二进制转16进制-4位一组
4. 八进制转二进制-每一位的数字转为三位二进制--十六进制转二进制-每一位的数字转为四位二进制

#### 位运算

- 位移运算

![运算符_位移运算](.\Java入门markdown图片\运算符_位移运算.png)

1. 算术右移'>>':低位溢出,符号位不变,并用**符号位补溢出的高位
2. 算术左移'<<':符号位不变,低位补0
3. '>>>' 逻辑右移也叫无符号右移,运算规则是:低位溢出,高位补0
4. 特别说明:没有<<<符号

```java
System.out.println(1 >> 2); // 0
System.out.println(1 << 2); // 4
System.out.println(4 << 3); // 4 * 2 * 2 * 2 = 32
System.out.println(15 >> 2); // 15 /2 / 2 = 3
```

- 位运算

1. 按位取反~
2. 按位与&
3. 按位或|
4. 按位异或^

- **原码-反码-补码

1. 二进制的最高位是符号位:0表示正数,1表示负数(0正1负)
2. 正数的原码,反码,补码都一样(三码合一)
3. 负数的反码=它的原码符号位不变，其它位取反(0->1,1->0)
4. 负数的补码=它的反码+1，负数的反码=负数的补码-1
5. O的反码，补码都是0
6. java没有无符号数，换言之, java中的数都是有符号的
7. 在计算机运算的时候，都是以**补码**的方式来运算的
8. 当我们看运算**结果**的时候,要看他的**原码**

```java
System.out.pritln(2&3); // 用补码进行计算--正数的三码合一
// 推导
// 1.先得到 -2的原码 10000000 00000000 00000000 00000010
// 2.-2的 反码 11111111 11111111 11111111 11111101
// 3.-2的 补码 11111111 11111111 11111111 11111110
// 4.~-2操作 00000000 00000000 00000000 00000001 ~按位取反
// 5.运算后的原码 00000000 00000000 00000000 00000001
System.out.println(~-2);
// 推导
// 1.先得到 -2的原码 10000000 00000000 00000000 00000010
// 2.~2操作 11111111 11111111 11111111 11111101 ~按位取反
// 3.运算后的反码 11111111 11111111 11111111 11111100
// 4.运算后的原码 10000000 00000000 00000000 00000011 => -3
System.out.println(~2); // -3
```



### 8.控制结构

#### 顺序控制

- 特点

1. 程序从上到下逐行地执行，中间没有任何判断和跳转。
2. 程序默认的运行顺序--向前引用-先定义再引用

#### 分支(if else, switch)

- if--else

1. 单分支：基本语法--条件表达式为真--运行代码块

```java
if (条件表达式) {
	执行代码块;(可以有多条语句.)
}
```

2. 双分支

```java
if (条件表达式) {
	执行代码块1;
} else {
	执行代码块2;
}
```

3. 多分支

```java
if (条件表达式1) {
	执行代码块1;
} else if (条件表达式2) {
	执行代码块2;
} ...
else {
	执行代码块n;
}
```

4. 嵌套分支：嵌套分支不要超过3层严重影响可读性

```java
if (条件表达式) {
	if (条件表达式) {
	执行代码块1;
    } else {
        执行代码块2;
    }
}
```

- switch分支结构

1. 基本语法

```java
switch(表达式) {
    case 常量1:
        语句块1;
        break;
    case 常量2:
        语句块2;
        break;
    case 常量n:
        语句块n;
        break;
    default:
        default语句块;
        break;
}
```

2. 表达式运算过后--获得一个具体的值
3. break
   - 跳出当前switch
   - 如果没有break语句--会依次运行剩余case的所有代码包括default (穿透)
4. default--表示所有case都没有匹配上默认执行的程序

- switch注意与细节

1. 表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符,而常量是int
2. switch(表达式)中表达式的返回值必须是: (byte,short,int, char,enum[枚举],String)
3. case子句中的值必须是**常量,而不能是变量

![case语句报错](.\Java入门markdown图片\case语句报错.png)

4. default子句是可选的，当没有匹配的case时，执行default

5. break语句用来在执行完一个case分支后使程序跳出switch语句块;如果没有写break，程序会执行到switch结尾或者遇到break跳出

- 习题

```java
/*
对学生成绩大于60分的，输出“合格”。低于60分的，
输出”不合格”。(注:输入的成绩不能大于10)，提示 成绩/60
思路分析
1.这道题，可以使用 分支来完成， 但是要求使用switch
2.这里我们需要进行一个转换，编程思路
如果成绩在 [60,1], (int)(成绩/60) = 1
如果成绩在 [,60), (int)(成绩/60) = 0
*/
if(score >= 0 && score <= 100) {
    switch ((int)(score / 60)) {
        case 0:
        	System.out.printIn("不合格");
        	break;
        case 1 :
        	System.out.println("合格");
        	break;   
    }
} else {
	System.out.println("输入的成绩在0-100");
}
```

```java
/*
根据用于指定月份，
打印该月份所属的季节。
3,4,5 春季 6,7,8 夏季 9,10,11 秋季 12，1，2 冬季
[课堂练习，提示：使用穿透]
*/
Scanner myScanner = new Scanner(System.in);
System.out.printIn("输入月份");
int month = myScanner.nextInt() ;
switch(month) {
    case 3:
    case 4:
    case 5:
        System.out.printIn("这是春季");
        break;
}
```

- if-else和switch的选择

1. 如果判断的具体数值不多，而且符合byte、short、int、char, enum[枚举], String这6种类型。虽然两个语句都可以使用，建议使用swtich语句.
2. 其他情况:对区间判断,对结果为boolean类型判断,使用if,if的使用范围更广

#### 循环(for,while,do while,**多重循环)

- for循环

1. 基本语法

```java
for(循环变量初始化; 循环条件; 循环变量选代) {
	循环操作(可以多条语句);
}
// 执行顺序：初始化->判断循环条件->T->执行循环操作->变量迭代->判断循环条件->...
```

- for循环：注意与细节

1. 循环条件是返回一个**布尔值的表达成
2. 在循环变量初始化时声明的变量作用域在循环内

3) for(循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。

```java
int i = 0;
for (; i <= 10;) {
    System.out.println("这是第"+ i +“次循环");
    i++;
}
                       
for(;;){ //表示一个无限循环,死循环
	System.out.println("ok~"); // 无限循环
}
```

4. 循环初始值可以有多条初始化语句,但要求类型一样，并且中间用逗号隔开,循环变量迭代也可以有多条变量迭代语句,中间用逗号隔开。

```java
for (int i = 0,j = 5; i <= 10 || j >= 0; i++, j--) {
	System.out.println("此时的i=" + i + "j=" + j);
}
```

5. 使用内存分析法,老师分析输出下面代码输出什么?

- while循环

1. 基本语法

```java
while (循环条件) {
    循环体(语句);
    循环变量迭代
}
```

2. while循环也有4要素--只是位置与for循环不同

- while循环：注意与细节

1. 循环条件是返回一个**布尔值的表达式

```java
while (1) {
	System.out.printIn("循环ing");
}
// 报错：java: 不兼容的类型: int无法转换为boolean
```

2. while循环是先判断再执行--与do-while区别

- do-while循环

1. 基本语法

```java
循环变量初始化;
do{
循环体(语句):
循环变量迭代;
} while(循环条件);
```

- do-while循环：注意与细节

1. do while是关键字
2. 同样具有循环四要素,只是位置不一样
3. **先执行，再判断**--一定会执行一次
4. 最后有一个分号;
5. 应用常见--点菜的菜单--至少显示一次
6. 循环条件是返回一个布尔值的表达式

- **多重循环**

1. 基本概念
2. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do...while均可以作为外层循环和内层循环。【建议一般使用两层，最多不要超过3层，否则，代码的可读性很差】

#### break：跳转控制语句

- 满足条件时：跳出当前循环

- 注意与细节

1. break语句出现在多层嵌套的语句块中时,可以通过标签指明要终止的是哪一层语句块
2. 标签的使用--标签可以指定退出的位置--实际开发中通常不使用标签--没有指定标签时-默认退出最近的循环体

```java
lable1:
for (int j = 0; j< 4; j++) {
lable2:
    for (int i = 0; i < 10; i++) {
    	if(i == 2) {
    		break lable1;
        }
    System.out.println("i = " + i);
    }
}
```

#### continue

- 基本介绍

1. continue语句用于结束本次循环,继续执行下一次循环。
2) continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环，这个和前面的标签的使用的规则一样.

#### return

- 基本介绍

1. return使用在方法，表示跳出所在的**方法，在讲解方法的时候，会详细的介绍,这里我们简单的提一下。

2. 注意：如果return写在main方法，退出程序。

### 9.数组、排序和查找

#### 数组

- 简介

数组可以存放多个同一类型的数据。数组也是一种数据类型,是**引用类型。

- 数组的使用方式

1. 动态初始化
   - 方法1
   - 数据类型[] 数组名=new 数据类型[大小]：[ ]可以写在数据类型后面--或数组名后面--效果是一样的
   - int a[]=new int[5];//创建了一个数组，名字a,存放5个int
   - 方法2
   - 先声明--再创建
   - 声明:数据类型数组名[];也可以数据类型[]数组名;
   - 创建:数组名=new 数据类型[大小];

```java
double[] scores; //声明数组， 这时 scores 是 nul1
scores = new doubLe[5]; // 分配内存空间，可以存放数据
```

2. 静态初始化
   - 数据类型[] 数组名 = {元素值,元素值...}

```java
double[] arr1 = new double[]{1,2,3,4,5,6}
System.out.print(Arrays.toString(arr1));
double[] arr2 = {1, 2, 3, 4, 5, 6};
System.out.print(Arrays.toString(arr2));
// 第一种写法：[6]括号里不能限定大小
double[] arr1 = new double[6]{1,2,3,4,5,6}; // 编译报错
```

- 数组的引用/使用：数组名[下标]
- 注意与细节

1. 数组是多个相同类型数据的组合，实现对这些数据的统一管理
2. 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3. 数组创建后，如果没有赋值，有默认值int 0--short 0--byte 0--long 0--float 0.0--double 0.0--char \u0000--boolean false--String null 
4. 使用数组的步骤：
   - 1.声明数组并开辟空间
   - 2.给数组各个元素赋值
   - 3.使用数组
5. 数组的下标是从0开始的。
6. 数组下标必须在指定范围内使用，否则报：下标越界异常，比如int[] arr=new int[5]; 则有效下标为0-4
7. 数组属于引用类型,数组型数据是对象(object)

- 数组赋值的机制

1. 基本数据类型赋值,这个值就是具体的数据,而且相互不影响。
   - int n1 = 2;int n2 = n1; //值拷贝
2. 数组在默认情况下是**引用传递，赋的值是地址。看一个案例，并分析数组赋值的内存图(重点)。
   - int[] arr1 ={1,2,3];int[] arr2 = arr1;//引用传递-地址拷贝
   - 此时arr1和arr2指向同一个数组的地址

![数组拷贝](.\Java入门markdown图片\数组拷贝.png)

- 操作数组

1. 数组的拷贝：数据空间独立

```java
int[] arr1 = {10, 20, 30};
//创建一个新的数组arr2, 开辟新的数据空间
//大小 arr1.length;
int[] arr2 = new int[arr1.length];

//遍历 arr1, 把每个元秦拷贝到arr2对应的元
for(int i = ; i < arr1.length; i++) {
	arr2[i] = arr1[i];
}

// API
arr3 = Arrays.copyOf(arr1, arr1.length);
```

2. 数组反转：不能像Python一样直接交换或者切片
   - 1.使用temp变量遍历交换
   - 2.创建一个新的数组进行交换--再将原来的变量名指向新数组
3. 数组扩容
   - 重新创建一个数组进行遍历赋值
   - 再将原来的变量名指向新数组
   - 此时原来的arr没有引用就会被销毁

- 排序：详细的排序方法查看-数据结构和算法

1. 排序的分类
   - 内部排序--占用的内存比较少-可以将所有数据加载到内存中
     外部排序--占用的内存比较大-不能将所有数据加载到内存中
2. 冒泡排序--时间复杂度--O(n^2)

- 查找：常见的查找方法
  - 1.顺序查找
  - 2.二分查找

##### 多维数组

- 二维数组：一维数组的每个元素又是一维数组

- 二维数组的使用方式
  1. 动态初始化
     - 方法1
     - 数据类型[][] 数组名=new 数据类型[大小][大小]
     - int [ ] [ ] arr[][]=new int[ 5 ] [ 5 ]; //创建了一个二维数组
     - 方法2
     - 声明-定义-赋值(默认值)-使用
     - 方法3
     - 列数不确定：允许二维数组里面的每一个一维数组的列数不相同

```java
int[][] arr = new int[3][]; //创建 二维数组，但是只是确定一维数组的个数
for(int i = 0; i < arr.length; i++) {//遍历arr每个一维数组
    //给每个一维数组开空间 new
    //如果没有给一维数组 new ,那么 arr[i]就是null
    arr[i] = new int[i + 1];
    //逼历一维数组，并给一维数组的每个元素赋值
    for(int j = 0; j < arr[i].length; j++) {
    	arr[i][j] = i + 1;//赋值
    }
}
```

2. 静态初始化
   - 类型[][] 数组名 ={{值1,值2..].{值1,值2..}.{值1,值2..}}

```java
int[][] arr = {{1,1,1}, {8,8,9}, 10}; // 报错--不能把基本数据类型赋值给一维数组
// 数组是存放多个同一数据类型的数据类型
```

- 赋值的机制

![二维数组的赋值机制](.\Java入门markdown图片\二维数组的赋值机制.png)

- 注意与细节

1. 二维数组的声明方式: 
   - int[ ] [ ] [][] y
   - int[ ] y[ ]
   - int y [ ] [ ]
2. 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同-也可以不相同。比如:map[0]是一个一维数组

## C.面向对象编程：基础

### 类与对象

- 实例化/创建

```java
//1.new Cat() 创建一只猫
//2.Cat cat1 = new Cat(); 把创建的猫赋给 cat1
Cat cat1 = new Cat();
```

- 实例化类的内存使用情况

![实例化类的内存使用情况](.\Java入门markdown图片\实例化类的内存使用情况.png)

- 属性/成员变量/字段

1. 基本介绍
   - 1.从概念或叫法上看:成员变量=属性= field(即成员变量用来表示属性)
   - 2.属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象,数组)

2. 注意与细节
   - 1)属性的定义语法同变量，示例：访问修饰符 属性类型 属性名;
     	访问修饰符(后面会详细讲解)
   - public--protected--默认(什么都不加)--private
   - 2)属性的定义类型可以为任意类型：基本类型或引用类型
   - 3)属性如果不赋值，有默认值，规则和数组一致**

- 创建对象的方法

1. 先声明再创建

```java
Cat cat; //声明对象 cat
cat = new Cat(); //创建
```

2. 直接创建

```java
Cat cat = new Cat();
```

- 类和对象的内存分配机制

1. 栈:一般存放基本数据类型(局部变量)
2. 堆:存放对象(Cat cat，数组等)
3. 方法区:常量池(常量，比如字符串),类加载信息

- Java创建对象的简单流程

1. 加载xxx类信息
2. 在堆中分配空间：进行默认初始化
3. 把地址赋值给实例名：让实例名指向该地址
4. 再对属性进行初始化

### **成员方法**

- 基本介绍：在某些情况下，我们要需要定义成员方法(简称方法)。
- 创建方法

```java
class Person {
    String name;
    int age;
    //方法(成员方法)
    //添加speak 成员方法,输出“我是一个好人”
    //1. public: 表示方法是公开
    //2. void: 表示方法没有返回值
    //3.speak(): speak是方法名, () 形参列表
    //4.{} 方法体，可以写我们要执行的代码
    //5.System.out.printIn("我是一个好人"); 表示我们的方法就是输出一句话
    public void speak() {
    System.out.printIn("我是一个好人");
	}
}
```

- 方法的使用

```java
public class Methode1 {
    //编写一个main方法
    public static void main(String[] args) {
    //方法使用
    //1.方法写好后,如果不去调用(使用),不会输出
    //2.先创建对象,然后调用方法即可
    Person p1 = new Person();
    p1.speak(); //调用方法
    }
}
```

- 案例演示

```java
public class Method01 {
    public static void main(String[] args){
        Person p1 = new Person();
        p1.speak();
        p1.count(50);
        int res = p1.getAdd(37, 71);
        System.out.println("res=" + res);
	}
}
class Person {
    String name;
    int age;
    char gender;
    public void speak() {
        System.out.println("你是个好人")
    }
    public void count(int n) { // 计算前n个整数和
        int sum = 0;
        for (int i = 1; i <= n; i++){
            sum += i;
            System.out.printIn("前”+ n +“个整数的和为:”+ sum)
		}
	}
	public int getAdd(int n1, int n2) {
		System.out.println(n1 + "+" + n2 + "=" + (n1 + n2));
		return n1 + n2;
	}
}
```

- 方法的调用机制

1. 当程序执行到方法时，就会开辟一个独立的空间(栈空间)
2. 当方法执行完毕，或者执行到return语句时，就会返回(使用的栈空间也会清除)
3. 返回到调用方法的地方
4. 返回后，继续执行方法后面的代码
5. 当main方法(栈)执行完毕，整个程序退出

![方法的调用机制](.\Java入门markdown图片\方法的调用机制.png)

- 方法的好处

1. 提高代码的复用性
2. 将实现细节的封装

- 成员方法的定义

1. 参数(形参)列表:表示成员方法输入
2. 数据类型(返回类型):表示成员方法输出, void表示没有返回值
3. 方法主体:表示实现某功能的代码块
4. return语句不是必须的。

```java
public 返回数据类型 方法名 (形参列表..) {//方法体
    语句;
    return 返回值;
}
```

- 注意与细节

1. 访问修饰符：控制方法的使用范围--后面详细讲解--public--protected--默认--private
2. 返回数据类型
   - 一个方法最多有一个返回值(多个返回值存在数组里)
   - 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)
   - 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return值;而且要求返回值类型必须和return的值类型一致或兼容
   - 如果方法是void，则方法体中可以没有return语句，或者只写return ;
3. 形参列表
   - 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开,比如 getSum(int n1, int n2)
   - 参数类型可以为任意类型，包含基本类型或引用类型，比如 printArr(int[] map)
   - 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数! getSum
   - 方法定义时的参数称为形式参数，简称形参;方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致![演示]
4. 方法体
   - 里面写完成功能的具体的语句,可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法!即:方法不能嵌套定义！！
5. 方法调用的使用细节
   - 同一个类中的方法调用:直接调用即可。比如print(参数);
   - 跨类中的方法A类调用B类方法:需要通过对象名调用。比如对象名.方法名(参数);
   - 特别说明一下:跨类的方法调用和方法的访问修饰符相关--后面细讲

### **成员方法传参机制**

- 传参机制

1. 基本数据类型：传递的是值(值拷贝)--形参的改变不会影响实参
2. 引用数据类型：传递的地址的值，可以通过形参修改实参

```java
// 形参置null--不会影响方法外面的实参的引用(指向)
class B {
    public void test20(Person p) {
    	p = null;
    }
}
```

- 方法的递归调用

1. 最基本的使用：a.阶乘 b.斐波那契数列
2. 递归调用的规则
   - 1.执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
   - 2.方法的局部变量(基本数据类型)是独立的，不会相互影响,比如n变量
   - 3.如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
   - 4.递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError
   - 5.当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### 方法重载(overload)

- 基本介绍

java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致!System.out.print()可以输出各种类型的参数

- 重载的作用

1. 减轻了起名的麻烦
2. 减轻了记名的麻烦

- 注意与细节

1. 方法名:必须相同
2. 参数列表:必须不同(参数**类型或个数或顺序**，至少有一样不同，参数名无要求)--否则就是方法重复定义
3. 返回类型:无要求

### 可变参数

- 基本概念

java允许将同一个类中多个同名同功能但参数个数不同的方法,封装成一个方法。

- 基本语法

```java
访问修饰符 返回类型 方法名(数据类型...形参名){
} // 输入的可变参数可以当作数组使用
//1.int... 表示接受的是可变参数，类型是int,即可以接收多个int(0-多)
//2.使用可变参数时，可以当做数组来使用 即 nums 可以当做数组
public int sum(int... nums) {
	System.out.printIn("接收的参数个数=" + nums.length);
	return 0;
}
```

- 注意和细节

1. 可变参数的实参可以为0个或任意多个。
2. 可变参数的实参可以为数组。
3. 可变参数的本质就是数组。
4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后。

```java
//细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
public void f2(double... nums, String str) {
    
}
// 报错
```

5. 一个形参列表中只能出现一个可变参数**

```java
// 一个形参列表中只能出现一个可变参数
public void f3(double... nums1, double... nums2) {
    
}
// 报错
```

### 作用域

- 基本使用

1. 在java编程中，主要的变量就是属性(成员变量)和局部变量。
2. 我们说的局部变量一般是指在成员方法中定义的变量。
3. java中作用域的分类
   - 全局变量:也就是**属性**，作用域为整个类体 Cat类:cry eat等方法使用属性【举例】
   - 局部变量:除了属性之外的其他变量，作用域为定义它的代码块中!
4. **全局变量可以不赋值**，直接使用，因为有默认值，**局部变量必须赋值**，才能使用，因为没有默认值。

- 注意和细节

1. 属性和局部变量可以重名,访问时遵循就近原则。**
2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量,生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法调用过程中。
4. 作用范围不同
   - 全局变量:可以被本类使用,或其他类使用(通过对象调用)--在另一个类中创建类对象--给另一个传入一个类对象
   - 局部变量:只能在本类中对应的方法中使用
5. 修饰符不同
   - 全局变量/属性可以加修饰符
   - 局部变量不可以加修饰符

### **构造器/构造方法**

- 基本需求

在创建类的时候完成属性的赋值

- 基本语法

1. 构造器可以有修饰符
2. 构造器没有返回值
3. 方法名和类名字必须一样
4. 参数列表和成员方法一样的规则
5. 构造器的调用系统完成

```java
[修饰符] 方法名(形参列表){
	方法体;
}
```

- 基本介绍

1. 构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成：新对象的初始化。
2. 方法名和类名相同
3. 没有返回值
4. 在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化。

- 注意与细节

1. 构造器可以重载
   比如:我们可以再给Person类定义一个构造器,用来创建对象的时候,只指定人名,不需要指定年龄

2. 构造器名和类名要相同--构造器的形参名不能和属性名重名

   ```java
   //如果我们构造器的形参，能够直接写成属性名，就更好了
   //但是出现了一个问题，根据变量的作用域原则
   //构造器的name 是局部变量，而不是属性
   //构造器的age 是局部变量，而不是属性
   public Dog(String name, int age) {//构造器
       name = name ;
       age = age;
   }
   ```

3. 构造器没有返回值

4. 构造器是完成对象的初始化--并不是创建对象

5. 在创建对象时,系统自动的调用该类的构造方法：自己主动调用会出错

   ![默认构造器的反编译](.\Java入门markdown图片\默认构造器的反编译.png)

6. **如果没有定义构造方法，系统会自动给类生成一个默认无参构造方法(也叫默认构造方法)：使用javap指令反编译查看**

7. **自己定义了构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非自己显式的定义一下。**

### 对象创建的流程

- 案例演示

```java
class Person {//类Person
    int age=90;
    String name;
    Person(String n,int a){//构造器
        name=n;//给属性赋值
        age=a;//..
    }
}
Person p=new Person("小情20", 20);
```

![对象创建的内存分配](.\Java入门markdown图片\对象创建的内存分配.png)

1. 在方法区加载类方法
2. 在堆中分配内存空间(地址)
3. 初始化(声明)属性--age--name-->执行属性赋值语句(age=90)->执行构造器->初始化属性
4. 把对象在堆中的地址返回给对象名(对象引用)

### this关键字

- this关键字的引出

1. 想要实现构造方法的局部变量名和属性名相同

```java
class Person {
    String name;
    int age;
    public Person(String name, int age){
        this.name = name ;
        this.age = age;
	}
}
```

2. java虚拟机会给每个对象分配this--代表当前对象：可以用hashcode()查看是否是同一地址

- 注意和细节

1. this关键字可以用来访问本类的属性、方法、构造器
   - 继承的时候--两种方法略有区别
   - this.属性--访问本类的属性
   - 变量名--**就近原则访问**

```java
public void f1() {
	System.out.println("f1() 方法..");
}
public void f2() (
    System.out.printIn("f2() 方法..");
    //调用本类的 f1
    //第一种方式
    f1();
    //第二种方式
    this.f1();
}
// 传统方法
System.out.println("name=" + name + "num=" + num);
// 也可以使用this访问属性
System.out.println("name=" + this.name + "num=" + this.num);
```

2. this用于区分当前类的属性和局部变量
3. 访问成员方法的语法:this.方法名(参数列表);
4. **访问构造器语法:this(参数列表);注意只能在构造器中使用--只能在构造器中使用--使用this()访问构造器的方法-必须放在构造器语句块的第一行(与继承有关)

![this在构造器中的调用](.\Java入门markdown图片\this在构造器中的调用.png)

5. this不能在类定义的外部使用，只能在类定义的方法中使用

### 章节作业

- String.equals()--判断字符串是否相等

```java
public int find(string findstr, string[] strs) {
	//直接遍历
    for(int i = 0; i < strs.length; i++) {
    	if(findStr.equals(strs[i])) {
    		return i;
        }
    }
}
```

- 数学中的pi：Math.PI
- 匿名对象

```java
//1. new Test() 是匿名对象，匿名对象使用后，就不能使用
//2. new Test().count1() 创建好匿名对象后，就调用count1()
new Test().count1();
```

- 每个类可以有main方法

- 构造器的使用

1. **访问构造器语法:this(参数列表);注意只能在构造器中使用--只能在构造器中使用--使用this()访问构造器的方法-必须放在构造器语句块的第一行(与继承有关)
2. 这样使用会报错

```java
// 这样使用会报错
public Employee(sting job, double sal, Sting name, char gender, int age) {
    this(name, gender, age);//使用到 前面的 构造器
    this(job, sal);
}
```

## D.面向对象编程：中级

### IDE

- IntelliJ IDEA：的基本使用

1. 字体修改：
   - 界面字体：Setting->apperance
   - coding字体
   - 字体加粗：setting--editor--font
2. 主题修改：主题颜色
3. 字符编码：
   - Setting--Editor--File Encodings--UTF-8
   - 只有dos控制台用GBK
4. 运行时会生成一个out文件--class文件保存在该目录下--原码保存在src文件下
5. 常用的快捷键--可以自己修改(setting--keymap)
   - 删除当前行--ctrl + Y
   - 复制当前行--ctrl + D
   - 补全代码--alt + /
   - 导入该行需要的类--先配置auto import--然后使用alt+enter即可
   - 代码快速格式化--ctrl + alt + L
   - 程序允许快捷键
   - 生成构造器等alt + insert[提高开发效率]--generater
   - 自动创建变量名-- .var
   - **(超级有用)**模板快捷键file->setting->editor->Live templates
   - 快速创建代码--Crtl+alt+T
   - 查看一个类的层级关系ctrl +H 学习继承后，非常有用

- Eclipse

### 包

- 包的三大作用

1. 区分相同名字的类--同名类放在不同的包下---不能同时引用两个同名的类-会报错---可以用不同的包区分
   - com.zyp:表示创建com文件目录下还有zyp文件
2. 当类很多时,可以很好的食理类[看Java API文档]
3. 控制访问范围

- 包的基本语法
  - package com.Usetcedu; package打包关键字 XXX包名
- 包的本质：创建不同的文件夹来保存文件
- 包的命名规则

1. 只能包含数字、字母、下划线、小圆点.不能用数字开头，不能是关键字或保留字
2. 规范：一般是com.公司名称.项目名称.业务模块名称

![包的命名规则](.\Java入门markdown图片\包的命名规则.png)

- Java中常用的包

1. java:lang. *//lang包是基本包,默认引入,不需要手动引入
2. java.util. * //util 包，系统提供的工具包，工具类，使用Scanner
3. java.awt. * //是做java的界面开发,GUI
4. java.net. * M/网络包，网络开发

- 包的使用细节

1. 基本语法
   - import 包
   - import java.util.Scanner;只引用Scanner一个类--通常用该种方法--使用什么类就导入什么类
   - import java.util.*;导入util下的所有类

- 注意与细节

1. package的作用是声明当前类所在的包--需要放在class的最上面--一个类中最多只有一句package(只能在一个目录下面)

```java
package com.hspedu.pkg;
```

2. import指令位置放在package的下面，在类定义前面,可以有多句且没有顺序要求。

### 访问修饰符

- 基本介绍

1. java提供四种访问控制修饰符号控制方法和属性(成员变量)的访问权限（范围)
2. 公开级别:用public修饰,对外公开
3. 受保护级别:用protected修饰,对子类和同一个包中的类公开
4. 默认级别:没有修饰符号,向同一个包的类公开
5. 私有级别:用private修饰,只有类本身可以访问,不对外公开

- **访问修饰符的访问范围**：背下来

默认--不同包的子类不能访问--相同包可以访问

![访问权限1](.\Java入门markdown图片\访问权限1.png)

![访问权限2](.\Java入门markdown图片\访问权限2.png)

- 注意

1. 修饰符可以用来修饰类中的属性，成员方法以及类
2. **只有默认的和public才能修饰类!并且遵循上述访问权限的特点。
3. 成员方法的访问规则和属性完全一样

### 面向对象的三大特征：**封装**

- 简单的操作

封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起,数据被保护在内部,程序的其它部分只有通过被授权的操作[方法],才能对数据进行操作。

- 封装的好处

1. 隐藏实现细节:方法(连接数据库)<--调用(传入参数..)
2. 可以对数据进行验证，保证安全合理

- 封装实现的步骤

1. 将属性进行私有化【不能直接修改属性】
2. 提供一个公共的set方法(public)，用于对属性判断并赋值

```java
public void setXxx(类型参数名){
//加入数据验证的业务逻辑
    属性=参数名;
}
```

3. 提供一个公共的get方法(public)，用于获取属性的值

```java
public XX getXxx(){//权限判断
	return xx;
}
```

4. 封装的方法可以配合构造器使用

### 面向对象的三大特征：**继承**

- 解决问题

1. 两个类的属性和方法有很多相同的地方
2. 继承：提高代码的复用性

- 基本介绍

1. 继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。
2. 继承的示意图

![继承示意图](.\Java入门markdown图片\继承示意图.png)

- 基本语法

1. 子类就会自动拥有父类定义的属性和方法
2. 父类又叫超类，基类。
3. 子类又叫派生类。

```java
class 子类 extends 父类{
    
}
```

- 注意与细节

1. 子类继承了所有的属性和方法(但是不能直接访问所有)，非私有属性可以直接访问，但是私有属性不能在子类直接访问，要通过父类提供的公共的方法去访问
2. **子类必须调用父类的构造器**,完成父类的初始化--无参数构造器会默认调用父类的无参构造器--super();
   - 父类没有无参构造器需要显式调用
3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
   - 父类没有设置构造器是会内置一个无参构造器--当父类写了一个有参构造器之后-内置的无参构造器就会被取消
4. 如果希望指定去调用父类的某个构造器,则显式的调用一下
5. super在使用时，需要放在构造器第一行
6. super()和 this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器--二选一
   - this()可以使用本类的其他构造器
7. java所有类都是Object类的子类
  - ctrl+H快捷键可以查看继承关系

8. 父类构造器的调用不限于直接父类!将一直往上追溯直到Object类(顶级父类)--从最顶层的构造器开始
9. 单继承机制--子类最多只能继承一个父类(指直接继承)--可以间接继承
10. 不能滥用继承,子类和父类之间必须满足is-a的逻辑关系

- **继承的本质**

继承信息的查找规范

1. 首先看子类是否有该属性
2. 如果子类有这个属性，并且可以访问，则返回信息
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到0bject.. .

![继承的本质2](.\Java入门markdown图片\继承的本质2.png)

![继承的本质1](.\Java入门markdown图片\继承的本质1.png)

### 面向对象的三大特征：**多态**

- 问题引出：同一个方法有很多种输入--不利于管理
- 基本介绍：多态--方法或对象具有多种形态。
- 对象多态的具体体现

1. 一个对象的编译类型和运行类型可以不一致(父类的运行类型可以是子类)  等号左边是编译类型--右边是运行类型

```java
Animal animal = new Dog();
// 编译时animal是Aniaml，运行是animal是Dog
animal,cry();
// animal变成了cat
animal = new Cat();
animal.cry();

// animal 编译类型就是 Animal, 运行类型 Dog
Animal animal = new Dog();
animal.cry(); //因为运行时,这时就执行到该行时，animal运行类型是Dog

//使用多态机制，可以统一的管理主人喂食的问题
//animal 编译类型是Animal,可以指向(接收) Animal子类的对象
//food 编译类型是Food ,可以指向(接收) Food子类的对象
public void feed(Animal animal， Food food) {
System.out.println("主人 “ + name + " 给“ + animal.getName() + " 吃" + food);
}
```

2. 编译类型在定义对象时，就确定了，不能改变
3. 运行类型是可以变化的.
4. 编译类型看定义时=号的左边,运行类型看=号的右边

- 注意与细节

1. 多态的前提--两个类存在继承关系

2. 多态的向上转型：属性看编译-方法从子类开始找

   1)本质:父类的引用指向了子类的对象

   2)语法:父类类型 引用名= new 子类类型();

   3)特点:

   1.编译类型看左边，运行类型看右边
   2.可以调用父类中的所有成员(需遵守访问权限)，不能调用子类中特有成员(只有子类才用的方法和属性)
   	因为在**编译阶段**，能调用哪些成员，是由编译类型决定的
   3.最终运行效果看子类的具体实现
   	与前面一致：从子类开始查找方法

```java
//animal.catchMouse();错误
//最终运行效果看子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法
//然后调用，规则与前面讲的方法调用规则一致。
animal.eat();//狱吃鱼..
animal.run();//跑
animal.show();//hello,你好
animal.sleep();//睡
```

3. 多态的向下转型

   1)语法:子类类型 引用名 = (子类类型) 父类引用;

   ```java
   Cat cat = (Cat) animal;
   ```

   2)只能强转父类的引用,不能强转父类的对象--只是转换了引用-没有改变对象的本质

   3)要求父类的引用必须指向的是当前目标类型的对象(和强转的目标是同一个类)

   	//animal声明的时候必须指向强转的类型
   	Animal animal = new Cat();
   	Cat cat = (Cat) animal;

   4)向下转型后--可以调用子类类型中所有的成员

4. 属性重写？属性没有重写之说
   	**属性的值看--编译类型

5. instanceOf--比较操作符

   用于判断对象的(运行)类型是否为XX类型或XX类型的子类型

```java
Student d1 = new Doctor();
System.out.println(d1.age);
System.out.printin(d1 instanceof Student);
```

6. **动态绑定机制***超级无敌重要**
   	1.当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
   	2.当调用对象属性时,没有动态绑定机制--哪个类的方法就用那个类的属性(就近访问)

- 多态的应用
  1. 数组的定义类型为父类类型,里面保存的实际元素类型为子类类型--利用动态绑定机制-使用不同子类的方法--想调用子类的特有方法就向下转型-再调用
  2. 多态参数--方法定义的形参类型为父类类型，实参类型允许为子类类型

### 关键字：super

- 基本介绍

1. super代表父类的引用，用于访问父类的属性、方法、构造器
2. 方法重载：体现多态

```java
//方法重载体现多态
A a = new A():
//这里我们传入不同的参数，就会调用不同sum方法，就体现多态
System.out.println(a.sum(10，20));
System.out.println(a.sum(10，20，30));
```

3. 方法的重写：体现多态

```java
//方法重写体现多态
B b = new B():
a.say();
b.say();
```

- 基本语法

1. 访问父类的属性，但不能访问父类的private属性[案例]
   super.属性名;
2. 访问父类的方法，不能访问父类的private方法
   super.方法名(参数列表);
3. 访问父类的构造器:
   super(参数列表);只能放在构造器的第一句，**只能出现一句**!

- 注意与细节
  	1.调用父类构造器--明确分工--父类的属性-父类初始化--子类的属性-子类初始化
  	2.当子类中有和父类中的成员（属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果!
  	3.super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员;如果多个基类中都有同名的成员，使用super访问遵循就近原则。A->B->C

- super和this的对比

![super和this的对比](.\Java入门markdown图片\super和this的对比.png)

### overwrite：方法重写/方法覆盖

- 基本介绍：方法覆盖(重写)就是子类有一个方法和父类的某个方法的名称、返回类型、参数一样，则子类的这个方法就覆盖了父类的方法
- 注意与细节

1. 子类方法的形参列表，方法名称和父类方法的形参列表,方法名称完全一样。
2. 子类方法的返回类型和父类方法返回类型一样或者是父类返回类型的子类--比如父类返回类型是Object,子类方法返回类型是String。

```java
public object getInfo(){
public string getInfo(){
```

3. 子类方法不能缩小父类方法的访问权限--可以扩大

### Object类详解

- Object类是所有类的基类
- 常用方法

1. equals(obj)方法

a. == 是比较运算符
可以判断基本类型和引用类型
基本类型：判断值是否相等
引用类型：判断地址是否相等(判断是否是同一个对象)
b. equals方法

equals方法是Object类中的方法，只能判断**引用类型--如何看Jdk源码
		源码查看方法
			设置源码位置file--Project Structure--SDKs--SourcePath
			ctrl+b查看
默认判断(Object中)的是地址是否相等,子类中往往重写该方法，用于判断内容是否相等。比如Integer,String(源码中查看)

2. hashCode方法--获取对象的哈希码--整数
   - 1)提高具有**哈希结构的容器的效率
   - 2)两个引用
     如果指向的是同一个对象，则哈希值相同
     如果指向的是不同对象，则哈希值不同(可能出现哈希碰撞)
   - 3)哈希值主要根据地址号获得--但不等价于地址
   - 4)在集合部分--有需要会重写hashCode

![HashCode](.\Java入门markdown图片\HashCode.png)

3. toString方法
   - 默认返回:全类名+@+哈希值的十六进制--查看Object的toString方法--子类往往重写toString方法,用于返回对象的属性信息
   - 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式.
   - 当直接输出一个对象时,toString方法会被默认的调用
     System.out.println(xxx对象)

![toString](.\Java入门markdown图片\toString.png)

4. Finalize方法--开发中通常不会使用该方法-面试会问
   - 1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法--可以写入一些业务逻辑相关的代码(比如-释放数据库的连接)
   - 2.什么时候被回收--当某个对象没有任何引用时,jvm就认为这个对象是一个垃圾对象,就会使用垃圾回收机制来销毁该对象,在销毁该对象前,会先调用finalize方法。
   - 3.垃圾回收机制的调用，是由系统来决定,也可以通过System.gc()主动触发垃圾回收机制
     		垃圾回收机制有自己的运行逻辑--不是有垃圾马上就回收

### IDE：断点调试(debug)

- 实际需求

1. 在开发过程中一步一步的查看源码
2. 在实际运行过程中--对象是以运行类型来执行的

- 断点调试快捷键

1. F7--跳入--跳入方法内
2. F8--逐行执行
3. shift+F8--跳出方法--回到原先进入的位置
4. F9--执行到下一个断点
5. alt+shift+F7--强制跳入--查看源码
   - 或者修改IDE的设置--允许F7进入源码
   - Setting--Build-Execution,Deployment--Debugger--Stepping
   - 选上java. * 和 javax. *

### 本章作业

- 变量名的对象改变，动态绑定机制也相应变化

```java
AAA obj = new BBB();//向上转型
AAA b1 = obj;
System.out.println("obj的运行类型=” + obj.getclass());//BBB
obj = new CCC();//向上转型
obj.xxx();
System.out.println("obj的运行类型=” + obj.getclass());//CCC
obi = b1;
obj.yyy();
System.out.println("obj的运行类型=" + obj.getclass());//BBB
```

- 1.方法多态
  (1)重载体现多态(2)重写体现多态
- 2.对象多态
  (1)对象的编译类型和运行类型可以不一致，编译类型在定义时，就确定，不能变化
  (2)对象的运行类型是可以变化的,可以通过getClasss()来查看运行类型
  (3)编译类型看定时时=号的左边，运行类型看=号右边

### 补充知识

- Java的API文档(Application Programming Interface)--Java提供的基础类可以通过文档查询--文档可以查询提供的类和类里面的方法

1. Java 8 API
   		https://www.matools.com/api
2. JDK下面有多个包--包里面包含接口-类-异常处理
   		类包含-字段-构造器(构造方法)-成员方法

- 字符串是否相等的比较--使用equals方法

```java
System.out.printIn(name.equals("林黛玉"));//T
System.out.printIn("林黛玉".equals(name));//T [推荐，可以避免空指针]
```

## E.第一阶段项目

- 零钱通
  	面向过程->面向对象
- 房屋出租系统：与零钱通类似的文本界面

1. 模式管理方式->分层管理--一个层次的类放在一个包里
   - HouseView.java(界面层)
     1.显示界面
     2.接受用户的输入
     3.调用其他类(HouseView)对房屋信息完成各种操作
   - HouseService.java(业务层)
     1.响应HouseView的调用
     2.完成房屋信息的增删改查-C(create)R(read)U(update)D(delete)
   - House.java(model)
     1.一个house对象就是一个房屋信息
   - HotelApp(业务入口)
   - Tools.java(工具类)
     公司会提供相应的工具类和发开库--提高开发效率
   - House.java(数据层)
2. 实现功能的三个步骤-明确功能-思路分析-代码实现

# 第二阶段

## 面向对象编程：高级

### 类变量和类方法

- 类变量(静态变量/静态属性)和类方法(静态方法)：可以直接通过类名.变量/方法访问

#### 类变量/静态变量/静态属性

- 基本概念：类变量也叫静态变量/静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量。
- 基本语法

1. 定义方法
   - 访问修饰符 static 数据类型 变量名;[推荐]
   - static 访问修饰符 数据类型 变量名;
   - 访问修饰符的权限和普通属性一致
2. 访问方法
   - 类名.类变量名[推荐]
   - 对象名.类变量名

- 特点

1. static修饰
2. 最大的特点就是会被该类的所有的实例对象共享

- 内存布局：静态变量的两种说法

1. 在堆区域(红色)-jdk8以后
2. 在静态方法区(蓝色)-jdk8及以前

![静态变量内存布局](.\Java入门markdown图片\静态变量内存布局.png)

- 注意与细节

1. 使用场景：需要所有对象都访问该变量时
2. 类变量与实例变量(普通属性)区别
   - 类变量是该类的所有对象共享的，而实例变量是每个对象独享的。
3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量
4. 类变量可以通过类名.类变量名或者对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问。(前提是满足访问修饰符的访问权限和范围)
5. 实例变量不能通过类名.类变量名方式访问
6. 类变量是在类加载时就初始化了，即使你没有创建对象，只要类加载了，就可以使用类变量。
7. 类变量的生命周期是随类的加载开始，随着类消亡而销毁。

#### 类方法/静态方法

- 基本介绍

1. 基本语法
   - 访问修饰符 static 数据返回类型 方法名(){} [推荐]
   - static 访问修饰符 数据返回类型 方法名(){}
2. 调用方法
   - 类名.类方法名或者对象名.类方法名 [前提是满足访问修饰符的访问权限和范围]

- 使用场景

1. 当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法,提高开发效率。
2. 比如：utils类，Math类，Arrays类，Collections集合类

- 注意与细节

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:类方法中无this的参数--普通方法中隐含着this的参数
2. 类方法可以通过类名调用，也可以通过对象名调用。
3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数),不能通过类名调用。
4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以。
5. **类方法(静态方法)中只能访问静态变量或静态方法。**
   - 静态方法只能访问静态成员(变量和方法)
6. 普通成员方法，既可以访问普通成员，也可以访问静态成员。[遵守访问权限]

- 练习题

```java
class Person{
    private int id;
	private static int total = 0;
	public static void setTotalPerson(int total){
		// this.total = total://错误，因为在static方法中，不可以使用this 关键字
		Person.total = total;
    }
    public Person() {//构造器
        total+ +:
        id = total;
    }
}
public class TestPerson {
    public static void main(String[] args) {
        Person.setTotalPerson(3);
        new Person();//最后 total的值就是4
    }
}
```

### main方法

- 理解main方法的语法(static)
- 深入理解main方法

1. 解释main方法的形式:public static void main(String[] args){}

2. main()方法是JVM调用，该方法的访问权限**必须是public

3. java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static

4. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数

5. java 执行的程序--参数1参数2参数3

   - dos指令传参数

     ![main函数传参1](.\Java入门markdown图片\main函数传参1.png)

     ![main函数传参2](.\Java入门markdown图片\main函数传参2.png)

   - Idea的传参位置

<img src=".\Java入门markdown图片\main函数传参3.png" alt="main函数传参3" style="zoom: 67%;" />

- 注意与细节

  main方法只能访问静态成员--实例化对象后可以使用普通成员

### 代码块

- 基本介绍

1. 代码化块又称为初始化块,属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。
2. 但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用,而是加载类时，或创建对象时隐式调用。

- 基本语法

```java
[修饰符]{
	代码
};
```

1. 修饰符可选--但**只能写static**
2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰叫普通代码块.
3. 逻辑语句可以为任何逻辑语句(输入、输出、方法调用、循环、判断等)
4. 最后的 ; 可以写--可以省略。

- 代码块的理解

1. 构造器的补充--初始化的操作
2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性
3. 代码块的调用在构造器调用之前

- **注意与细节**

1. static代码块也叫静态代码块--对类进行初始化，而且它随着**类的加载**而执行--只会执行一次。
   普通代码块，每创建一个对象就执行一次。
2. **类的加载时间**[**重要**]
   - a.创建对象实例时(new)
   - b.创建子类对象实例，父类也会被加载(而且父类先被加载)
   - c.使用类的静态成员时(静态属性,静态方法)
3. 普通的代码块，在创建对象实例时,会被隐式的调用--被创建一次就会调用一次。使用类的静态成员时，普通代码块并不会执行。
4. 创建一个对象时，在**一个类调用顺序**是(**重/难点**)∶a->b->c
   - a.调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)--谁写在前面-谁先执行
   - b.调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)
   - c.调用构造方法。
5. 构造方法(构造器)的最前面其实隐含了super()和调用普通代码块--静态相关的代码块，属性初始化-在类加载时就执行完毕--优先于构造器和普通代码块执行
6. 面试题***创建一个子类对象时(继承关系)-静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下:
   - ①父类的静态代码块和静态属性(优先级一样,按定义顺序执行)--一直追寻到最顶级的父类
   - ②子类的静态代码块和静态属性(优先级一样，按定义顺序执行)
   - ③父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
   - ④父类的构造方法
   - ⑤子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
   - ⑥子类的构造方法
     - 创建一个实例对象的顺序
     - 1.类加载--父类的静态代码(静态代码块-静态成员)-子类的静态代码
     - 2.普通代码加载-父类普通成员-父类构造方法-子类普通成员-子类构造方法
7. 静态代码块只能直接调用静态成员(静态属性和静态方法),普通代码块可以调用任意成员。

- 小结：普通代码块-对象创建时执行--静态代码块-类加载时执行

### 单例设计模式

- 什么是设计模式

1. 静态方法和属性的经典使用
2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。

- 基本概念

1. 类的单例设计模式--采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
2. 单例模式有两种方式:
   - 1)饿汉式
   - 2)懒汉式

- 单例模式应用实例

1. 构造器私有化
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法
4. 代码实现
5. Runtime类--内置类--饿汉式

- 饿汉式：还没使用就已经创建了

1. 将构造器私有化
2. 在类的内部直接创建对象(static)
3. 提供一个公共的static方法，返回对象

```java
//只能有一个女朋友
class GirlFriend {
    private String name;
	private GirlFriend gF = new GirFriend("小红红")
//如何保障我们只能创建一个 GirTFriend 对象
//步骤
//1。将构造器私有化
//2。在类的内部直接创建
//3。提供一个公共的static方法，返回 gf对象
    private GirlFriend(String name) {
    	this.name = name;
    }
    public static GirlFriend getInstance() {
    	return gf;
    }
}
```

- 懒汉式--使用才创建

1. 构造器私有化
2. 定义一个static静态属性对象
3. 提供一个public的static方法，可以返回一个对象
4. 懒汉式--只有常用户使用getInstance时，才返回对象，后面再次调用时，任然返回第一次的对象

```java
class Cat {
    private String = name;
    private static Cat cat ;
//步骤了
//1.仍然构造器私有化
//2.定义一个static静态属性对象
//3.提供一个public的static方法，可以返回一个Cat对象
    private Cat(String name) {
    	this.name = name;
    }
    public static Cat getInstance() {
        if(cat == null) {//如果没有创建cat封象
        	cat = new Cat("小可爱");
        }
    }
    return cat;
}
```

才能在线程安全问题--后续讲解

### 关键字：final

- 基本介绍

1. 当不希望类**被继承**时,可以用final修饰
2. 当不希望父类的某个**方法****被子类覆盖/重写(override)**时,可以用final关键字修饰
3. 当不希望类的的某个**属性**的值**被修改**，可以用final修饰
4. 当不希望某个局部变量被修改，可以使用final修饰

- 注意与细节

1. final修饰的属性又叫常量,一般用XX_XX_XX来命名
2. final修饰的**属性**在定义时,**必须赋初值**,并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】:
   ①定义时:如public final double TAX_RATE=0.08;
   ②在**构造器**中
   ③在**代码块**中。
3. 如果final修饰的属性是静态的，则初始化的位置只能是
   ①定义时 ②在静态代码块 ③不能在构造器中赋值。
   静态属性--在类加载时就需要完成初始化
4. final类不能继承,但是可以实例化对象。[A2类]
5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。
6. 一个类是final类就没有必要再将方法修饰成final方法--继承都不存在-更没有方法重写
7. final不能修饰构造方法/构造器
8. final和static往往搭配使用，效率更高，底层编译器做了优化处理。
9. 包装类(Integer,Double,Float,Boolean等都是final),String也是final类。

### 抽象类

- 基本介绍：当父类不能明确方法的具体作用时可以写为抽象方法--当一个类中存在抽象方法时-该类必须是抽象类(abstract)

```java
public abstract void eat()
```

1. 用abstract 关键字来修饰一个类时,这个类就叫抽象类

	访问修饰符 abstract 类名{
	}
2. 用abstract关键字来修饰一个方法时,这个方法就是抽象方法
   - 访问修饰符 abstract 返回类型 方法名(参数列表)
   - 抽象方法没有方法体
3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()
4. 抽象类：考官比较爱问的知识点--在框架和设计模式使用较多**

- 注意与细节

1. 抽象类**不能被实例化**
2. 抽象类不一定要包含abstract方法--抽象类可以没有abstract方法
3. 类包含了abstract方法,则这个类必须声明为abstract
4. abstract只能修饰**类和方法**，不能修饰属性和其它的
5. 抽象类可以有任意成员【抽象类本质还是类】,比如:非抽象方法、构造器、静态属性等等
6. 抽象方法不能有方法体，即不能实现
7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类
8. **抽象方法不能使用private、final和 static来修饰，因为这些关键字都是和重写相违背的。**

- 抽象类的最佳实践：模板设计模式

1. 父类实现时间的计算

```java
abstract public cLass Template { //抽象类-模板设计模式
	public abstract void job();//抽象方法
	public void calculateTime() {//实现方法，调用job方法
        //得到开始的时间
        long start = System.currentTimeMillis():
        job();
        //得的结束的时间
        Long end = System.currentTimeMillis():
        System.out.println("AA 执行时间 + (end - start));
	}
}
```

2. 子类重载job()方法--可以计算所有子类的运行时间--提高代码的复用性--子类动态绑定

### 接口(interface)

- 快速入门

1. 定义接口：确定相关的内容和规范

```java
public interface UsbInterface { //接口
    //规定接口的相关方法，老师规定的。
    public void start();
    public void stop();
}
```

2. 实现接口：实现接口的相关方法

	public class Camera implements UsbInterface {//实现接口,就是把接口方法实现
	    @Override
	    public void start() {
	    	System.out.println("相机开始工作...");
	    }
	    @Override
	    public void stop() {
	    	System.out.println("相机停止工作....");
	    }
	}

3. 通过接口调用方法

```java
public class Computer {
    //编写一个方法，计算机工作
    public void work(UsbInterface usbInterface) {
        //通过接口，来调用方法
        usbInterface.start();
        usbInterface.stop() ;
    }
}
```

- 基本介绍：接口就是提出一些没有实现的方法--封装--某个类要使用时,根据具体情况把这些方法实现。
- 基本语法

```java
interface 接口名{
//属性
//方法(抽象方法/默认实现/静态方法)
}
class 类名 implements 接口{
    自己属性;
    自己方法;
    必须实现的接口的抽象方法
}
public interface AInterface {
//写属性
    public int n1 = 10;
    //写方法
    //在接口中，抽象方法，可以省略abstract关键词
    public void hi();
    //在jdk8后，可以有默认实现方法，需要使用default关键词
    default public void ok() {
    	System.out.println("ok ...");
    }
    //都jdk8后，可以有静态方法
}
```

注意：在JDK7以前接口的方法没有方法体--JDK8以后接口可以有静态方法/默认方法/方法的具体实现(需要加default)--必须实现的接口的抽象方法

- 接口应用场景：规定方法的调用名--同一管理不同类的相同方法
- 注意与细节

1. 接口**不能被实例化**
2. 接口中所有的方法是**public方法**，接口中抽象方法，可以不用abstract修饰:
3. **普通类**实现接口--必须将该接口的所有方法都实现。
4. **抽象类**实现接口，可以不用实现接口的方法。
5. 接口中的**属性**,只能是**final**的，而且是 **public static final修饰符**。
   比如:int a=1;实际上是public static final int a=1;(必须初始化)
6. 接口中属性的访问形式:接口名.**属性名**
7. 一个类同时可以实现多个接口--直接实现多个接口
8. **一个接口不能继承其它的类,但是可以继承多个别的接口**
9. 接口的修饰符只能是 public和默认，这点和类的修饰符是一样的。

- 实现接口和继承类的区别

1. 实现接口--是Java对单继承机制的补充--实现父类以外的方法
2. 解决不同问题
   - 继承--解决代码的复用性和可维护性。
   - 接口--设计好各种规范(方法)，让其它类去实现这些方法。
3. 满足关系
   - 继承--is a
   - 接口--like a
4. 接口在一定程度上可以实现代码的解耦

- 接口的多态特性

1. 多态参数：如前面的例子-可以接收手机对象又可以接收相机对象-就体现了接口多态(接口引用/形参可以指向实现该接口的对象实例/类对象)

```java
//1.UsbInterface usbInterface 形参是接口类型 UsbInterface
//2.看到 接收 实现了 UsbInterface接口的类的对象实例
public void work(UsbInterface usbInterface) {
    //通过接口，来调用方法
    usbInterface.start();
    usbInterface.stop();
}
```

```java
//接口的多态体现
//接口类型的变量 ifo1 可以指向 实现了IF接口的对象实例
IF if01 = new Monster():
if01 = new Car():
interface IF {}
class Monster implements IF{}
class Car implements IF{}
```

2. 多态数组

```java
//多态数组 -> 接口类型数组
Usb[] usbs = new Usb[2]:
usbs[o] = new Phone_() ;
usbs[1] = new Camera_():
interface Usb{}
class Phone_ implements Usb {}
class Camera_ implements Usb {}
// 向下转型--instanceof-判断运行类型
```

3. 接口存在**多态传递现象.

```java
IG ig = new Teacher();
IH ih = new Teacher();
interface IH
interface IG extends IH{}
class Teacher implements IG {}
```

- 练习题

```java
interface A{
	int x = 0; } //想到 等价 public static final int x = 0:
class B{
	int x = 1; }//普通属性
class C extends B implements A {
	public void pX() {
        System.out.println(x); //问题
    }
    public static void main(Stringll args) {
    	new C().pX();
    }
}
```

1. 需要明确指明x是谁的x--不然会报错
   - 接口的x--A.x
   - 父类的x--super.x

### 内部类(重难点)

- 类的五大成员--1.属性-2.方法-3.构造器-4.代码块-5.内部类
- 基本介绍
  	一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系
- 基本语法

```java
class Outer{//外部类
	class Inner{//内部类
	}
}
class Other{//外部其他类
}
```

#### 内部类的分类

##### 定义在外部类局部位置上(比如：方法内)

###### 1)局部内部类（有类名)

- 说明

1. 可以直接访问外部类的所有成员，包含私有变量
   内部类本质还是类
2. **不能添加访问修饰符**：相当于一个局部变量。**局部变量是不能使用访问修饰符**，但是可以使用**abstract/final修饰**，因为局部变量可以使用final修饰。
3. 作用域:仅仅在定义它的**方法/代码块中。
4. 局部内部类--访问->外部类的成员[访问方式:直接访问]
5. 外部类--访问->局部内部类的成员
   访问方式:创建对象,再访问(注意:必须在作用域内)
6. 外部其他类--不能访问->局部内部类（因为局部内部类地位是一个局部变量)
7. 如果外部类和局部内部类的成员重名时,默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问
   外部类名.this.成员
   外部类名.this--相当于一个对象---谁调用局部内部类所在的方法--谁就是外部类名.this-指的对象--可以使用hashcode验证

###### 2)匿名内部类(没有类名**重点)(AnonymousInnerClass)

- 说明
  	四个关键点：本质还是类--内部类--没有名字(系统会分配一个名字)--是一个对象

- 基本语法

```java
new 类或接口(参数列表){
	类体
}
```

- 快速入门

1. 类只使用一次-后面不再使用--避免写很多类
2. 匿名内部类创建一次该类就消失了--但是创建的对象可以反复使用
3. 基于接口
   - 编译类型--IA
   - 运行类型--匿名内部类
   - 可以使用--类名.getClass()来查看底层分配的类名--一般是外部类名$X

```java
class Outer04 {//外部类
    private int n1 = 10;//属性
    public void method() {//方法
        //基于接口的匿名内部类
        //解读
        //1.需求: 想使用IA接口,并创建对象
        //2.传统方式，是写一个类，实现该接口，并创建对象
        //3.需求是 Tiger/Dog 类只是使用一次，后面再不使用
        //4.可以使用匿名内部类来简化开发
        IA tiger = new Tiger();
        tiger.cry();
	}
}
interface IA {//接口
	public void cry();
}
class Tiger implements IA {
    @Override I
    public void cry() {
		System.out.println("老虎叫唤...");
    }
}
class Dog implements IA{
    @Override
    public void cry() {
    	System.out.println("小狗汪汪...");
    }
}
// ---------------
//5.tiger的编译类型 ? IA
//6.tiger的运行类型 ? 就是匿名内部类
/*
我们看底层
class XXXX implements IA {
    @Override
    public void cry() {
    System.out.println("老虎叫唤...")
    }
}
*/ 
IA tiger = new IA() {
    @Override
    public void cry() {
    System.out.println("老虎叫唤...");
}
```

4. 基于类(抽象类)
   - 形参列表会传递给类的构造器
   - 基于抽象类的匿名内部类必须实现抽象方法

```java
//1. father编译类型 Father
//2.father运行类型 0uter04$2
//3.底层会创建匿名内部类
/*
    class Outer0412 extends Father{
        @Override
        public void test() {
        	System.out.println("匿名内部类重写了test方法");
        }
	}
*/
Father father = new Father("jack"){
    @Override
    public void test() {
    	System.out.println("匿名内部类重写了test方法");
    }
}
```

- 注意和细节

1. 匿名内部类的语法具有--类定义和创建对象的特征--既是一个类的定义-同时本身也是一个对象
   - 可以直接调用--匿名内部类本身也是返回对象

```java
new Person(){
    @Override
    public void hi() {
    	System.out.printLn("匿名内部类重写了 hi方法,哈哈...")
    @Override
    public void ok(string str) {
    	super.ok(str);
    }
}.ok("jack");
```

2. 可以直接访问外部类的所有成员，包含私有的成员
3. 不能添加访问修饰符：因为它的地位就是一个局部变量。
4. 作用域：仅仅在定义它的方法或代码块中。
5. 匿名内部类：访问->外部类成员[访问方式:直接访问]
6. 外部其他类：不能访问->匿名内部类（因为匿名内部类地位是一个局部变量)
7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问
7. 匿名内部类**不可以定义构造器**

- 内部类的经典实现案例

1. 匿名内部类当作实参直接传递

```java
interface AA {
	public void cry();
}
main方法中:
public static void show(AA a) (
	a.cry();
}
show(new AA() {
    public void cry() {
    	System.out.println("AA cry");
	}
});
```

```java
// 当做实参直接传递，简洁高效
// 只使用一次这样写更简介
f1(new IL() {
    @Override
    public void show() {
    	System.out.println("这是一副名画...");
    });
// 传统方法
f1(new Picture()):
```

2. Comparator的实现

```java
// 注意泛型的选择，int不是引用数据类型
Integer[] arr = new Integer[]{1, 200, 23, 123, 20, 3, 1, 6, 100};
Arrays.sort(arr,
            new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o2 - o1;
                }
            });
```

##### 定义在外部类的成员位置上

###### 1)成员内部类(没用static修饰)

- 说明

```java
// 创建在外部类的成员位置
class 0uter08 {//外部美
    private int n1 = 10;
    public String name = "张三";
    cLass Inner08 {//成员内部类
    	public void say() {
        //可以直接访问外部类的所有成员，包含私有的
        System.out.println("n1 = + n1 + " name = " + name);
		}
	}
}
```

1. 可以直接访问外部类的所有成员，包含私有的

2. 可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。

3. 作用域--和外部类的其他成员一样，作用域为整个类体

4. 成员内部类--访问->外部类 (比如:属性) [访问方式:直接访问] (说明)

5. 外部类--访问->内部类--访问方式:创建对象，再访问

6. 外部其他类--访问->成员内部类(两种方式)

   - a.外部类的类名.内部类的类名 变量名 = 外部类的变量名.new 内部类的类名()

     ```java
     // 把new 内部类的类名()当作外部类的一个成员
     Outer08 outer08 = new Outer08();
     Outer08.Inner08 inner08 = outer08.new Inner08();
     ```

   - b.写一个返回类实例的方法

     ```java
     //方法，返回一个Inner08实例
     public Inner08 getInner08Instance(){
     	return new Inner08():
     }
     //第二种方法：在外部内中编写一个方法返回 内部类的对象
     Outer08.Inner08 inner08Instance = outer08.getInner08Instance()
     ```

7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问

###### 2)静态内部类(使用static修饰)

- 说明：静态内部类是定义在外部类的成员位置，并且有static修饰

1. 静态内部类是定义在外部类的成员位置，并且有static修饰

2. 可以添加任意访问修饰符(public、protected、默认、private)--因为它的地位就是一个成员。

3. 作用域:和其他成员一样为整个类体

4. 静态内部类--访问->外部类(比如:静态属性)[访问方式:直接访问所有静态成员]

5. 外部类--访问->静态内部类访问方式:创建对象，再访问

6. 外部其他类---访问----->静态内部类

   - a.可以通过类名直接访问(只要满足访问权限)

     ```java
     //因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)
     Outer10.Inner10 inner1o = new Outer10.Inner10();
     inner10.say();
     ```

   - b.写一个返回类实例的方法

     ```java
     public Inner getInner10() {
         return newInner10();
     }
     ```

7. 如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员)去访问

### 枚举(enumeration)和注解

#### 枚举

- 基本介绍

1.  传统的类的实现方式--不能完美解决只有固定类型的情况->枚举类-有效解决这种情况-把具体的对象一个个的列举出来
2. 枚举(enumeration,简写enum)
   - 枚举是一组常量的集合
   - 可以理解为：枚举是一种特殊的类--里面包含一组有限的特定对象

- 枚举的两种实现方式

1. 自定义类实现枚举
   - 私有化构造器
   - 取消set方法--防止修改信息
   - 在内部创建对象
   - 使用public final static共同修饰实现底层优化

```java
cLass Season {//类
private String name;
private String desc;//描述
//定义了四个对象，固定
public static final Season SPRING = new Season("春天", “温暖");
public static final Season WINTER = new Season("冬天", "寒冷");
public static final season AUTUMN = new Season("秋天", "凉爽");
public static ISeason SUMMER = new Season("夏天", "炎热");
//1.将构造器私有化，目的防止 直接 new
//2.去掉setXxx方法，防止属性被修改
//3.在Season 内部，直接创建固定的对象
//4.优化，可以加入 final 修饰符
```

```java
public class Enumeration02 {
    public static void main(string[] args) {
        System.out.println(Season.AUTUMN);
        System.out.println(Season.SPRING);
    }
}
```

2. enum关键字实现枚举
   - 使用enum关键字代替class
   - 将原本的创建对象的方法用--常量名(实参列表代替)
   - 存在多个常量(对象)使用，分隔
   - 使用enum实现枚举-常量对象需要放最前面

```java
enum Season2 {//类
//如果使用了enum 来实现枚举类
//1.使用关键字 enum 替代 class
//2.public static final Season SPRING = new Season("春天"，"温暖") 直接使用
//	SPRING("春天"，“温暖”) 解读 常量名(实参列表)
//3.如果有多个常量(对象)， 使用,号间隔即可
SPRING("春天", "温暖"),WINTER("冬天", “寒冷"),AUTUMN("秋天", "凉爽"), SUMMER("夏天", "炎热");
private String name;
private String desc;//描述
```

- 细节与注意

1. 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类--[如何证明]使用javap工具(反编译工具--.class->.java)--查看底层的一些细节

![enum_注意与细节](.\Java入门markdown图片\enum_注意与细节.png)

2. 传统的public static final Season2 SPRING = new Season2("春天","温暖“");
   简化成 SPRING(“春天","温暖")，
   这里必须知道，它调用的是哪个构造器.
3. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用,间隔，最后有一个分号结尾

```java
SPRING("春天", "温暖"), WINTER("冬天", "寒冷"), AUTUMN("秋天", "凉爽"), SUMMER("夏天", "炎热"), What;
```

5. 枚举对象必须放在枚举类的行首

- 常用方法

1. 说明:使用关键字enum时，会隐式继承Enum类,这样我们就可以使用Enum类相关的方法。

```java
public abstract class Enum<E extends Enum<E> >
	implements Comparable<E>, Serializable {
}
```

2. values()返回所有枚举对象的数组--顺序为创建时的声明顺序

```java
Season2[] values = Season2.values();
System.out.printLn("===遍历取出枚举对象(增强for)====")
for (Season2 season: values) {//增强for循环
	System.out.println(season);
}
```

3. valueOf("字符串")--将字符串转化为对应的枚举对象--不存在会报错

```java
//value0f: 将字符串转换成枚举对象，要求字符串必须VT为已有的常量名，否则报异常
Season2 autumn1 = Season2.value0f("AUTUMN");
System.out.printin("autumn1=" + autumn1);
```

![enum_常用方法](.\Java入门markdown图片\enum_常用方法.png)

- 小结

1. 使用enum关键字后，就不能再继承其它类了，因为enum会隐式继承Enum而Java是单继承机制。
2. 枚举类和普通类一样，可以实现接口，如下形式:
   enum 类名 implements 接口1，接口2 {}

#### 注解

- 基本介绍

1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。
2. 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当子嵌入在代码中的补充信息。
3. 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。
   - 在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。

- JDK内置的基本注解类型

1. 使用Annotation时要在其前面增加@符号,并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素，三个基本的Annotation

2. @Override

   - 限定子类某个方法是重写父类方法，该注解只能用于方法

     - 不写@Override注解也是重写
     - 写了@Override系统会去校验--是否重写
     - Override源码--@interface也是注解

     ```java
     @Target(ElementType.METHOD)
     @Retention(RetentionPolicy.SOURCE)
     public @interface Override {
     }
     ```

   - 使用说明

     - 1.@Override表示指定重写父类的方法（从编译层面验证)，如果父类没有fly方法，则会报错
     - 2.如果不写@Override注解,而父类仍有public void fly00，仍然构成重写'
     - 3.@Override只能修饰方法，不能修饰其它类，包，属性等等
     - 4.查看@Override注解源码为@Target(ElementType.METHOD),说明只能修饰方法
     - 5.@Target是修饰注解的注解，称为元注解

3. @Deprecated

   - 用于表示某个程序元素(类,方法等)已过时

     ```java
     public class Deprecated_ {
     	public static void main(String[] args)
             A a = new A();
             a.hi();
             System.out.println(a.n1);
     	}
     }
     //解读
     //1.@Deprecated 修饰某个元素，表示该元素已经过
     //2.即不在推荐使用，但是仍然可以使用
     @Deprecated
     class A {
     	@Deprecated
     }
     ```

   - 说明

     - 1.用于表示某个程序元素(类,方法等)已过时
     - 2.可以修饰方法,类,字段,包,参数等等
     - 3.@Target(value={CONSTRUCTOR,FIELD, LOCAL_VARIABLE, METHOD,PACKAGE,PARAMETER, TYPE))
     - 4.@Deprecated的作用可以做到新旧版本的兼容和过渡

4. @SuppressWarnings

   - 抑制编译器警告

   ```java
   //1.当我们不希望看到这些警告的时候，可以使用 SuppressWarnings注解来抑制警告信息
   //2.在{""} 中，可以写入你希望抑制(不显示)警告信息
   @SuppressWarnings({"all"})
   public static void main(String[] args) {
       List list = new ArrayList();
       List.add("jack");
       List.add("tom");
       List.add("mary")
       int i;
   }
   ```

   - 说明
     - (1)放置的位置就是 TYPE，FIELD，NETHOD，PARAMETER，CONSTRUCTOR，LOCAL_VARIABLE
     - (2)该注解类输入为数组 String[] values()设置一个数组比如{"rawtypes","unchecked","unused"}

- 元注解：对注解进行注解--了解
  - 基本介绍：JDK的源注解--用于修饰其他注解
- 元注解的种类

1. Retention//指定注解的作用范围/保留时间，三种SOURCE,CLASS,RUNTIME
   - RetentionPolicy.SOURCE:编译器使用后，直接丢弃这种策略的注解
   - RetentionPolicy.CLASS:编译器将把注解记录在class文件中.当运行Java程序时，JVM不会保留注解。这是默认值
   - RetentionPolicy.RUNTIME:编译器将把注解记录在 class文件中.当运行Java程序时,JVM会保留注解.程序可以通过反射获取该注解
2. Target/指定注解可以在哪些地方使用
3. Documented1/指定该注解是否会在javadoc体现
   - @Documented:用于指定被该元注解修饰的注解类将被javadoc工具提取成文档,即在生成文档时，可以看到该注解。
4. Inherited //子类会继承父类注解
   - 被@Inherited修饰的注解将具有继承性.如果某个类使用了被@Inherited修饰的注解,则其子类将自动具有该注解

### 异常(exception)

- 基本概念

1. 代码出现异常--程序中断(后序代码不再执行)->影响程序的健壮性---提供异常处理机制来解决该问题->try-catch--程序若出现异常-还是会继续执行后序的代码
2. Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)
3. 分类
   - 1)Error(错误): Java虚拟机无法解决的严重问题。如:JVM系统内部错误、资源耗尽等严重情况。比如:StackOverflowError[栈溢出]和OOM(out of memory)，Error是严重错误，程序会崩溃。
   - 2)Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等。
     - Exception分为两大类
       - 运行时异常[运行时发生的异常]
       - 编译时异常[编译时--编译器检查出的异常]

- 异常体系图

![异常体系图1](.\Java入门markdown图片\异常体系图1.png)

![异常体系图2](.\Java入门markdown图片\异常体系图2.png)

#### 常见的异常

- 常见运行时异常

1) NullPointerException空指针异常
当应用程序试图在需要对象的地方使用null时，抛出该异常
1) ArithmeticException数学运算异常
当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例
3) ArraylndexOutOfBoundsException数组下标越界异常
用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引
3) ClassCastException类型转换异常
当试图将对象强制转换为不是实例的子类时，抛出该异常。

```java
public class ClassCastException_ {
	public static void main(string[] args) {
        A b = new B(); //向上转型
        B b2 = (B)b;//向下转型，这里是0K
        C c2 = (C)b;//I
    }
}
class A {}
class B extends A {}
class C extends A {}
```

5. NumberFormatException数字格式不正确异常
   当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常=>使用异常我们可以确保输入是满足条件数字.

- 常见的编译异常

1. SQLException//操作数据库时，查询表可能发生异常
2. IOException//操作文件时，发生的异常
3. FileNotFoundException//当操作一个不存在的文件时，发生异常
4. ClassNotFoundException//加载类，而该类不存在时，异常
5. EOFException//操作文件，到文件未尾，发生异常
6. lllegalArguementException//参数异常

#### 异常处理

- 基本概念：异常处理就是当异常发生时，处理异常的方式。
- 异常处理方式分类：

1. try-catch-finally：程序员在代码中捕获发生的异常，自行处理
2. throws：将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是JVM

##### try-catch-finally

- 基本语法

```java	
try {
//可疑代码
//将异常生成对应的异常对象，传递给catch块
}catch(异常){//对异常的处理
}
//可以没有finally
```

- 处理机制

```java
try {
代码/可能有异常
} catch(Exception e){
//捕获到异常
//1.当异常发生时
//2.系统将异常封装成Exception对象e，传递给catch
//3.捕获异常后--程序员处理异常
//4.注意--异常没有发生catch代码块不执行
} finally{
//1.不管try代码块是否发生异常finally代码块一定执行
//2.通常把释放资源的操作放在finally代码块
}
```

- 注意与细节

1. 如果异常发生了，则**异常发生后面的代码不会执行**，直接进入到catch块.
2. 如果异常没有发生，则顺序执行try的代码块，不会进入到catch.
3. 如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally {}
4. **可以有多个catch语句,捕获不同的异常(进行不同的业务处理)--要求父类异常在后,子类异常在前(如果父类在前-后面的子类就没有意义)**--比如(Exception在后,NullPointerException在前)，如果发生异常,只会匹配一个catch

```java
try {
    
	} catch(NullPointerExcetpion e) {
    
    } catch(Exception e) {
        
    } finally{
        
    }
```

5. 可以进行try-finally 配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉。应用场景--执行一段代码-不管是否发生异常-都必须执行某个业务逻辑。

```java
try {
   //代码... 
}
finally{ //总是执行
}
```

6. try的形式有三种： try-catch try-finally try-catch-finally 但catch和finally语句不能同时省略

- 小结

1. 如果没有出现异常，则执行try代码块中所有语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句
2. 如果出现异常，则try块中异常发生后，剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句!

- 最佳实践：如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止

```java
//思路
//1.创建Scanner对象
//2.使用无限循环，去接收一个输入
//3.然后将该输入的值，转成一个int
//4.如果在转换时，抛出异常，说明输入的内容不是一个可以转成int的内容
//5.如果没有抛出异常，则break该循环
Scanner scanner = new Scanner(System.in);
int num = 0;
String inputStr = "":
while (true) {
    System.out.println("请输入一个整数:"); //
    inputStr = scanner.next();
    try {
    	num = Integer.parseInt(inputStr); //这里是可能抛出异常
    	break;
    } catch (NumberFormatException e) {
    	System.out.println("你输入的不是一个整数:");
    }
}
```

##### throws

- 基本介绍

1. 如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理,而由该方法的调用者负责处理。
2. 在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。

- 基本语法

```java
public void f2() throws Exception {
//创建了一个文件流对象
//解读:
//1.这里的异常是一个FileotFoundException 编译异常
//2.使用前面讲过的 try-catch-finally
//3.使用throws ,抛出异常，让调用f2方法的调用者(方法)处理
//4.throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类
//5.throws 关键字后也可以是 异常列表，即可以抛出多个异常
	FileInputStream fis = new FileInputStream("d://aa.txt");
}
```

```java
public void f2() throws FileNotFoundException, NullPointerException, ArithmeticException {
    
}
// 可以接受多个异常
```

- 处理机制

1. 两种异常处理方式选择一种即可
2. 若程序员没有显示的处理异常--默认使用throws

![Throw处理机制](.\Java入门markdown图片\Throw处理机制.png)

- 注意与细节

1. 对于**编译异常，程序中必须处理，比如try-catch或者throws

```java
public static void f1() throws FileNotFoundException {
    //这里大家思考问题 调用f3() 报错
    //解读
    //1.因为f3() 方法抛出的是一个编译异常
    //2.即这时，就要f1() 必须处理这个编译异常
    //3.在f1() 中，要么 try-catch-finally ,或者继续throws 这个编译异常
    f3(); // 抛出异常
public static void f3() throws FileNotFoundException {
	FileInputstream fis = new FileInputStream("d://aa,txt");
}
    // f3()会抛出(编译)异常--f1()就必须处理/抛出异常
```

2. 对于**运行时异常，程序中如果没有处理，**默认就是throws的方式处理[举例]

```java
public static void f4() {
    //老韩解读:
    //1。在f4()中调用方法f5() 是0K
    //2。 原因是f5() 抛出的是运行异常
    //3。而java中，并不要求程序员显示处理，因为有默认处理机制
    f5();
}
public static void f5() throws ArithmeticException {
}
// f4()中没有接受/抛出异常--但是不会报错--运行异常有默认的处理机制
```

3. 子类重写父类的方法时，对抛出异常的规定:
   子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型**
4. 在throws过程中，如果有方法 try-catch，就相当于处理异常，就可以不必throws

#### 自定义异常

- 基本概念：当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这时可以自己设计异常类，用于描述该错误信息。
- 案例

```java
class AgeException extends RuntimeException {
    public AgeException(string message) {//构造器
    super(message);
    }
}
// 通常情况自定义异常都继承RuntimeException--可以利用异常默认处理机制
```

```java
public static void main(String[] args) {
    int age = 180;
    //要求范围在 18 - 120 之间，否则抛出一个自定义异常
    if(!(age >= 18 && age <= 120)) {
    //这里我们可以通过构造器，设置信息
    	throw new AgeException("年龄需要在 18~120之间");
    }
    System.out.println("你的年龄范围正确。");
}
```

#### throw和throws的对比

![throw和throws的对比](.\Java入门markdown图片\throw和throws的对比.png)

## 常用类

### 包装类：Wrapper

- 基本介绍

1. 八种基本数据类型相应的引用类型—包装类
2. 包装类具有类的特点，可以调用类中的方法。

- 分类

![包装类_分类](.\Java入门markdown图片\包装类_分类.png)

- 包装类和基本数据类型的转换

1. 装箱 : 基本数据 -> 包装类型
2. 拆箱 : 包装类 -> 基本类型
3. jdk5前的手动装箱和拆箱方式

```java
// 基本类型 -- 包装类型[手动装箱]
int i = 10;
Integer i1 = new Integer(i);
Integer i2 = Integer.valueOf(i);
// 包装类型 -- 甚本类型[手动拆箱]
Integer j = new Integer(99);
int jl = j.intValue();
```

4. jdk5以后(含jdk5)的自动装箱和拆箱方式

```java
//jdk5后，就可以自动装箱和自动拆箱
int n2 = 200;
//自动装箱 int->Integer
Integer integer2 = n2; //底层使用的是 Integer.value0f(n2)
//自动拆箱 Integer->int
int n3 = integer2; //底层仍然使用的是 intValue()方法
```

5. 自动装箱底层调用的是valueOf方法，比如Integer.valueOf()

- 包装类与String相互转换

1. 包装类->String

```java
//包装类(Integer)->String
Integer i = 100;//自动装箱
//方式1
String str1 = i + "":
//方式2
String str2 = i.toString();
//方式3
String str3 = String.value0f(i):
```

2. String->包装类

```java
//string -> 包装类(Integer)
String str4 = "12345";
Integer i2 = Integer.parseInt(str4); //使用到自动装箱
Integer i3 = new Integer(str4); //构造器
```

- 包装类常方法

1. Integer

```java
System.out.println(Integer.MIN_VALUE);//返回最小值
System.out.println(Integer.MAX_VALUE)://返回最大值
```

2. Character

```java
System.out.println(Character.isDigit('a'));//判断是不是数字
System.out.println(Character.isLetter('a'));//判断是不是字母
System.out.println(Character.isUpperCase('a'));//判断是不是大写
System.out.println(Character.isLowerCase('a'));//判断是不是小写
System.out.println(Character.isWhitespace('a'));//判断是不是空格
System.out.println(Character.toUpperCase('a'));//转成大写
System.out.println(Character.toLowerCase('A'));//转成小写
```

### String

- 基本说明

1. String 对象用于保存字符串
2. 字符串常量**对象是用双引号括起的字符序列。例如:“你好"、"12.97"."boy"等
3. 字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节
4. String类较常用构造方法(看手册):

```java
String s1 = new String();
String s2 = new String(String original);
String s3 = new String(char[] a);
String s4 = new String(char[] a, int startlndex, int count);
```

5. String类实现的接口
   - Serializable--可串行化-网络传输
   - Comparable--对象可以比较大小
6. String是final类--不能被继承
7. ***private final char value[]；该属性用于存放字符串内容--不可以修改(value指的地址不可以修改)----字符串对象(地址与对应的内容)**一旦被分配，其内容是不可变的

```java
String name = "jack";
name = "tom";
final char[] value = {'a' ,'b','c'};
char[] v2 = {'t', 'o', 'm'};
value[0] = 'H';
//value = v2; 不可以修改 value地址
```

- 创建方式

1. 方式一:直接赋值String s = "hspedu";
   - 方式一:先从常量池查看是否有"hspedu”数据空间，如果有，直接指向;如果没有则重新创建，然后指向。
   - s最终指向的是常量池的空间地址
2. 方式二:调用构造器String s = new String("hspedu");
   - 方式二:先在堆中创建空间，里面维护了value属性，指向常量池的hspedu空间。如果常量池没有"hspedu"，重新创建，如果有，直接通过value指向。
   - 最终指向的是堆中的空间地址。
3. 图示说明

![String创建方法](.\Java入门markdown图片\String创建方法.png)

- 字符串特性

1. String是一个final类，代表不可变的字符序列
2. 字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的.

```java
// 1.以下语句创建了几个对象? 画出内存布局图
String s1 = "hello";
s1 = "haha";
//创建了2个对象.
```

3. 编译器会自动优化--判断创建的常量池对象，是否有引用指向

```java
String a = "hello" + "abc";
// 创建了几个对象? 只有1个对象。
// 解读: String a =“hello"+"abc"; //==>优化等价 String a =“helloabc";
// 字符串常量(相加)直接--指向常量池
```

```java
String a = "hello"; //创建 a对象
String b = "abc";//创建 b对象
//老韩解读
//1.先创建一个 StringBuilder sb = StringBuilder()
//2.执行 sb.append("hello");
//3. sb.append("abc");
//4.string c= sb.tostring()
//最后其实是 c 指向堆中的对象(string) value[] -> 池中"helloabc"
String c = a + b;
```

```java
/*
小结: 底层是 StringBuilder sb = new StringBuilder; sb.append(a);sb.append(b); sb是在堆中，并且append是在原来字符串的基础上追加的.重要规则，String c1 ="ab"+"cd"; 常量相加，看的是池。 String c1 = a + b;变量相加,是在堆中.
*/
```



![String相加](.\Java入门markdown图片\String相加.png)

- 说明

1. String类保存字符串常量。每次更新都需要重新开辟空间，效率较低,因此java设计者还提供了StringBuilder和 StringBuffer 来增强String的功能，并提高效率。
2. 每次都重新创建对象再更新

```java
//看看这段代码
String s = new String("");
for (int i = 0; i < 80000; i++) {
	s += "hello";
}
```

- 常用方法

1. 实例1

   - charAt(idx):字符串不能像数组一样直接访问--str[0]--因为数组的内容是存在value[]中的

   - equals()--判断内容是否相等--区分大小写
   - equalsIgnoreCase()--判断内容是否相等--忽略大小写
   - length()--字符串长度
   - indexOf()--返回字符(串)在字符串中的第一次出现的索引(开始的idx)--不存在返回-1
   - substring()--截取x开始的子串(包括)--截取(x,y)的子串(不包括y)

2. 实例2

   - toUpperCase--转大写

   - toLowerCase

   - concat--字符拼接

     ```java
     // 3.concat拼接字符串
     String s1 ="宝玉";
     s1 = s1.concat("林黛玉").concat("薛宝钗").concat("together");
     System.out.println(s1);//宝玉林黛玉薛宝钗together
     ```

   - replace(xx,yy)--替换字符串中的字符

     ```java
     s1 ="宝玉 and 林黛玉 林黛玉 林黛玉";
     //在s1中，将 所有的 林黛玉 替换成薛宝钗
     // 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的
     // 注意对 s1没有任何影响
     String s11 = s1.replace("宝玉", "jack");
     System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉
     System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉
     ```

   - split--分割字符串--对于某些分割字符,我们需要转义比如\\等

     ```java
     string poem =“锄禾日当,汗滴禾下士,谁知盘中餐,粒粒皆辛苦";
     //解读: 以','为标准对 poem 进行分割
     String[] split = poem.split(",");
     poem ="E:\\aaa\\bbb";
     split = poem.split("\\\\");
     ```

   - toCharArray()--转换成字符数组

     ```java
     s = "happy";
     char[] chs = s.toCharArray();
     ```

   - compareTo--比较两个字符串的大小--看具体源码

     ```java
     (1) 如果长度相同，并且每个字符也相同，就返回 0
     (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小
     	就返回 if (c1 != c2) {
     		return c1 - c2;
         }
     (3) 如果前面的部分都相同，就返回 str1.Len - str2.Len
     ```

   - format--格式字符串--占位符%s字符串 %c字符 %d整型 %.2f浮点型2位

     ```java
     String formatStr ="我的姓名是%s 年龄是%d，成绩是%,2f 性别是%c，希望大家喜欢我!";
     String info2 = String.format(formatStr, name, age, score, gender);
     ```


### StringBuffer

- 基本介绍

1. java.lang.StringBuffer--代表可变的字符序列，可以对字符串内容进行增删。
   - StringBuffer的直接父类是 AbstractStringBuilder
   - StringBuffer实现了Serializable，即StringBuffer的对象可以串行化
   - 在父类中 AbstractStringBuilder有属性char[] value--不是final--value数组存放字符串内容，因此内存空间位于堆中
   - StringBuffer是一个final类，不能被继承
2. 很多方法与String相同，但StringBuffer是可变长度类型
3. StringBuffer是一个容器

- String和StringBuffer的对比

1. String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低//private final char value;
2. StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上更新的内容，不用每次更新地址(容量不够时扩容更新地址)，效率较高//char[] value;//存放在堆.

- 构造器

1. StringBuffer()

```java
StringBuffer()：构造一个其中不带字符的字符串缓冲区，其初始为16个字符
```

2. StringBuffer(CharSequence seq)

```java
StringBuffer(CharSequence seq)
public java.lang.StringBuilder(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符。
```

3. StringBuffer(int capacity)

```java
构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对 char[] 大小进行指定
```

4. StringBuffer(Stering str)：创建大小为str.length+16；构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。

- String<->ShtringBuffer互相转换

1. String->ShtringBuffer

```java
String str = "hello tom";
//方式1 使用构造器
//注意: 返回的才是stringBuffer对象，对str 本身没有影响
StringBuffer stringBuffer = new StringBuffer(stm);
//方式2 使用的是append方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);
```

2. String<-ShtringBuffer

```java
//方式1 使用StringBuffer提供的 tostring方法
String s = stringBuffer3.toString();
//方式2: 使用构造器来搞定
String s1 = new String(stringBuffer3);
```

- StringBuffer的常用方法

1. 增：append()

```java
//增
s.append(','); // "hello,"
s.append("张三丰"); // "hello,张三丰"
s,append("赵缴").append(100).append(true).append(10.5);//"hello,张三,赵缴100true10.5"
```

2. 删除：delete(start,end)

```java
// 删除索引为>=start && <end 处的字符
// 解读: 删除 11~14的字符 [11，14)
s.delete(11, 14);
```

3. 改：replace(start,end,string) //将start----end间的内容替换为string,不含end

```java
s.replace(9, 11, "周芷若");
```

4. 查：indexOf //查找子串在字符串第1次出现的索引,如果找不到返回-1

```java
int index0f = s.index0f("张三丰");
```

5. 插：insert

```java
//解读: 在索引为9的位置插入 “赵敏”,原来索引为9的内容自动后移
s.insert(9, "赵饭");
```

6. 获取长度length

### StringBuilder

- 基本介绍

1. 一个可变的字符序列。此类提供一个与 StringBuffer兼容的APl，但不保证同步(StringBuilder不是线程安全)。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候。---单线程优先使用
   - 1.StringBuilder继承 AbstractStringBuilder类
   - 2.实现了Serializable,说明StringBuilder对象是可以串行化(对象可以网络传输,可以保存到文件)
   - 3.StringBuilder是final类，不能被继承
   - 4.StringBuilder对象字符序列仍然是存放在其父类 AbstractStringBuilder的 char[] value;因此，字符序列内存位于堆
   - 5.StringBuilder的方法，没有做互斥的处理,即没有synchronized 关键字,因此在单线程的情况下使用stringBuilder
2. 在StringBuilder上的主要操作是append和insert方法，可重载这些方法,以接受任意类型的数据。

- 常用方法：与StringBuffer一样
- String-StringBuffer-StringBuilder--对比

1. StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样
2. String:不可变字符序列,效率低,但是复用率高。
3. StringBuffer:可变字符序列、效率较高(增删)、线程安全 -- synchronized
4. StringBuilder:可变字符序列、效率最高、线程不安全
5. String使用注意说明:
  - 如果多次执行这些改变串内容的操作，会导致大量本字符串对象存留在内存中，降低效率；
    如果这样的操作放到循环中，会极大影响程序的性能=>结论:如果我们对String 做大量修改,不要使用String**。
  - 效率: StringBuilder > StringBuffer > String

```java
string s="a";
//创建了一个字符串s += "b";
//实际上原来的"a"字符串对象已经丢弃了，现在又产生了一个字符串s+"b”(也就是"ab")。
```

6. 使用原则
   - 1．如果字符串存在大量的修改操作，一般使用StringBuffer 或StringBuilder
   - 2．如果字符串存在大量的修改操作，并在单线程的情况,使用 StringBuilder
   - 3．如果字符串存在大量的修改操作，并在多线程的情况,使用StringBuffer
   - 4．如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等

### Math

- 基本介绍：Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。
- 常用方法

1. abs()--绝对值
2. pow(a,b)--求幂

3) ceil向上取整
4) floor向下取整
5) round四舍五入
6) sqrt求开方
7) random()：生成[0,1)之间的随机数随机数
8) max求两个数的最大值
9) min求两个数的最小值

### Arrays

- 基本介绍：Arrays里面包含了一系列静态方法，用于管理或操作数组(比如排序和搜索).
- 常用方法

1. toString--返回数组的字符串形式：Arrays.toString(arr)
2. sort排序(自然排序和定制排序)--数组是引用类型-排序会改变实参
   - 定制排序--重载比较器-排序--->comparator的返回值必须是一个整型
   - 接口编程+匿名内部类+动态绑定

```java
Integer arr[] = {1,-1,7,0,89};
//1.可以直接使用冒泡排序 ， 也可以直接使用Arrays提供的sort方法排序
//2.因为数组是引用类型，所以通过sort排序后，会直接影响到 实参 arr
//3.sort重载的，也可以通过传入一个接口 Comparator 实现定制排序
//4.调用 定制排序 时，传入两个参数 
// (1) 排序的数组 arr
// (2) 实现了Comparator接口的匿名内部类,要求实现compare方法
// 定制排序
Arrays.sort(arr, new Comparator() {
    @Override
    public int compare(object o1, 0bject o2) {
    Integer i1 = (Integer) o1;
    Integer i2 = (Integer) o2;
	return i2 - i1;
    }
});
```

3.  binarySearch 通过二分搜索法进行查找，要求必须排好序**

```java
//1.使用 binarySearch 二叉查找
//2.要求该数组是有序的。 如果该数组是无序的，不能使用binarySearch
//3.如果数组中不存在该元素，就返回 return -(Low + 1); // key not found.
int index = Arrays.binarySearch(arr, 3);
```

4. copyOf：拷贝前n个元素

```java
//1.从 arr 数组中，拷贝 arr.length 个元素到 newArr 数组中
//2.如果拷贝的长度 > arr.Length 就在新数组的后面 增加 null
//3.如果拷贝长度 < 0 就抛出异常NegativeArraySizeException
Integer[] newArr = Arrays.copy0f(arr, -1);
System.out.println("==拷贝执行完毕后==");
System.out.println(Arrays.toString(newArr));
```

5. fill(arr, x)--数组元素都填充为x

```java
Integer[] num = new Integer[]{9,3,2};
Arrays.fill(num,99);
```

6) equals比较两个数组元素内容是否完全一致

```java
boolean equals = Arrays.equals(arr, arr2);
```

7. asList将一组值，转换成list

```java
List<lnteger> asList = Arrays.asList(2,3,4,5,6,1);
System.out.println("asList=" + asList);
```

### System

- 常用方法

1. exit 退出当前程序

```java
System.out.println("ok1");
//老韩解读
//1.exit(0) 表示程序退出
//2.0 表示一个状态,正常的状态
System.exit(0);//
System.out.println("ok2"):
```

2. arraycopy:复制数组元素，比较适合底层调用,一般使用Arrays.copyOf完成复制数组.

```java
int[] src = {1,2,3};
int[] dest = new int[3];
System.arraycopy(src, 0, dest, 0,3);
/*
源数组
* @param src the source array .
srcPos: 从源数组的哪个索引位置开始拷贝
* @param srcPos starting position in the source array.
dest : 目标数组，即把源数组的数据拷贝到哪个数组
* @param dest the destination array.
destPos: 把源数组的数据拷贝到 目标数组的哪个索引
* @param destPos starting position in the destination data.
Length: 从源数组拷贝多少个数据到目标数组
@param Lengththe number of array elements to be copied.
*/
```

3) currentTimeMillis:返回当前时间距离1970-1-1的毫秒数
4) gc:运行垃圾回收机制System.gc();

### BigInteger/BigDecimal

- BigInteger

1. 当我们编程中，需要处理很大的整数，Long 不够用。可以使用BigInteger的类来搞定。

```java
long l = 23788888899999999999999999999L;
System.out.printIn("l=" + l);
BigInteger bigInteger = new BigInteger("23788888899999999999999999999");
```

2. 需要使用BigInteger提供的相应的方法实现加减乘除

![BigInteger](.\Java入门markdown图片\BigInteger.png)

### BigDecimal

- 不设置保留的小数位数--相除可能无限(不)循环--会抛出异常可以设置保留小数的位数

```java
BigDecimal bigDecimal = new BigDecimal("1999.11111111111999999999999977788");
BigDecimal bigDecimal2 = new BigDecimal("3");
System.out.println(bigDecimal);
//解读
//1.如果对 BigDecimal进行运算，比如加减乘除，需要使用对应的方法
//2.创建一个需要操作的 BigDecimal 然后调用相应的方法即可
System.out.println(bigDecimal.add(bigDecimal2));
System.out.println(bigDecimal.subtract(bigDecimal2));
System.out.println(bigDecimal.multiply(bigDecimal2));
//System.out.printin(bigDecimal.divide(bigDecimal2));//可能抛出异常ArithmeticExceptiol
//在调用divide 方法时，指定精度即可。BigDecimal.ROUND_CEILING
//如果有无限循环小数，就会保留 分子 的精度
System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));
```

### 日期类

- 日期类：Date/Calender/LocalDate

- 第一代日期类：date

![date](.\Java入门markdown图片\date.png)

1. 获取系统时间

```java
//1.获取当前系统时间
//2.这里的Date 类是在java.util包
//3.默认输出的日期格式是国外的方式，因此通常需要对格式进行转换
Date d1 = new Date(); //获取当前系统时间
System.out.println("当前日期=" + d1);
```

2. 格式化输出

```java
//1.创建 simpleDateFormat对象，可以指定相应的格式
//2.这里的格式使用的字母是规定好，不能乱写
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 Ch:mm:ss E");
String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
```

```java
//1.可以把一个格式化的string 转成对应的 Date
//2.得到Date 仍然在输出时，还是按照因外的形式，如果希望指定格式输出，需要转换
//3.在把String -> Date ， 使用的 sdf 格式需要和你给的Strng的格式一样，否则会抛出转换异常
string s =“1996年01月01日 10:20:30 星期一";
Date parse = sdf.parse(s);
System.out.println("parse=" + sdf.format(parse));
```

3. 毫秒数转化为时间

```java
Date d2 = new Date(9234567); //通过指定毫秒数得到时间
System.out.println("d2=" + d2); //获取某个时间对应的毫秒数
```

- 第二代日期类：Calender

```java
//1.CaLendar是一个抽象类，并且构造器是private
//2.可以通过 getInstance() 来获取实例
//3.提供大量的方法和字段提供给程序员
//CaLendar
```

1. 获取日历对象

```java
System.out.printin(c);
Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由
```

2. 获取日期字段

```java
//2.获取日历对象的某个日历字段
System.out.println("年:" + c.get(Calendar.YEAR));
// 这里为什么要 + 1，因为Calendar 返回月时候，是按照 0 开始编号
System.out.println("月:" + (c.get(Calendar.MONTH) + 1));
System.out.println("日:" + c.get(Calendar.DAY_OF_MONTH));
System.out.println("小时:" + c.get(Calendar.HOUR));
System.out.println("分钟:" + c.get(Calendar.MINUTE));
System.out.println("秒:" + c.get(Calendar.SECOND));
```

3. Calender没有格式化输出方法

```java
//CaLender 没有专门的格式化方法，所以需要程序员自己来组合显示

System.out.println(c.get(Calendar,YEAR) + "-" + (c.get(Calendar.MONTH) + 1) + "-" + c.get(Calendar.DAY) +
" " + c.get(Calendar.HOUR) +":" + c.get(Calendar.MINUTE) +":"+ c.get(Calendar.SECOND));
```

- 第三代日期：LocalXXXX

1. 前两代日期的缺点

   - 可变性: 像日期和时间这样的类应该是不可变的。
   - 偏移性: Date中的年份是从1900开始的，而月份都从0开始。
   - 格式化: 格式化只对Date有用，Calendar则不行。
   - 此外，它们也不是线程安全的; 不能处理秒等 (每隔2天，多出1s)。

2. LocalDate：日期-年月日

3. LocalTime：时间-时分秒

4. LocalDateTime：日期时间-年月日时分秒

   - 获取时间对象

     ```java
     //1.使用now() 返回表示当前日期时间的 对象
     LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()
     System.out.println(ldt);
     // 时间信息的get方法
     ldt.getYear();
     ldt.getMonthValue();
     ldt.getMonth();
     ldt.getDayOfMonth();
     ldt.getHour();
     ldt.getMinute();
     ldt.getSecond();
     ```

   - 格式化输出：DateTimeFormatter

     ```java
     //2.使用DateTimeFormatter 对象来进行格式化
     // 创建 DateTimeFormatter对象
     DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH小时mm分钟ss秒")
         // 格式符号和Date一致
     ```

     ```java
     DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH小时mm分钟ss");
     String format = dateTimeFormatter.format(ldt);
     System.out.println("格式化的日则=" + format);
     ```

   - Instant时间戳：可以和Date类相互转换

     ```java
     //1.通过 静态方法 now() 获取表示当前时间藏的对象
     Instant now = Instant.now();
     System.out.println(now);
     //2.通过 from 可以把 Instant转成 Date
     Date date = Date.from(now);
     //3.通过 date的toInstant() 可以把 date 转成Instant对象
     Instant instant = date.toInstant();
     ```

5. 相关方法

   - LocalDateTime类
   - MonthDay类:检查重复事件
   - 是否是年
   - 增加日期的某个部分
   - 使用plus方法测试增加时间的某个部分
   - 使用minus方法测试查看一年前和一年后的日期

   

## 集合

### 集合的引出

- 为什么要使用集合

1. 数组的不足--必须指定长度且不能更改--元素类型一致--增加元素比较麻烦
2. 集合的好处--动态保存多个对象--提供操作方法-增删改查

### 集合体系的框架

- 背下来***

![集合框架图1](.\Java入门markdown图片\集合框架图1.png)

![集合框架图2](.\Java入门markdown图片\集合框架图2.png)



### Collection

- List和Set的子类都是单列集合

#### List

- 基本介绍

1) List集合类中元素有序(即添加顺序和取出顺序一致)且可重复
2) List集合中的每个元素都有其对应的顺序索引，即支持索引。--- list.get(idx)
3) List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。---index

- List接口的常用方法

1. add()--插入  add(Object obj)--添加  add(idx，obj )--插入
2. indexOf(obj)--返回obj首次出现的idx
3. lastIndexOf(obj)--返回obj最后一次出现的idx
4. remove()删除--remove(idx)--删除idx位置的元素
5. set()--set(idx, obj)--将idx位置的元素替换为obj
6. subList()--subList(idx1, idx2)--返回idx1到idx2的子集合
6. get()--有助于从列表中随机访问元素

- List的三种遍历方式

1. iterator

```java
//1.迭代器
Iterator iterator = list.iterator(O);
	while (iterator.hasNext()) {
		0bject obj = iterator.next();
        system.out.println(obj);
}
```

2. 增强for循环

```java
//2.增强for循环
for(object o : list) {
	system.out.println(""o=" +o);
}
```

3. 普通for循环

```java
//3.普通for循环--list.get(idx)方法
for (int i = 0; i < list.size(); i++) {
	system.out.println("对象=" +list.get(i));
}
```

##### **ArrayList**--数组

- ArrayList的注意事项

1. 可以接受任何类型的元素, 包括null(任何数量的null)

2. ArrayList使用数组实现数据存储--查看源码

3. ArrayList基本等同于Vector,除了ArrayList是线程不安全(执行效率高)--看源码--

   在多线程情况下，不建议使用ArrayList---没有synchronized修饰

- **ArrayList的底层结构和源码分析**(重难点)

1. ArrayList中维护了一个Object类型的数组elementData. [debug 看源码]

   ```java
   transient Object[] elementData;//transient表示不会被序列化
   ```

2. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍。

3. 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容,
   则直接扩容elementData为1.5倍。(没有元素的位置均为null)
   ----IDEA会省略null的debug显示--可以在Build,Execution,Deployment-Dubugger-DataViewx-Java-Enable alternative view for Collections classes和Hide null elements in arrays and collections(取消✔该项)(debug显示null元素)

##### **Vector**

- Vector的基本介绍

1. 类的定义说明

```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

2. Vector底层也是一个对象数组

```java
protected Object[] elementData;
```

3. Vector是线程同步的，即线程安全, Vector类的操作方法带有synchronized

```java
public synchronized E get(int index) {
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        return elementData(index);
    }
```

4. 在开发中，需要线程同步安全时，考虑使用Vector

- Vector和ArrayList的比较

![Vector和ArrayList的比较](.\Java入门markdown图片\Vector和ArrayList的比较.png)

- Vector的底层结构和源码分析**(重难点)

1. 默认无参构造器--数据大小为10->每次扩容两倍(默认)

##### LinkedList--链表

- 基本说明

1. LinkedList底层实现了**双向链表**和**双端队列**特点
2. 可以添加任意元素(元素可以重复)，包括null
3. 线程不安全，没有实现同步

- LinkedList底层结构

1. LinkedList底层维护了一个双向链表
2. LinkedList中维护了两个属性--first属性->指向链表的头部----last属性->指向链表的尾部
3. 每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过
   prev指向前一个，通过next指向后一个节点。最终实现双向链表.
4. 所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高(只需要修改prev和next的指向)。

- LinkedList增删改查(CRUD--增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete))

1. 添加(增加)元素

```java
//1.创建一个双向链表
LinkedList linkedList = new LinkedList();
public LinkedList(){
}
//2.此时的first和last都为空
//3.执行添加
linkedList.add(Integer num);
```

2.删除元素

```java
//被删除节点的next->null 下一节点的prev->null 调整first和last
linkedList.remove();//默认删除第一的节点
linkedList.remove(idx);//删除指定节点
linkedList.removeFisrt();//删除第一节点
//其他删除方法查看文档
```

3.修改元素

```java
linkedList.set(idx, obj);
```

4.查找(获取)元素

```java
linkedList.get(idx);
```

- ArrayList和LinkedList比较

![ArrayList和LinkedList比较](.\Java入门markdown图片\ArrayList和LinkedList比较.png)

如何选择ArrayList和LinkedList:

1. 改查的操作多，选择ArrayList
2. 增删的操作多，选择LinkedList
3. 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList
4. 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList,另外一个模块是LinkedList.

- LinkedList元素遍历-三种方法

```java
//1.iterator
Iterator iterator = linkedList.iterator();
while (iterator.hasNext()) {
	0bject next = iterator.next();
    system.out.println("next=" + next);
}
```

```java
//2.增强for循环
for (Object o1 : linkedList) {
	system.out.println("o1=" + o1);
}
```

```java
//3.普通for循环
for (int i =0; i< linkedList.size(); i++) {
	System.out.println(linkedList.get(i);
}
```



#### Set

- 基本介绍

1. 无序（添加和取出的顺序不一致)，没有索引
2. 不允许重复元素，所以最多包含一个null
3. JDK API中Set接口的实现类有:AbstractSet，ConcurrentSkipListSet，Copy0rWriteArraySet，EnumSet, HashSet，JobStateReasons，LinkedHashSet，TreeSet

- Set接口的常用方法

```java
//使用HashSet展示Set的接口方法
//1.实现Set接口的类的对象(Set接口对象)，不能存放重复的元素，可以添加一个null
//2.Set接口对象存放数据是无序(存放的顺序和添加的顺序无关)
//3.去除的顺序是固定的(查看底层代码)
Set set = new Hashset();
set.add( "john"');//add方法会返回boolean类型--添加是否成功
set.add("lucy");
set.add( "john ");//重复--添加失败返回boolean值false
set.add("jack");
set.add(null);//
set.add(null);//再次添加null
set.remove(null)
```

- Set接口的遍历方式

1. 迭代器

```java
Iterator iterator = set.iterator();
while (iterator.hasNext()){
	object obj= iterator.next();
    System.out.println( "obj=" + obj);
}
```

2. 增强for循环

```java
Iterator iterator = set.iterator();
for (Object obj: iterator)
    System.out.println( "obj=" + obj);
}
```

3. **不能使用**索引遍历

##### **HashSet**

- HashSet的基本说明

1. HashSet的底层是HashMap(数组+链表+红黑树)，HashSet实现了Set接口
2. 可以存放null值，但是只能有一个null(不能有重复元素)
3. HashSet不保证元素是有序的,取决于hash后，再确定索引的结果.
4. 不能有重复元素/对象(Set接口的特点)

```java
//怎么理解不能有重复元素/对象
HashSet set = new HashSet();
set.add("lucy");
set.add("lucy"");
set.add(new Dog("tom"));
set.add(new Dog("tom"));//地址不同-可以添加-里面存在同名的String属性
System.out.println("set=" +set);
//经典面试题--看源码才能判断(底层机制决定)
set.add(new String("hsp"));
set.add(new String("hsp"));//加入不了--
```

- 元素的添加机制

1. 先获取元素的哈希值(hashCode方法)
2. 对哈希值进行运算,得出一个索引值即为要存放在哈希表中的位置
3. 如果该位置上没有其他元素，则道接存放
   如果该位置上已经有其他元素，则需要进行equals判断
   如果相等，则不再添加。如果不相等则以链表的方式添加

- 底层代码

1. HashSet底层是 HashMap
2. 添加一个元素时，先得到**hashCode()值**--转成->索引值
3. 找到存储数据表table，看这个索引位置是否已经存放的有元素
   如果没有，直接加入；如果有，调用**equals()**比较，如果相同，就放弃添加,如果不相同，则添加到最后
4. 在Java8中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD(默认是8)，并且table的大小>=
   MIN_TREEIFY_CAPACITY(默认64),就会进行树化(红黑树)
5. HashSet的putVal部分源码--仔细学习阅读

```java
//查看源码
/*
1.构造器创建HashMap
2.add()方法
public boolean add(E e) {
 	return map.put(e, PRESENT)==null;//PRESENT一个Object对象
}
put方法--与hashcode()有关
public V put(K key, V value) {
	return putVal(hash(key), key, value, false, true);
}
putVal方法
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    HashMap.Node<K,V>[] tab; HashMap.Node<K,V> p; int n, i;
    //table就是 HashMap的一个数组，类型是 Node[]
    //if 语句表示如果当前table是null,或者大小=0--就第一次扩容到16个空间。
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;//resize()方法--扩容方法
    //根据key，得到hash去计算该key应该存放到table表的哪个索引位置
    //并把这个位置的对象，赋给p
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
    	//如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样
    	//并且满足下面两个条件之一:
		//(1）准备加入的key和p指向的Node结点的 key 是同一个对象
		//(2) p指向的Node结点的key的equals()和准备加入的key比较后相同--equals()方法可以修改
        HashMap.Node<K,V> e; K k;
        if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        //如果是红黑树--按照红黑树的方法添加
        else if (p instanceof HashMap.TreeNode)
            e = ((HashMap.TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
		//如果table对应索引位置，已经是一个链表，就使用for循环比较
		//(1）依次和该链表的每一个元素比较后，都不相同，则加入到该链表的最后
			添加元素后判断是否达到8个节点->Yes则进行树化treeifyBin()
			若if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)条件成立--先扩容暂时不树化--条件不成立--树化
		//(2）依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {//整个链表没有equals()相同的元素-则加到最后
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);//treeifyBin内部还会判断--大小是否超过64-没有则不树化
                    break;
                }
                //满足以下条件就不添加
                if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold) //超过临界值就扩容
        resize();
    afterNodeInsertion(evict);//HashMap没有实现该方法
    return null;
}
 */
HashSet set = new HashSet();
set.add(new String("hsp"));
set.add(new String("hsp"));//加入不了--
//总结
//1.HashSet底层是HashMap,第一次添加时,table数组扩容到16，临界值(threshold)是16*加载因子
//(loadFactor)是0.75 = 12
//2.如果table数组使用到了临界值12,就会扩容到16*2 = 32,新的临界值就是32*0.75 = 24,依次类推
//3.在Java8中,如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是8).并且table的大小>=
//MIN_TREEIFY_CAPACITY(默认64),就会进行树化(红黑树)，否则仍然采用数组扩容机制(没有到达扩容阈值也会扩容--treeifyBin()方法)
```

```java
//注意：每一个table的元素相当于链表的head--无论是挂在链表上的元素还是tabel中链表的head，添加一个元素就size++  不受table的非空元素数量影响
```

- Hashset的最佳实践
  - 在set中某类的如果name和age相同则认为是相同对象

```java
//重写hashCode()
@0verride
public int hashCode() {
	return 0bjects.hash(nam hage);
}
//HashCode()相同则比较equals()内容是否相同--HashCode()相同内容不认同则挂在链表后面
public boolean equals(Object o){
	if (this == o) return true;
	if (o == null ll getclass() != o.getclass()) return false;
    Employee employee =(Employee) o;
	return age == employee.age && Objects.equals(name,employee.name);
}
```



##### LinkedHashSet

- 基本说明

1. LinkedHashSet是 HashSet 的子类
2. LinkedHashSet底层是一个 LinkedHashMap，底层维护了一个数组+双向链表

```java
/*
1)在LinkedHastSet中维护了一个hash表和双向链表(LinkedHashSet有head和tail )
2)每一个节点有prev和next属性,这样可以形成双向链表
3)在添加一个元素时，先求hash值，在求索引.确定该元素在
	hashtable的位置，然后将添加的元素加入到双向链表(如果已经存在，不添加的原则和hashset一样])
	tail.next = new Element; //简单指定
	newElement.pre = tail;
	tail = newEelment;
4)遍历LinkedHashSet就可以确保插入顺序和遍历顺序一致
*/
```

3. LinkedHashSet根据元素的hashCode值来决定元素的存储位置,同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。

```java
//1.LinkedHashSet加入顺序和取出元素/数据的顺序一致
//2.LinkedHashSet底层维护的是一个LinkedHashMap(是HashSet的子类--HashSet内部由HashMap实现)
//3.LinkedHashSet底层结构(数组table+双向链表<before和after>+next指针)
//4．第一次添加时，直接将数组table扩容到16,存放的结点类型是 LinkedHashMap$Entry
//5．数组是 HashMap$Node[]存放的元素/数据是LinkedHashMap$Entry(HashMap的内部类)类型

```



3. LinkedHashSet 不允许添重复元素

##### **TreeSet**

- 源码解读

```java
//使用无参构造器创建的TreeSet仍然是无序的
Treeset treeSet = new TreeSet();
//TreeSet的元素添加和compare的实现方法有关--compare方法返回值为0时认为元素相同--不能添加
TreeSet treeSet = new TreeSet(new Comparator() {
	@Override
public int compare(Object o1, Object o2) {
    return ((String) o1).compareTo((String) o2);
	}
});
treeSet.add("Jack");
treeSet.add("Tom");
treeSet.add("A pig");
treeSet.add("ZYP");
System.out.println(treeSet);

```



#### Collection接口和常用方法

- 基本说明

1. Collection实现的子类可以存放多个元素(Object或子类)
2. 有些Collection的实现类,可以存放重复的元素，有些不可以
3. 有些Collection的实现类，有些是有序的(List)，有些不是有序(Set)
4. Collection接口没有直接的实现子类，是通过它的子接口Set 和 List来实现的

- 常用方法

1. add:添加单个元素--自动装箱

  ```java
  List list = new ArrayList();//add :添加承个元素
  list.add("jack"");
  list.add(10);//list.add(new Integer(10))
  list.add(true);
  System.out.println("list=" +list):
  ```

2. remove:删除指定元素--删除(索引指向的)对象

  ```java
  //list.remove(0);//删除第一个元素
  list.remove(true);//指定删除某个元素
  system.out.println("list=" + list);
  ```

3. contains:查找元素是否存在

4. size:获取元素个数

5. isEmpty:判断是否为空

6. clear:清空

7. addAll:添加多个元素

  ```java
  ArrayList list2 = new ArrayList();
  list2.add("红楼梦");
  list2.add("三国演义"");
  list.addAll(list2);
  System.out.println("list=" +list);
  
  ```

8. containsAll:查找多个元素是否都存在

9. removeAll:删除多个元素

  ```java
  list.add(""聊斋"");
  list.removeAll(list2);
  System.out.println("list=" + list);//[聊斋]
  ```

10. 说明:以ArrayList实现类来演示.

- 遍历元素的方法

1. Iterator迭代器遍历---模板快捷键itit

   - iterator()方法--返回一个迭代器----与python的迭代器类似---执行原理

     ![迭代器原理](.\Java入门markdown图片\迭代器原理.png)

     - 调用iterator.next()方法之前需要调用iterator.hasNext()方法进行检测---返回类型为Object编译类型为Object运行类型为实际的类型

     ```java
     Iterator iterator = col.iterator();
     //使用while循环遍历
     while (iterator.hasNext(){//判断是否还有数据
     	//返回下一个元素，类型是Object
     	0bject obj = iterator.next();
         system.out.printiLn("obj=" + obj);
     }
     ```

     - 当循环结束时--指针已经指向迭代器的最后位置--再继续调用iterator.next()---会抛出NoSuchElementException异常

     - 可以重置迭代器再使用--iterator = col.iterator();

     ```java
     iterator = col.iterator();
     System.out.println();
     while (iterator.hasNext() {
     	0bject obj = iterator.next();
         system.out.println( "obj=" + obj);
     }
     ```

     

   - Iterator仅用于遍历集合,Iterator本身并不存放对象。

2. 增强for循环---模板快捷键I

- 基本语法

```java
for(元素类型元素名:集合名或数组名){
访问元素
}
```



### Map

- Map的子类都是双列集合---包括key和value
- Map接口的基本特点(Map的实现类的特点)

1. Map与Collection为两种不同形式的容器类。Map用于保存具有映射关系的数据:Key-Value

2) Map中的key和value可以是任何**引用类型的数据**，会封装到HashMap$Node对象中
3) Map中的key不允许重复，原因和HashSet一样(查看源码)--输出顺序与存放顺序无关--HashMap的本质->idx通过hashCode()获得----存在相同的key时相当于替换
4) Map中的value可以重复
5) Map的key可以为null, value也可以为null，注意key为null,只能有一个，value为null，可以多个.
6) 常用String类作为Map的key
7) key和 value之间存在单向一对一关系，即通过指定的 key 总能找到对应的value
8) Map存放数据的key-value示意图,一对k-v是放在一个Node中的，有因为Node实现了Entry 接口，有些书上也说一对k-v就是一个Entry[看源代码]

```java
//1.k-v最后是 HashMap$Node node = new Node(hash,key,value,null);
//2.k-v为了方便程序员的遍历，还会创建EntrySet集合，该集合存放的元素的类型 Entry，而一个Entry对象就有k, v -- EntrySet<Entry<K,V>>即:transient Set<Map.Entry<K, V>> entrySet;
//3.entrySet中，定义的类型是 Map.Entry，但是实际上存放的还是 HashMap$Node
//	HashMap$Node implements Map.Entry
//4.当把 HashMap$Node 对象存放到 entrySet 方便我们的遍历--Map.Entry提供了getKey()
//	和getValue()两个重要的方法
Map map = new HashMap();
map.put("Key1", "ZYP");
map.put(null, null);
map.put(new Object(), "芝麻开门");
Set set = map.entrySet();
System.out.println(set.getClasss());// HashMap$EntrySet
for (Object obj : set) {
	Map.Entry entry = (Map.Entry) obj;
	System.out.println(entry.getKey() + "-" +entry.getValue() );
}
Set set = map.KeySet();//KeySet()--内部类--获得所有key的Set
Collection col = map.Values();//Values()--内部类--返回所有Value的Collection
```

- Map接口的常用方法

1. 添加元素

```java
Map map = new HashMap();
map.put("Key1", "ZYP");
map.put(null, null);
map.put(new Object(), "芝麻开门");
```

2. 获取元素

```java
map.get(key);//获取key对应的value
```

3. 删除键值元素

```java
map.remove(key);//删除键对应的键值元素
map.remove(null);
```

4) size:获取元素个数

```java
map.size();
```

5. isEmpty:判断个数是否为06) clear:清除

```java
map.isEmpty()//返回boolean类型
```

6. containsKey:查找键是否存在

```java
map.containsKey(Key)//检查Key键是否存在
```

7. clear：清除所有元素

- Map接口的遍历方法

1. 增强for循环

```java
//1.map.Values()->Collection//2.map.keySet()->Set//3.map.EntrySet()->Set
Set keyset = map.keySet();
for (Object key: keyset) {
    System.out.println(map.get(key));
}
Set entrySet = map.EntrySet();
for (object entry : entrySet) {
	//将entry 转成 Map.Entry
	Map.Entry m = (Map.Entry) entry;
	System.out.println(m.getKey() +"-" +m.getValue());
}
```

2. 迭代器

```java
Set keyset = map.keySet();
Iterator iterator = keyset.iterator();
        while (iterator.hasNext()){
            Object next = iterator.next();
            System.out.println(next);
}
```

#### HashMap

- HashMap小结

1) Map接口的常用实现类:HashMap、Hashtable和Properties
2)  HashMap是Map接口使用频率最高的实现类
3) HashMap是以key-val对的方式来存储数据
4) key不能重复，但是是值可以重复,允许使用null键和null值
5) 如果添加相同的key，则会覆盖原来的key-val ,等同于修改.(key不会替换,val会替换)
6) 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的.
7) HashMap没有实现同步，因此是线程不安全的(没有synchronized修饰)

- 底层代码

![HashMap底层结构图](.\Java入门markdown图片\HashMap底层结构图.png)

1. (k,v)是一个Node内部类实现了Map.Entry<K,V>接口--查看HashMap的源码(HashSet部分笔记)
2.  hashmap--jdk7.0的底层实现[数组+链表]， jdk8.0底层实现[数组+链表+红黑树]

- HashMap**扩容机制**(与HashSet完全一样)

1. HashMap底层维护了**Node类型**的数组table，默认为null

2. 当创建对象时，将**加载因子(loadfactor)**初始化为0.75

3. 当添加key-val时，通过key的哈希值得到在table的索引。

   然后判断该索引处是否有元素,如果没有元素直接添加。

   如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val;

   如果不相等需要判断是树结构还是链表结构，做出相应处理;

   如果添加时发现容量不够，则需要扩容。

4. 第1次添加,则需要扩容table容量为16，**临界值(threshold)**为12(16*loadfactor)

5. 以后再扩容，则需要扩容table容量为**原来的2倍**，临界值为原来的2倍,即24,依次类推

6. 在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，并且table的大小 >= MIN_TREEIFY_CAPACITY(默认64),就会进行树化(红黑树)

#### Hashtable

- Hashtable的基本介绍

1. 存放的元素是键值对:即Key-Value
2. Hashtable的**键和值**都**不能为null**--会抛出空指针异常

3) Hashtable使用方法基本上和**HashMap一样**
4) Hashtable是**线程安全**的，hashMap是线程不安全的
5) 简单看下底层结构
   - 初始容量为11
   - 默认临界值(threshold)为0.75
   - 扩容机制：

```java
//关键代码--具体看底层源码
if (count >= threshold)
int newCapacity = (oldCapacity << 1) + 1;
```

- Hashtable和HashMap对比

  ![Hashtable和HashMap对比](.\Java入门markdown图片\Hashtable和HashMap对比.png)

#### Properties

- 基本介绍

1. Properties类**继承自Hashtable类**并且实现了Map接口，也是使用一种键值对的形式来保存数据。
   - K-V不能为null
2. Properties类的使用特点和Hashtable类似
3. Properties还可以用于，从xxx.properties文件中加载数据到Properties类对象,进行读取和修改
4. 说明:工作后xxx.properties文件通常作为配置文件，这个知识点在IO流举例

- 增删改查

```java
Properties properties = new Properties();
//增加
properties.put(key, value);
//删除
properties.remove(key);
//修改
properties.put("学历", "北京大学");
properties.put("学历", "电子科大");
//查找
properties.get("John");
properties.getProperty("John");
```

#### TreeMap

- 底层代码

```java
//有序表--实现Comparator接口的内部类决定表的排序方式--compare方法的返回值为0视为相同对象->由底层代码决定-看源码
//和HashMap的源码对比学习--HashMap是根据Hash()值判断是否是同一个对象
TreeMap map = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();
            }
        });
map.put("jack", "杰克");//第一次添加也会调用compare方法--检验compare方法的可行性
map.put("Tom", "汤姆");
map.put("Kristina", "克瑞斯缇娜");
map.put("Smith", "斯密斯");
map.put("ZYP", "周原平");//替换汤姆--Key值不变--Value改变
System.out.println(map);
//{Tom=汤姆, jack=杰克, Smith=斯密斯, Kristina=克瑞斯缇娜}
//{Tom=周原平, jack=杰克, Smith=斯密斯, Kristina=克瑞斯缇娜}
```



#### LinkedHashMap

##### 

### Collections工具类

- 基本介绍

1. Collections是一个操作 Set、List和Map等集合的工具类
2. Collections中提供了一系列**静态的方法**对集合元素进行排序、查询和修改等操作

- 排序

1. sort(List):根据元素的自然顺序对指定List集合元素按升序排序

```java
List list = new ArrayList();
list.add("jack");
list.add("Joe");
list.add("ZYP");
list.add("kakaxi");
System.out.println(list);
Collections.sort(list);
System.out.println(list);
//[jack, Joe, ZYP, kakaxi]
//[Joe, ZYP, jack, kakaxi]
```

2. reverse(List):反转 List中元素的顺序

```java
Collections.reverse(list);
System.out.println(list);
//[kakaxi, jack, ZYP, Joe]
```

3. shuffle(List):对List集合元素进行随机打乱

```java
Collections.shuffle(list);
System.out.println(list);
//[kakaxi, jack, ZYP, Joe]
//[jack, Joe, kakaxi, ZYP]
```

4. sort(List, Comparator):根据指定的Comparator产生的顺序对List集合元素进行排序

```java
Collections.sort(list, new Comparator(){
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).compareTo((String) o2);
            }
        });
System.out.println(list);
//[Joe, ZYP, jack, kakaxi]
```

5. swap(List, int, int):将指定List集合中i处元素和j处元素进行交换

```jav
Collections.swap(list, 0 , 2);
System.out.println(list);
//[Joe, ZYP, jack, kakaxi]
//[jack, ZYP, Joe, kakaxi]
```

- 查找替换

1. Object max(Collection):根据元素的自然顺序，返回给定集合中的最大元素
2. Object max(Collection, Comparator):根据Comparator 指定的顺序,返回给定集合中的最大元素
3. Object min(Collection)
4. object min(Collection,Comparator)
5. int frequency(Collection, Object):返回指定集合中指定元素的出现次数
6.  copy(List dest, List src):将src中的内容复制到dest中
7. boolean replaceAll(List list, T oldVal, T newVal):新值替换List 对象的所有旧值
   

### 集合选型规则

在开发中，选择什么集合实现类，主要取决于**业务操作特点**，然后根据集合实现类特性进行选择，分析如下:

1. 先判断存储的类型(一组对象[单列]或一组键值对[双例])
2. 一组对象:Collection接口
   - 允许重复:List
     - 增删多:LinkedList [底层维护了一个双向链表]
     - 改查多:ArrayList [底层维护Object类型的可变数组]
   - 不允许重复:Set
     - 无序: HashSet [底层是HashMap，维护了一个哈希表即(数组+链表+红黑树)
     - 排序:TreeSet
     - 插入和取出顺序一致:LinkedHashSet，维护数组+双向链表

3. 一组键值对:Map
   - 键无序：HashMap [底层是:哈希表 jdk7:数组+链表，jdk8:数组+链表+红黑树]
   - 键排序：TreeMap
   - 键插入和取出顺序一致：LinkedHashMap
   - 读取文件：Properties

### 6.泛型

#### 泛型的引入

1. 在Collection的数据容器中无法限制数据类型(不安全)

   比如在处理Dog类的程序中，储存Dog类的HashSet中出现Cat类型

2. 遍历时需要数据类型的转换，数据量很大的时候影响效率

- 引入泛型解决以上问题

#### 泛型的快速入门

```java
//使用中括号限制ArrayList中接受的数据类型
ArrayList<Dog> arr = new ArrayList<Dog>();
//直接使用泛型指定的数据类型进行增强for循环
//原来只能使用Object进行接受(List包含各种数据类型的时候)->向下转型再使用->效率低
for (Dog dog : arrayList) {
	System.out.println(dog. getName() + "-" +dog. getAge());
}

```

#### 泛型的基本介绍 

1. 泛(广泛)型(类型)又称**参数化类型**，是Jdk5.0出现的新特性，解决数据类型的安全性问题。可以理解为泛型是表示数据类型的一种(数据)类型。
2. 在类声明或实例化时需要指定具体的类型。ArrayList< Dog >相当于将底层代码中的< E >全部替换为Dog类型->有点类似实参传值给形参。

3) Java泛型可以保证如果程序在**编译时**没有发出警告，运行时就不会产生ClassCastException异常。同时,代码更加简洁、稳定。
3) 泛型的作用是:可以在类声明时通过一个标识表示类中某个**属性的类型**,或者是某个方
   法的**返回值的类型**，或者是**参数类型**。

```java
//再编译期间就指定E的类型
//属性的类型
class Person<E> {
    E s;//指定属性s的数据类型为E
    public Person(E s) { // 指定参数类型
        this.s = s;
    }
    public E func { // 指定返回值类型
        return s ;
    }
}
//当我设置E为String类型时，代码相当于
class Person<String> {
    String s;//指定属性s的数据类型为E
    public Person(String s) { // 指定参数类型
        this.s = s;
    }
    public String func { // 指定返回值类型
        return s ;
    }
}
```

#### 泛型的基本语法

- 泛型的声明

```java
interface 接口<T> {
    
}
class 类<K,V> {
    
}
//参考List和ArrayList
```

1. 其中，T/K/V不代表值，而是表示类型。
2. 可以用任意字母表示。常用T表示，是Type的缩写。

- 泛型的实例化

```java
//指定集合或者迭代器内部的类型和某种类型有关
List<String> strList = new Array List<String>();
Iterator<Customer> iterator = customers.iterator();
```

#### 泛型的注意与细节

1. 泛型只能是**引用数据类型**。

```java
//泛型只能是引用数据类型
interface List<T>()
public class HashSet<E>{
    ...
}
//下面语句是否正确
List<Integer> list = new ArrayList<Integer>();//正确
List<int> list2 = new ArrayList<int>();//不正确
```

2. 在指定泛型具体类型后，可以传入该类型或者其子类。
3. 泛型使用形式

```java
List<Integer> list1 =new ArrayList<Integer>();
List<Integer> list2 = new ArrayList<>();//简写形式--实际开发过程推荐的写法
List list3 = new ArrayList();//则默认泛型为Object类
```

#### 自定义泛型

##### 自定义泛型类

- 基本语法

```java
class 类名<T, R...> {//类//...表示可以指定多个泛型
    成员
}
```

- 注意细节

1. 普通成员可以使用泛型(属性、方法)
2. 使用**泛型的数组**,**不能初始化

```java
T[] arr;//可以声明
T[] arr = new T[8];//初始化保持--不确定T的类型没办法分配初始化空间
```

3. **静态方法**中**不能**使用类的泛型
   - 静态成员和类有关，类加载时还没有实例化对象，JVM不知道泛型的类型

4. 泛型类的类型，是在创建对象时确定的(因为创建对象时，需要指定确定类型)
5. 如果在创建对象时,没有指定类型，**默认为Object**

##### 自定义泛型接口

- 基本语法

```java
interface 接口名<T,R...> {//接口
    成员
}
```

- 注意细节

1. 接口中，**静态成员**也**不能使用**泛型(和泛型类规定一样)

```java
interface IUsb<U，R> {
//接口中的成员都是静态的
    U name; // 报错
//普通方法中，可以使用接口泛型
    R get(U u);
    void hi(R r);
    void run(R r1，R r2,U u1,U u2);
//在jdk8中，可以在接口中使用默认方法，默认方法也可以使用泛型
    default R method(U u) {
        return null;
    }
}
```

2. 在**继承接口或者实现接口**时确定接口泛型的类型

```java
interface IA extends IUsb<String,Double> {
    
}
//当我们去实现IA接口时，因为IA在继承IUsU接口时，指定了U为String R为Double
//在实现IUsu接口的方法时，使用String替换U，是Double替换R
class AA implements IA {
    @override
    public Double get(String s) {
    return null;
    }
    @Override
    public void hi(Double aDouble) {
    }
}
```

3. 没有指定类型，默认为Object

##### 自定义泛型方法

- 基本语法

```java
修饰符 <T,R..> 返回类型 方法名(参数列表) {
    
}

```

- 注意细节

1. 泛型方法，可以定义在**普通类**中或**泛型类**中

```java
//普通类中定义泛型方法
class Car {
	public void run() {//普通方法
    }
	//说明
	//1.<T,R>就是泛型
    //2.提供给fly使用的
	public <T,R> void fly(T t,R r) {//泛型方法
	}
}
//泛型类中定义泛型方
class Fish<T，R>{//泛型霆
    public void run() {//普通方法
    }
    public <U,M> void eat(U u,M m) {//泛型方法
    }
}
```

2. 当泛型方法**被调用**时，类型会确定

```java
//泛型方法的调用和普通方法一样，但是传入类型确定的时候，泛型的类型也确定
Car car = new Car();
car.fly("宝马"，100);//当调用方法时，传入参数，编译器，就会确定类型
car.fly(300，100.1);//当调用方法时，传入参数，编译器，就会确定类型
```

3. public void eat(E e){}，修饰符后没有<T,R..> eat方法不是泛型方法，而是使用了泛型
4. 泛型方法可以使用类声明的泛型，也可以使用自己声明泛型

```java
//泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型
    public <k> void hello(R r,K k){//R是类声明的泛型
}
```



#### 泛型的继承和通配符

- 基本说明

1. 泛型**不具备继承性**

```java
//没有继承性
List<Object> list = new ArrayList<String>();//错误的
```

2. <?>︰支持任意泛型类型
3. <? extends A>：支持A类以及A类的子类,规定了泛型的上限
4. <? super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * @version 1.0
 * @auther Meez
 */
public class GenericExtends {
    public static void main(String[] args) {
        List<Objects> l1 = new ArrayList<>();
        List<String> l2 = new ArrayList<>();
        List<AA> l3 = new ArrayList<>();
        List<BB> l4 = new ArrayList<>();
        List<CC> l5 = new ArrayList<>();
        printList1(l1);
        printList1(l2);
        printList1(l3);
        printList1(l4);
        printList1(l5);
        printList2(l1);//报错
        printList2(l2);//报错
        printList2(l3);//报错
        printList2(l4);
        printList2(l5);
        printList3(l1);//报错
        printList3(l2);//报错
        printList3(l3);
        printList3(l4);
        printList3(l5);//报错
    }
    public static void printList1(List<?> l){
        System.out.println(l);
    }
    public static void printList2(List<? extends BB> l){
        System.out.println(l);
    }
    public static void printList3(List<? super BB> l){
        System.out.println(l);
    }

}
class AA{}
class BB extends AA{}
class CC extends BB{}
```

#### JUnit的使用

- 为什么需要JUnit？

1. 一个类有很多功能代码需要测试，为了测试需要把代码写到main方法中
2. 如果有多个功能代码测试就需要来回注释，切换很麻烦
3. 如果可以直接运行一个方法，就方便很多，并且可以给出相关信息-> JUnit测试框架

- 基本介绍

1. JUnit是一个Java语言的单元测试框架
2. 多数Java的开发环境都已经集成了JUnit作为单元测试的工具

- 使用方法

```java
//IDEA的快捷键Alt + Enter --> 快捷选择引用
@Test
public void m1() {// 直接出现运行小箭头
    System.out.println("m1方法");
}
```

### 7.线程基础

#### 线程相关概念

- 程序：是为完成特定任务、用某种语言编写的一组指令的集合。简单的说，就是我们写的代码。

- 进程

1. 进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间。
2. 进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程:有它自身的产生、存在和消亡的过程

- 线程

1. 线程由进程创建的,是进程的一个实体

2. 一个进程可以拥有多个线程,如下图

- 其他相关概念

1. 单线程：同一个时刻，只允许执行一个线程
2. 多线程：同一个时刻，可以执行多个线程，比如:一个qq进程，可以同时打并多个聊天窗口,一个迅雷进程，可以同时下载多个文件
3. 并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发。
4. 并行：同一个时刻，多个任务同时执行。多核cpu可以实现并行。

```java
//查看CPU的线程数量
Runtime runtime = Runtime.getRuntime();
int cupNum = runtime.availableProcessors();
```

#### 线程的使用

- Java创建线程的两种方法

1. 继承Thread类，重写run方法(Thread类实现了Runnable接口)
2. 实现Runnable接口，重写run方法

- 基本使用方法

1. 请编写程序,开启一个线程，该线程每隔1秒。在控制台输出“喵喵,球是小猫咪“

2. 使用JConsole监控线程执行情况，并画出程序示意图!
3. 主线程可以开子线程，子线程也可以开其他的子线程。所有子线程运行结束该进程才结束运行。

```java
//可以通过JConsole监控线程
public class ThreadTest {
    public static void main(String[] args) {
        //可以当做线程使用的Cat类
        Cat cat = new Cat();
        /*
        源码解读
        (1)
        public synchronized void start() {
        start0();
        }
        (2)
        //start0()是本地方法，是JVM调用，底层是c/c++实现
        //真正实现多线程的效果，是stdto()，而不是 run 
        //private native void start0();
        
        start()方法调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。
        具体什么时候执行，取决于CPU，由CPU统一调度。
		*/
        cat.start();
        
        
        //当main线程启动一个子线程 Thread-0，主线程不会阻塞，会继续执行
		//主线程和子线程同时在运行
        System.out.println("----主线程继续执行----");
        for (int i = 0; i < 10; i++) {
            System.out.println("主线程正在执行");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
//1．当一个类继承了Thread类，该类就可以当做线程使用
//2．我们会重写run方法，写上自己的业务代码
//3. run Thread类实现了 Runnable 接口的run方法
class Cat extends Thread {
    private int times = 0;
    @Override
    public void run() {
        while (times < 8){
            System.out.println("喵喵" + "\t" + "子线程执行");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            times++;
        }
    }
}
```

- 为什么线程实例.start()会运行run()方法？为什么不直接线程实例.run()调用方法呢？

1. run方法就是一个普通的方法，没有真正的启动一个线程，把run方法执行完毕，才向下执行。直接调用run()方法就是串行执行，按顺序执行代码。

2. start()方法调用start0()方法后(start0()方法由JVM调用)，该线程并不一定会立马执行，只是将线程变成了可运行状态。

   具体什么时候执行，取决于CPU，由CPU统一调度。跟操作系统的底层算法有关。

- 实现Runnable接口

1. java是**单继承**模式，在某些情况下一个类可能已经继承了某个父类,这时就不能通过继承Thread类方法来创建线程。
2. java设计者们提供了另外一个方式创建线程，通过实现Runnable接口来创建线程。

```java
public class RunnableTest {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Thread thread = new Thread(dog);//这里使用了设计模式[静态代理模式]
        thread.start();
    }
}
class Dog implements Runnable {
    int count = 0;
    @Override
    public void run() {
        while (count < 11){
            System.out.println("小狗汪汪叫" + (++count) + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }

    }
}
```

- 多线程的使用

```java
public class MulThreadTest {
    public static void main(String[] args) {
        Speaker s1 = new Speaker("Hello, Word");
        Speaker s2 = new Speaker("Hi!!!");
        Thread st1 = new Thread(s1);
        Thread st2 = new Thread(s2);
        st1.start();
        st2.start();
    }
}
class Speaker implements Runnable{
    private String content;
    private int count = 0;
    public Speaker(String cont) {
        content = cont;
    }

    @Override
    public void run() {
        while (count < 10) {
            System.out.println(content + (++count));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

- 继承Thread和实现Runnable的区别

1. 从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从JDK帮助文档我们可以看到Thread类本身就实现了实现Runnable接口
2. 实现Runnable接口方式更加适合**多个线程共享一个资源**的情况(一个对象创建多个线程)，并且避免了单继承的限制

```java
//两种实现方法都会出现票数超卖的情况-->怎么解决？
public class SellTickets {
    public static void main(String[] args) {
        SellTickets01 sellTickets01 = new SellTickets01();
        SellTickets01 sellTickets02 = new SellTickets01();
        SellTickets01 sellTickets03 = new SellTickets01();
        sellTickets01.start();
        sellTickets02.start();
        sellTickets03.start();
    }
}
class SellTickets01 extends Thread{
    private static int allTickets = 100;
    @Override
    public void run() {
        while (allTickets > 0) {
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            allTickets--;
            System.out.println("窗口" + Thread.currentThread().getName() + "出售一张票" + "\t"
                    + "剩余票数为" + allTickets
            );
        }
        System.out.println("窗口" + Thread.currentThread().getName() + "结束售卖");
    }
}
```

- 线程终止

1. 当线程完成任务后，会自动退出。
2. 还可以通过使用变量来控制run方法退出的方式停止线程，即**通知方式**。用主线程控制子线程变量的方法-控制子线程的运行

#### 线程常用方法

- 常用方法--第一组

1. setName //设置线程名称，使之与参数name相同

2. getName//返回该线程的名称
3. start//使该线程开始执行;Java虚拟机底层调用该线程的start0()方法
4. run//调用线程对象run方法;
5. setPriority //更改线程的优先级

```java
t.setPriority(Thread.MIN_PRIORITY);
t.start();//启动子线程
```

6. getPriority//获取线程的优先级
7. sleep//在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)
8. interrupt//中断线程

```java
try {
	System.out.println(Thread.currentThread().getName() +"休眠中~~sr~");
    Thread.sleep(2ogoop ; //20秒
}catch (InterruptedException e) {
//当该线程执行到一个interrupt 方法时，就会catch一个异常，可以加入自己的业务代码
//InterruptedException是捕获到一个中断异常.
	system. out.println(Thread.currentThread(). getName()+"被interrupt了");
}
// 主程序调t.interrupt()会打断休眠，进入catch语句
```

- 常用方法-第二组

1. yield(静态方法)：线程的让步。让出CPU，让其他线程执行，但礼让的时间不确定，CPU资源不紧张，所以也**不一定礼让成功**。

2. join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务。

   案例1：main线程中调用t1.join()

   (1)：让t1线程的内容执行完

   (2)：返回main线程继续执行 

   案例2：创建一个子线程，每隔1s输出hello,输出20次,主线程每隔1秒，输出hi，输出20次.要求:两个线程同时执行，当主线程输出5次后，就让子线程运行完毕，主线程再继续,

- 细节与注意事项

1. start底层会创建新的线程，调用run,run就是一个简单的方法调用，不会启动新
   线程
2. 线程优先级的范围

3. interrupt：中断线程，但并没有真正的结束线程。所以一般用于中断正在休眠线程
4. sleep：线程的静态方法，使当前线程休眠

```java
try {
    system.out.println(Thread.currentThread().getName() +”休眠中~~v~");
    Thread.sleep(20000);//20秒
}catch (InterruptedException e) {
//当该线程执行到一个interrupt 方法时，就会catch一个异常，可以加入自己的业务代码
//InterruptedException是捕获到一个中断异常
	system.out.println(Thread.currentThread().getName()+"被interrupt了");
}
```

- 用户线程和守护线程

1. 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束
2. 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束
3. 常见的守护线程：垃圾回收机制

```java
MyDaemonThread myDaemonThread = new MyDaemonThread();
//如果我们希望当main线程结束后，子线程自动结束
//只需将子线程设为守护线程即可
myDaemonThread.setDaemon(true);//将子线程设置为守护线程
myDaemonThread.start();
```

#### 线程的生命周期

- 线程的状态：Thread.State枚举类型表示线程的几种状态

1. NEW：尚未启动的线程处于此状态。
2. RUNNABLE：在Java虚拟机中执行的线程处于此状态。RUNNABLE状态可以拆分为Ready和Running两个状态。
3. BLOCKED：被阻塞等待监视器锁定的线程处于此状态。
4. WAITING：正在等待另一个线程执行特定动作的线程处于此状态。
5. TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
6. TERMINATED：已退出的线程处于此状态。

- 线程状态转移图：记住转移关系！！！

<img src=".\Java入门markdown图片\线程状态示意图.png" alt="线程状态示意图" style="zoom: 33%;" />

- 查看线程状态

```java
//t1.getState()--查看线程状态
public class ThreadStateTest {
    public static void main(String[] args) {
        ThreadTest001 t1 = new ThreadTest001();
        System.out.println(t1.getName() + "状态为" + t1.getState());
        t1.start();
        while (t1.getState() != Thread.State.TERMINATED){
            System.out.println("状态为" + t1.getState());
        }
        System.out.println("状态为" + t1.getState());
    }
}
class ThreadTest001 extends Thread{
    @Override
    public void run() {
        while (true) {
            for (int i = 0; i < 10; i++) {
                System.out.println("第" + i + "次执行");
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            break;
        }
    }
}
```

#### 线程同步-Synchronized

- 基本概念

1. 在多线程编程，一些敏感数据不允许被多个线程同时访问。此时使用同步访问技术，保证数据在任何时刻**最多有一个线程访问**，以保证数据的完整性。
2. 线程同步，当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。

-  线程同步的实现方法--Synchronized

1．同步代码块

```java
synchronized (对象) {//得到对象的锁，才能操作同步代码
//需要被同步代码;
}
```

2. synchronized还可以放在方法声明中，表示整个方法-为同步方法

```java
public synchronized void m (String name) {
//需要被同步的代码
}
```

```java
//继承Thread类不能多次使用start();方法
public class SellTickets {
    public static void main(String[] args) {
        SellTickets01 sellTickets01 = new SellTickets01();
        sellTickets01.start();
        sellTickets01.start();
        sellTickets01.start();
    }
}
class SellTickets01 implements Thread{
    private static int allTickets = 100;
    @Override
    public void run() {
        while (allTickets > 0) {
            sell();
        }
        System.out.println("窗口" + Thread.currentThread().getName() + "结束售卖");
    }
    public synchronized void sell(){

        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        allTickets--;
        System.out.println("窗口" + Thread.currentThread().getName() + "出售一张票" + "\t"
                + "剩余票数为" + allTickets
        );
    }
}

```

```java
//实现Runnable接口
//还是会超卖？？？？---->解决方法->进入售卖阶段的部分要放到synchronized修饰的方法中(很关键)
public class SellTickets {
    public static void main(String[] args) {
        SellTickets01 sellTickets01 = new SellTickets01();
        new Thread(sellTickets01).start();
        new Thread(sellTickets01).start();
        new Thread(sellTickets01).start();
    }
}
class SellTickets01 implements Runnable{
    private static int allTickets = 100;
    private boolean loop = true;
    @Override
    public void run() {
        while (loop) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            sell();
        }
    }
    public synchronized void sell(){
        if (allTickets <= 0){
            System.out.println("窗口" + Thread.currentThread().getName() + "结束售卖");
            loop = false;
            return;
        }
        allTickets--;
        System.out.println("窗口" + Thread.currentThread().getName() + "出售一张票" + "\t"
                + "剩余票数为" + allTickets
        );
    }
}
```

#### 互斥锁

- 基本介绍

1. Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。
2. 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
3. 关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能有一个线程访问。
4. 同步的局限性:导致程序的执行效率要降低。
5. 同步方法(非静态的)的锁可以是this(当前对象),也可以是其他对象(要求是同一个对象-->同一个对象/共享的对象才能锁住)。

```java
synchronized (this) {//可以是this也可以是其他对象
    //代码块
}
```

6. 同步方法(静态的)的锁为当前类本身。

```java
//静态方法中实现同步代码块(对象互斥锁)
synchronized (类名.class) {//this不行
    //代码块
}
```

- 细节与注意

1. 同步方法如果没有使用static修饰:默认锁对象为this

2. 如果方法使用static修饰,默认锁对象:当前类.class

3. 实现的落地步骤:

   - 需要先分析上锁的代码

   - 选择同步代码块或同步方法
   - 要求**多个线程的锁对象为同一个**即可!

#### 线程的死锁

- 基本介绍

多个线程都占用了对方的锁资源，但不肯相让，导致了死锁,在编程是一定要避免死锁的发生.

```java
//两个线程互相需要对方的对象锁
public class DeadLockTest {
    public static void main(String[] args) {
        DeadLockDemo dl1 = new DeadLockDemo(true);
        DeadLockDemo dl2 = new DeadLockDemo(false);
        dl1.start();
        dl2.start();
    }
}
class DeadLockDemo extends Thread {
    static final Object o1 = new Object();
    static final Object o2 = new Object();
    boolean flag;
    public DeadLockDemo(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag) {
            synchronized (o1) {
                System.out.println(Thread.currentThread().getName() + "进入1");
                synchronized (o2) {
                    System.out.println(Thread.currentThread().getName() + "进入2");
                }
            }
        } else {
            synchronized (o2) {
                System.out.println(Thread.currentThread().getName() + "进入3");
                synchronized (o1) {
                    System.out.println(Thread.currentThread().getName() + "进入4");
                }
            }
        }
    }
}
```

#### 释放锁

- 会释放锁的操作

1. 当前线程的同步方法、同步代码块执行结束案例。
2. 当前线程在同步代码块、同步方法中遇到break、return。
3. 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。
4. 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。

- 不会释放锁的操作

1. 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁。
2. 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起,该线程不会释放锁。
   提示;应尽量避免使用suspend()和resume()来控制线程，方法不再推荐使用



### 8.IO流

#### 文件

- 文件流：文件在程序中是以流的形式来操作的
  - 流:数据在数据源(文件)和程序(内存)之间经历的路径
  - 输入流:数据从数据源(文件)到程序(内存)的路径
  - 输出流:数据从程序(内存)到数据源(文件)的路径

- 创建文件对象相关构造器和方法

```java
new File(String pathname)//根据路径构建一个File对象
new File(File parent, String child)//根据父目录文件+子路径构建
new File(String parent, String child)//根据父目录+子路径构建
createNewFile //创建新文件
```

```java
// "/"和"\\"两种方法都可以表示分隔符--Windows下
public void creat01() {
    String filePath = ".\\news1.txt";
    File f = new File(filePath); //在内存中创建
    try {
        f.createNewFile(); //保存到文件中(磁盘)
        System.out.println("文件创建成功");
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
public void creat02() {
        File parentFile = new File("C:/Users/97359/Desktop");
        String fileName = "news1.txt";
        File f = new File(parentFile, fileName); //在内存中创建
        try {
            f.createNewFile(); //保存到文件中(磁盘)
            System.out.println("文件创建成功");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
}
```

- 获取文件相关信息的方法(常用方法)

1. getName() //获取文件名称
2. getAbsolutePath() //获取绝对路径
3. getParent() // 获取父级文件目录
4. length() //获取文件大小
5. exists() //文件是否存在
6. isFileisDirectory() //是不是一个目录

```java
public void getFileinfo() {
    File file = new File("C:\\Users\\97359\\Desktop\\news1.txt");
    System.out.println(file.getName());
    System.out.println(file.getAbsoluteFile());
    System.out.println(file.getParentFile());
    System.out.println(file.length());
    System.out.println(file.exists());
    System.out.println(file.isDirectory());
}
```

- 目录的操作和文件删除

1. mkdir创建一级目录 // 文件目录(文件夹)在Java中也被当作文件
2. mkdirs创建多级目录
3. delete删除空目录或文件

```java
//删除文件
public void module1() {
    String filePath = "C:\\\\Users\\\\97359\\\\Desktop\\\\news1.txt";
    File file = new File(filePath);
    if (file.exists()) {
        if (file.delete()) {
            System.out.println("文件被删除");
        }
    } else {
        System.out.println("文件不存在");
    }
}
//
public void module2() {
    String filePath = "C:\\Users\\97359\\Desktop\\目录2";
    File file = new File(filePath);
    if (file.exists()) {
        System.out.println("目录存在");
    } else {
        System.out.println("目录不存在");
        file.mkdir();//创建一级目录
        System.out.println("创建目录");
    }
}
public void module3() {
    String filePath = "C:\\Users\\97359\\Desktop\\目录2/子目录";
    File file = new File(filePath);
    if (file.exists()) {
        System.out.println("目录存在");
    } else {
        System.out.println("目录不存在");
        file.mkdirs();//创建多级目录
        System.out.println("创建目录");
    }
}
```

#### IO流原理及流的分类

- 基本原理

1. I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理数据传输。
   如读/写文件，网络通讯等。
2. Java程序中，对于数据的输入/输出操作以”流(stream)”的方式进行。
3. java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据
4. 输入input:读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中。
5. 输出output:将程序(内存)数据输出到磁盘、光盘等存储设备中。

- 流的分类
  - Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的。
  - 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。

1. 按操作数据单位不同分为:字节流(8 bit)，字符流(按字符)
2. 按数据流的流向不同分为:输入流，输出流

<img src=".\Java入门markdown图片\流的分类.png" alt="流的分类" style="zoom:50%;" />

3. 按流的角色的不同分为:节点流，处理流/包装流

#### 节点流和处理流

- 基本介绍

1. **节点流**可以从一个特定的数据源(字符串、数组、文件、管道等----存放数据的地方)读写数据，如FileReader、FileWriter [源码]
2. **处理流**(也叫**包装流**)是“连接”在已存在的流（节点流或处理流)之上，为程序提供更为强大的读写功能,如BufferedReader、BufferedWriter等 [源码] -> 把节点流(reader/writer的子类)存在属性内、

- 节点流和处理流一览图：粗体节点流，非粗体字节流

<img src=".\Java入门markdown图片\节点流和处理流一览图.png" alt="节点流和处理流一览图" style="zoom:50%;" />

- 节点流和处理流的区别和联系

1. 节点流是底层流/低级流,直接跟数据源相接。
2. 处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。[源码理解]

3. 处理流(也叫包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连[模拟修饰器设计模式]

- 处理流的功能主要体现在以下两个方面:（**处理流设计模式没懂就再看P623**）

  基本思路 ：让低级的节点流继承处理流，处理流内部可以接受所有继承自己的子类->实现不同节点流的处理操作

1. 性能的提高:主要以增加缓冲的方式来提高输入输出的效率。
2. 操作的便捷:处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据,使用更加灵活方便

#### 输入流

##### InputStream：字节输入流

###### FilelnputStream：文件输入流

- 构造方法

1. FilelnputStream(File file)：通过打开实际文件创建
2. FilelnputStream(文件描述)：通过文件描述创建
3. FilelnputStream(String name)：通过文件的路径创建

- 成员方法

1. available()：返回剩余字节数
2. close()：关闭输入流
3. finalize()：确保使用时不被调用close方法
4. getChannel()：返回与本文件有关的FileChannel对象
5. getFD()：返回FileDiscripter对象
6. read()：读取一个字节
7. read(byte[] b)：b子节点的数据读入byte数组
8. read(byte[] b, int off, int len)：读取len个字节数据到byte数组中
9. skip(long n)：跳过n个字节的数据并抛弃

- 文件读取

```java
//单个字节读取
public void readFile01() throws IOException {
        String filePath = "C:\\Users\\97359\\Desktop\\test.txt";
        int readDate = 0;
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(filePath);
            while ((readDate = fileInputStream.read()) != -1) {
                System.out.print((char) readDate);
            }
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } finally {
            assert fileInputStream != null;
            fileInputStream.close();
        }
}
```

```java
//按照字节数组的大小读取
public void readFile02() throws IOException {
        String filePath = "C:\\Users\\97359\\Desktop\\test.txt";
        byte[] buf = new byte[8];
        int bufLen = 0;
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(filePath);
            //如果正常运行返回实际的字节数
            while ((bufLen = fileInputStream.read(buf)) != -1) {
                //不能使用buf.length
                System.out.print(new String(buf, 0, bufLen));
            }
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } finally {
            assert fileInputStream != null;
            fileInputStream.close();
        }
    }
```



###### BufferedInputStream：缓冲字节输入流/处理流

- 案例

```java
//字节文件拷贝(图片，音乐，视频等)--同样可以操作字符文件/文本文件
public static void main(String[] args) throws IOException {
    String srcFile = "C:\\Users\\97359\\Desktop\\fish.jpg";
    String destFile = "C:\\Users\\97359\\Desktop\\fish1.jpg";
    BufferedInputStream bufferedInputStream = null;
    BufferedOutputStream bufferedOutputStream = null;
    byte[] buf = new byte[1024];
    int bufLen = 0;
    try {
        bufferedInputStream = new BufferedInputStream(new FileInputStream(srcFile));
        bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(destFile));
        while ((bufLen = bufferedInputStream.read(buf)) != -1) {
            bufferedOutputStream.write(buf, 0, bufLen);
        }
    } catch (FileNotFoundException e) {
        throw new RuntimeException(e);
    } finally {
        if (bufferedInputStream != null){
            bufferedInputStream.close();
        }

        if (bufferedOutputStream != null) {
            bufferedOutputStream.close();
        }
    }
}
```



###### objectInputStream：对象字节输入流

- 基本需求

1. 将int num = 100这个int类型的数据保存到文件中。注意不是100数字，而是(int)100，并且能够从文件中直接恢复(int)100
2. 将Dog dog = new Dog(“小黄”，3)，将这个dog对象保存到文件中，并且能够从文件恢复
3. 上述需求就是能将**基本数据类型**或者**对象**进行**序列化**和**反序列化操作**

- 序列化和反序列化

1. 序列化就是在保存数据时，保存数据的**值**和**数据类型**

2. 反序列化就是在恢复数据时，恢复数据的值和数据类型

3. 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该
   类必须实现如下两个接口之一:

   >Serializable //这是一个标记接口->推荐使用这个--没有需要实现接口方法
   >Externalizable//

- 案例

```java
//使用ObjectOutputStream反序列化数据
package com.inputstreamtest;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import com.inputstreamtest.ObjectOutStreamTest.*;
public class ObjectInputStreamTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        String filePath = "C:\\Users\\97359\\Desktop\\data.dat";
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath));
        //反序列化的顺序必须与序列化的顺序一致
        System.out.println(ois.readInt());
        System.out.println(ois.readBoolean());
        System.out.println(ois.readChar());
        System.out.println(ois.readUTF());
        Object rabbit = ois.readObject();
        System.out.println("运行类型=" +rabbit.getClass());System.out.println("dog信息=" + rabbit);
        ois.close();
        Rabbit r = (Rabbit) rabbit;//把类拷贝引用过来--必须和创建时的是同一个类
    }
}
```

- 注意事项和细节说明

1. 读写**顺序要一致**
2. 要求序列化或反序列化对象,需要实现Serializable
3. 序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性
4. 序列化对象时，默认将里面所有属性都进行序列化，但除了**static或transient修饰**的成员
5. 序列化对象时,要求里面**属性的类型**(比如属性为某个类对象-该类需要实现Serializable)也需要**实现序列化接口**
6. 序列化具备**可继承性**,也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化



##### Reader：字符输入流

###### FileReader

- 相关方法

1. new FileReader(File/String)
2) read:每次读取单个字符，返回该字符，如果到文件末尾返回-1
3) read(char[]):批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1

相关APl:

1. new String(char[]):将char[]转换成String
2. new String(char[], off, len):将char[]的指定部分转换成String

- 读取文件

```java
//读取单个字符
public static void main(String[] args) throws IOException {
    String filePath = "C:\\Users\\97359\\Desktop\\test.txt";
    FileReader fileReader = null;
    //        char[] chars = new char[1024];
    int data = 0;
    try {
        fileReader = new FileReader(filePath);
        while ((data = fileReader.read()) != -1) {
            System.out.print((char) data);
        }

    } catch (FileNotFoundException e) {
        throw new RuntimeException(e);
    } finally {
        assert fileReader != null;
        fileReader.close();
    }
}
//字符数组读取
public void read01() throws IOException {
        String filePath = "C:\\Users\\97359\\Desktop\\test.txt";
        FileReader fileReader = null;
        char[] chars = new char[8];
        int bufLen = 0;
        try {
            fileReader = new FileReader(filePath);
            while ((bufLen = fileReader.read(chars)) != -1) {
                System.out.print(new String(chars));
                System.out.println(bufLen);
            }

        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            assert fileReader != null;
            fileReader.close();
        }
    }
```



###### BufferedReader：处理流/字符流

- 基本说明

1. BufferedReader和 BufferedWriter属于**字符流**，按照字符来读取数据
2. 关闭时，只需要关闭外层流即可[后面看源码]----关闭处理流的时候会关闭节点流

- 处理案例

```java
//使用BufferedReader读取文本文件(BufferedReader按字符读取-->读取二进制文件可能会信息损失),并显示在控制台
public static void main(String[] args) throws IOException {
    String filePath = "C:\\Users\\97359\\Desktop\\test.txt";
    //创建BufferedReader
    BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
    //读取
    String line;
    //按行读取->到达末尾返回null
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }
    bufferedReader.close();//底层调用传入节点流的方法
}
```

```java
//Bufferedwriter写入文件
public static void main(String[] args) throws IOException {
    String filePath = "C:\\Users\\97359\\Desktop\\test1.txt";
    BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath, true));//再节点流的位置设置是否追加模式
    bufferedWriter.write("hello1, zyp");
    bufferedWriter.newLine();//插入和系统相关的换行符
    bufferedWriter.write("hello2, zyp");
    bufferedWriter.newLine();//插入和系统相关的换行符
    bufferedWriter.write("hello3, zyp");
    bufferedWriter.newLine();//插入和系统相关的换行符
    bufferedWriter.write("hello4, zyp");
    bufferedWriter.newLine();//插入和系统相关的换行符
    bufferedWriter.close();
}
```

```java
//综合案例---文件拷贝
public void CopyTest() throws IOException {
    String srcFile = "C:\\Users\\97359\\Desktop\\test1.txt";
    String destFile = "C:\\Users\\97359\\Desktop\\testWrite.txt";
    BufferedReader bufferedReader = null;
    BufferedWriter bufferedWriter = null;
    String line;
    try {
        bufferedReader = new BufferedReader(new FileReader(srcFile));
        bufferedWriter = new BufferedWriter(new FileWriter(destFile));
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
            bufferedWriter.write(line);
            bufferedWriter.newLine();
        }
    } catch (IOException e) {
        throw new RuntimeException(e);
    } finally {
        if (bufferedReader != null) {
            bufferedReader.close();
        }
        if (bufferedWriter != null) {
            bufferedWriter.close();
        }
        System.out.println("拷贝结束");
    }
}
```



###### InputStreamReader

#### 输出流

##### OutputStream

- 构造方法

1. FileOutputStream(File file)：通过File表示写入数据的输出流
2. FileOutputStream(File file, Boolean append)：指定是否在后面添加
3. FileOutputStream(文件描述)
4. FileOutputStream(String name)
5. FileOutputStream(String name, Boolean append)

- 成员方法

1. close()：关闭输入流
2. finalize()：确保使用时不被调用close方法
3. getChannel()：返回与本文件有关的FileChannel对象
4. getFD()：返回FileDiscripter对象
5. write(int b)：写入b字节
6. write(byte[] b)：b子节点的数据读入byte数组
7. write(byte[] b, int off, int len)：写入len个字节数据到byte数组中

- 文件写入

```java
//字符/字符串方法写入
public void writeFile01() throws IOException {
    String filePath = "C:\\Users\\97359\\Desktop\\test1.txt";
    FileOutputStream fileOutputStream = null;
    String str = "Hello World !!!";    
    try {
        fileOutputStream = new FileOutputStream(filePath);
        //把字符串转为字符数组才可以直接使用
        //            fileOutputStream.write("Hello World !!!".getBytes(StandardCharsets.UTF_8));
        fileOutputStream.write('A');
        //fileOutputStream.write(str.getBytes(StandardCharsets.UTF_8), 0, str.getBytes().length);
    } catch (FileNotFoundException e) {
        throw new RuntimeException(e);
    } finally {
        assert fileOutputStream != null;
        fileOutputStream.close();
    }
}
```

- 文件拷贝：读取一部分就写入一部分

```java
public static void main(String[] args) throws IOException {
    String srcPath = "C:\\Users\\97359\\Desktop\\test.txt";
    String destPath = "C:\\Users\\97359\\Desktop\\test1.txt";
    byte[] buf = new byte[1024];
    int bufLen = 0;
    FileInputStream fileInputStream = null;
    FileOutputStream fileOutputStream = null;
    try {
        fileInputStream = new FileInputStream(srcPath);
        fileOutputStream = new FileOutputStream(destPath);
        while ((bufLen = fileInputStream.read(buf)) != -1) {
            fileOutputStream.write(buf, 0, bufLen);
        }
    } catch (FileNotFoundException e) {
        throw new RuntimeException(e);
    } finally {
        assert fileInputStream != null;
        fileInputStream.close();
        assert fileOutputStream != null;
        fileOutputStream.close();
    }
}
```



###### FileOutputStream

###### BufferedOutputStream：处理流/字节流

###### ObjectOutputStream：对象字节流/处理流

- 案例

```java
//使用ObjectinputStream序列化数据
public class ObjectOutStreamTest {
    public static void main(String[] args) throws IOException {
        String filePath = "C:\\Users\\97359\\Desktop\\data.dat";
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));
        oos.write(100);
        oos.writeBoolean(true);
        oos.writeChar('a');
        oos.writeUTF("光学成像");
        oos.writeObject(new Rabbit());
        oos.close();
    }
}
class Rabbit implements Serializable {

}
```





##### Writer：字符输出流

###### FileWriter

- 常用方法

1. new FileWriter(File/String)：覆盖模式，相当于流的指针在首端
2. new FileWriter(File/String, true)：追加模式，相当于流的指针在尾端
3. write(int)：写入单个字符
4. write(char)：写入指定数组
5. write(char[], off, len)：写入指定数组的指定部分
6. write (string)：写入整个字符串
7. write(string, off, len)：写入字符串的指定部分

相关APl:：

1. String类: toCharArray:将String转换成char[]

注意：

FileWriter使用后，必须要关闭(close)或刷新(flush)，否则写入不到指定的文件!(还在内存中)

- 文件写入

```java
public static void main(String[] args) throws IOException {
        String filePath = "C:\\Users\\97359\\Desktop\\testWrite.txt";
        FileWriter fileWriter = null;
        char[] chars = {'a', 'b', 'x'};
        try {
            fileWriter = new FileWriter(filePath);
//            fileWriter.write('H');//单个字符
//            fileWriter.write(chars);//字符数组
            fileWriter.write("你是谁？");//字符串
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            assert fileWriter != null;
//            fileWriter.flush();
            fileWriter.close();//close() = flush() + 文件关闭 -> 最底层调用writeBytes()方法才真正的写入文件-FileOutputStream
        }
    }
```



###### BufferedWriter：处理流/字节流

- 演示案例：见BufferedReader部分

###### OutputStreamWriter

#### 标准输入输出流

- 基本介绍

​												类型--默认设备
System.it标准输入--InputStream--键盘
System.out标准输出--PrintStream--显示器

- 说明

```java
public static void main(String[] args) {
        //System类的public final static InputStream in = null;
        //system.in 编译类型 InputStream
        //system.in运行类型 BufferedInputStream
        //表示的是标准输入 键盘
        System.out.println(System.in.getClass());
        // 1. System.out public final static PrintStream out = null;
        // 2．编译类型 PrintStream
        // 3．运行类型PrintStream
        // 4、表示标准输出显示器
        System.out.println(System.out.getClass());

    	Scanner scanner = new Scanner(System.in);//为什么System.in不用new？？？
        System.out.println("请输入内容");
        String next = scanner.next();
        System.out.println(next);
}
```

#### 转换流--InputStreamReader 和 OutputStreamWriter

##### 转换流的引出

- 基本说明

1. 字节流读取的时候可以选择字符的编码方式--防止乱码
2. 字符流读取默认是utf-8编码

- 案例

```java
public static void main(String[] args) throws IOException {
    //读取e:\la.txt文件到程序
    //思路
	//1.创建字符输入流BufferedReader[处理流]
    //2.使用 BufferedReader对象读取a.txt
	//3.默认情况下，读取文件是按照utf-8 编码
    String filePath = "C:\\Users\\ZYP\\Desktop\\test.txt";//把txt文件的编码方式改为ANSI(GBK编码)--直接读取会乱码
	BufferedReader br = new BufferedReader(new FileReader(filepath));
	String s = br.readLine();
	System.out.println("读取到的内容:" +s);
    br.close();
}
```

##### 转换流

- 基本介绍

1. InputStreamReader:Reader的子类，可以将InputStream(字节流)包装(或者叫转换)成Reader(字符流)
2. OutputStreamWriter:Writer的子类，实现将OutputStream(字节流)包装(转换)成Writer(字符流)
3. 当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题,所以建议将字节流转换成字符流
4. 可以在使用时指定编码格式(比如utf-8, gbk , gb2312, ISO8859-1等)

- 演示案例

```java
//InputStreamReader
public static void main(String[] args) throws IOException {
        String filePath = "C:\\Users\\ZYP\\Desktop\\test.txt";
        //解读
        // 1.把 FileInputStream转成InputStreamReader
        // 2.指定编码 gbk
        InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), "gbk");
        //3．把InputStreamReader传入 BufferedReader
        BufferedReader br = new BufferedReader(isr);
    
		//4.读取
        String s = br.readLine();
        System.out.println(s);
    	//5.关闭外层流
        br.close();
    }
```

```java
//OutputStreamWriter
public static void main(String[] args) throws IOException {
    String filePath = "C:\\Users\\ZYP\\Desktop\\test1.txt";
    String charSet = "utf-8";//gkb/utf8/utf-8
    OutputStreamWIriter osw = new OutputStreamWriter(new FileOutputStream(filePath), charSet);
    osw.write("hi，Java");
    osw.close();
    system.out.println("按照" +charSet + "保存文件成功~");
}
```

#### 打印流

- 说明

1. 打印流只有输出流
2. 可以打印到文件和输出设备上

- 案例

```java
//字符打印流PrintStream
import java.io.IOException;
import java.io.PrintStream;

public class SystemPrintOutTest {
    public static void main(String[] args) throws IOException {
        PrintStream out = System.out;
        //在默认情况下，PrintStream输出数据的位置是标准输出，即显示器
        /*
        public void print(String s){
            if (s == null){
                s = "null";
            }
            write(s);
        }
        */
        out.println("Hello Google");
        out.write("你好Java".getBytes());
        out.close();
        //我们可以去修改打印流输出的位置/设备
        // 1．输出修改成到"e:\\f1.txt"
        //2."hello，韩顺平教育~”就会输出到e:\f1.txt]
        System.setOut(new PrintStream( "C:\\Users\\ZYP\\Desktop\\test.txt"));
        System.out.println("hello，韩顺平教育~");

    }
}
```

```java
//字节打印流PrintStream
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class PrintWriterTest {
    public static void main(String[] args) throws IOException {
        String path = "C:\\Users\\ZYP\\Desktop\\test.txt";
        PrintWriter printWriter = new PrintWriter(new FileWriter(path));
        printWriter.println("打印一下");
        printWriter.close();//flush + 关闭流
    }
}

```

#### Properties类

- 基本需求

如下一个**配置文件**mysqI.properties

ip=192.168.0.13
user=root
pwd=12345
请问编程读取ip .user 和pwd的值是多少

传统方法读取和修改比较麻烦-->专门用于读写配置文件的Properties类

- 基本介绍

```java
import java.util.Properties
```

1. 专门用于读写配置文件的集合类

	配置文件的格式:
	键=值
	键=值

2. 注意:键值对**不需要有空格**,**值不需要用引号**一起来。默认类型是**String**
3. Properties的常见方法

```java
/*
load: 加载配置文件的键值对到Properties对象
list:将数据显示到指定设备
getProperty(key):根据键获取值
setProperty(key,value):设置键值对到Properties对象(不存在的适合就相当于添加)
store:将Properties中的键值对存储到配置文件,在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码
*/
```

- 案例

```java
//使用Properties类对mysql.properties读取
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

public class properties02 {
    public static void main(String[] args) throws IOException {
        String path = ".\\mysql.properties";
        //使用Properties类来读取mysql.properties 文件
        //1．创建Properties 对象
        Properties properties = new Properties();
        //2．加载指定配置文件
        properties.load(new FileReader(path));
        //3．把k-v显示控制台
        properties.list(System.out);
        //4．根据key 获取对应的值
        String user = properties.getProperty("user");
        String pwd = properties.getProperty("pwd");
        System.out.println("用户名=" +user);
        System.out.println("密码是=" +pwd);
    }
}
```

```JAVA
//修改配置文件
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

public class Properties03 {
    public static void main(String[] args) throws IOException {
        //使用Properties 类来创建配置文件，修改配置文件内容
        Properties properties = new Properties();
        //创建
        properties.setProperty("charset", "utf8");
        properties.setProperty("user", "汤姆");//注意保存时，是中文的 unicode码值
        properties.setProperty("pwd","abc111");//key存在就是修改
        //将k-v存储文件中即可
        properties.store(new FileOutputStream(".\\mysql.properties"), "注释内容");
        System.out.println("保存配置文件成功~");

    }
}
```

## b.课后作业

### 1.Map课堂练习

```java
//找到工资大于18000的人
Set entrySet = hashMap.entrySet();
system.out.println( "======迭代器======");
Iterator iterator = entrySet.iterator();
while (iterator.hasNext()){
	Map.Entry entry = (Map.Entry) iterator.next();//通过entry取得key和 value
	Emp emp = (Emp) entry.getValue();
    if(emp.getsal() > 18000){
	system.out.println(emp);
	}
}
```

### 2.集合的课后作业

1. 试分析HashSet和TreeSet分别如何实现去重的

   (1) HashSet的去重机制: hashCode() + equals() ,底层先通过存入对象,进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引所在的位置,没有数据，就直接存放如果有数据，就进行equals比较[遍历比较]，如果比较后，不相同就加入，否则就不加入

   (2) TreeSet的去重机制:如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果**方法返回0，就认为是相同的元素/数据**，就不添加，如果你没有传入一个Comparator匿名对象,则以你添加的对象实现的Compareable接口的compareTo去重.

2. TreeSet的默认构造器

```java
TreeSet treeSet = new TreeSet();
treeSet.add(new Person());
//TreeSet()使用默认构造器创建-添加时会使用存入对象的实现的Compareable接口中的compareTo()方法进行比较--若Person类没有实现Compareable接口则会报错
```

3.关于HashSet的添加和删除

```java
public class HashSetAddRemove {
    public static void main(String[] args) {
        HashSet set = new HashSet();//ok
        PersonX p1 = new PersonX(1001,"AA");//ok
        PersonX p2 = new PersonX(1002,"BB");
        set.add(p1);
        set.add(p2);
        p1.name ="CC";
        set.remove(p1);//原本的p1没有被移除--看源码--HashSet执行remove()方法时也会查找hash值
        System.out.println(set);//还有两个元素
        set.add(new PersonX(1001,"CC"));System.out.println(set);
        set.add(new PersonX(1001,"AA"));System.out.println(set);

    }
}
class PersonX {
    int id;
    String name;

    public PersonX(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PersonX personX = (PersonX) o;
        return id == personX.id && Objects.equals(name, personX.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
}
```

4.Vector和ArrayList的比较

### 3.泛型课后作业

1. 完成名字和生日年月日的比较

```java
//1.重写实现comparator接口的匿名内部类
list.sort(new Comparator<Employee>() {
    @Override
    public int compare(Employee o1, Employee o2) {
        if (o1 == null && o2 == null){
            return 0;
        }
        int nameIdx = o1.getName().compareTo(o2.getName());
        if (nameIdx != 0){
            return nameIdx;
        }
        return o1.getBirthday().compareTo(o2.getBirthday());
    }
});
//2.重写存储birthday的年月日的MyDate类的compareTo方法--在类的内部实现年月日的比较(MyDate需要实现Comparable接口)
public  class MyDate implement Comparable<MyDate>{
...
    @Override
    public int compareTo(MyDate o) {
        int yearMinus = year - o.year;
        if (yearMinus != 0) {
            return yearMinus;
        }
        int monthMinus = month - o.month;
        if (monthMinus != 0) {
            return monthMinus;
        }
        return day - o.day;
    }
}
```

2. 实例化有泛型的类不指定泛型类型则默认为Object，可以接收所有Object的子类

### 4.坦克大战大作业0.1

#### 4_1.Java绘图坐标体系

- 坐标的基本介绍

坐标原点位于左上角，(x,y)，x为横坐标，y为纵坐标

#### 4_2.Java绘图技术

```java
//JFrame生成一个窗口->画框
public class DrawCircle extends JFrame {
    public static void main(String[] args) {
        //定义一个面板
        new DrawCircle();
    }

    public DrawCircle() {
        MyPanel mp = new MyPanel();
        this.add(mp);
        this.setSize(400, 400);
        this.setVisible(true);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//关闭窗口时，关闭程序
    }
}

//1.先定义一个MyPanel，继承JPanel类，再面板上画图形
class MyPanel extends JPanel {
    //说明:
//1.MyPanel对象就是一个画板
//2.Graphics g 把g理解成一支画笔
//3.Graphics 提供了很多绘图的方法
    @Override
    public void paint(Graphics g) {//绘图方法
        super.paint(g);//调用父类的方法完成初始化·
        //int x, int y, int width, int height
        //x,y表示左上角的坐标
        g.drawOval(150, 150, 100, 100);
    }
}
```

- 绘图原理

Component类提供了两个和绘图相关最重要的方法:

1. paint(Graphics g)绘制组件的外观
2. repaint()刷新组件的外观。

当组件第一次在屏幕显示的时候,程序会自动的调用paint()方法来绘制组件。

在以下情况paint()将会被调用:

1. 窗口最小化再最大化
2. 窗口的大小发生变化
3. repaint()函数被调用

- Graphics类的常用方法
  - Graphics类可以理解为画笔,提供了各种绘制图形的方法:[参考JDK帮助文档]
  - 常用的方法

```java
//Graphics g
//1.画直线drawLine(int x1,int y1,int x2,int y2)
g.drawLine(150, 150, 100, 100);
//2画矩形边框drawRect(int x, int y, int width, int height)
g.drawRect(100, 100, 50, 50);
//3.画椭圆边框drawOval(int x, int y, int width, int height)
g.drawOval(150, 150, 100, 100);
//4.填充矩形 fillRect(int x, int y, int width, int height)
g.setColor(Color.black);
g.fillRect(0, 0, 100, 100);
//5.填充椭圆fillOval(int x, int y, int width, int height)
g.setColor(Color.yellow);
g.fillOval(250, 250, 100, 100);
//6.画图片drawlmage(lmage img, int x, int y, ..)
Image img = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource("/14054_A_Uformer.png"));//把图片文件放到out目录下的项目的根目录中
g.drawImage(img, 0, 0, 256, 256, this);
//7.画字符串drawString(String str, int x, int y)
g.setFont(new Font("行楷", Font.BOLD, 50));
g.drawString("你干什么", 0, 50);//字符串左下角的位置
//8.设置画笔的字体setFont(Font font)
g.setFont(new Font("宋体", Font.BOLD, 50));//设置字体-加粗-大小
//9.设置画笔的颜色setColor(Color c)
g.setColor(Color.blue);
```

- 坦克的绘制

```java
//面向对象思维->坦克有很多个种类->创建一个坦克父类
package com.TankGame;
/**
 * @version 1.0
 * @auther Meez
 */
public class Tank {
    private int x;
    private int y;
    public Tank(int x, int y){
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }
}
```

```java
//玩家的坦克
package com.TankGame;
public class Hero extends Tank {
    public Hero(int x, int y) {
        super(x, y);
    }
}
```

```java
//绘制面板
package com.TankGame;
import javax.swing.*;
import java.awt.*;
//游戏的绘图区
public class MyPanel extends JPanel {
    Hero hero = null;
    public MyPanel(){
        hero = new Hero(100, 100);//初始化位置
    }
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);
        //绘制坦克
        drawTank(hero.getX(), hero.getY(), g, 0, 1);
    }
    public void drawTank(int x, int y, Graphics g, int dir, int type){
        switch (type) {
            case 0: //玩家的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌方坦克
                g.setColor(Color.yellow);
                break;
        }
        switch (dir) {
            case 0://向上
                g.fill3DRect(x, y, 15, 50, false);
                g.fill3DRect(x + 35, y, 15, 50, false);
                g.fill3DRect(x + 15, y + 10, 20, 30, false);
//                g.setColor(Color.blue);
                g.fill3DRect(x + 23, y, 5, 20, false);
                g.fillOval(x + 15, x + 15, 20, 20);
                break;
            default:
                break;
        }
    }
}

```

```java
//游戏界面--窗口
package com.TankGame;

import javax.swing.*;

/**
 * @version 1.0
 * @auther Meez
 */
public class TankGame01 extends JFrame {
    MyPanel mp = null;

    public static void main(String[] args) {
        TankGame01 game = new TankGame01();
    }
    public TankGame01() {
        mp = new MyPanel();
        this.add(mp);
        this.setSize(1000, 750);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);
    }
}

```



#### 4_3.Java事件处理机制

- 基本说明

  java事件处理是采取"委派事件模型"(事件发生的地方和处理事件的地方是不同的对象)。当事件发生时，产生**事件的对象**，会把此"信息”传递给"事件的监听者”处理。这里所说的“信息"实际上就是java.awt.event事件类库里某个类所创建的对象，把它称为"事件的对象"。

- 深入理解事件处理机制

1. 事件源：事件源是一个产生事件的对象，比如按钮，窗口等。

2. 事件：事件就是承载事件源状态改变时的对象，比如当键盘事件、鼠标事件、窗口事件等等，会生成一个事件对象，该对象保存着当前事件很多信息，比如KeyEvent对象有含义被按下键的Code值。java.awt.event包和javax.swing.event包中定义了各种事件类型。

3. 事件类型：查看JDK文档

   ActionEvent：通常在按下按钮,或双击一个列表项或选中某个菜单时发生,
   AdjustmentEvente：当操作一个滚动条时发生。
   ComponentEvent：当一个组件隐藏，移动，改变大小时发送。
   ContainerEvent：当一个组件从容器中加入或者删除时发生,
   FocusEvent：当一个组件获得或是失去焦点时发生。
   ltemEvent：当一个复选框或是列表项被选中时，当一个选择框或选择菜单被选中。
   KeyEvent：当从键盘的按键祓按下，松开时发生。
   MouseEvent：当鼠标被拖动，移动，点击，按下..o
   TextEvent：当文本区和文本域的文本发生改变时发生。
   WindowEvent：当一个窗口激活，关闭，失效，恢复，最小化..

4. 事件监听器接口

   (1) 当事件源产生一个事件，可以将事件传送给事件监听者处理
   (2) 事件监听者实际上是一个类，该类实现了某个事件监听器接口。比如前面我们案例中的MyPanle就是一个类，它实现了KeyListener接口，它就可以作为一个事件监听者，对接受到的事件进行处理
   (3)事件监听器接口有多种，不同的事件监听器接口可以监听不同的事件,一个类可以实现多个监听接口。
   (4)这些接口在**java.awt.event包**和**javax.swing.event**包中定义。查看JDK文档。

- 小球的上下移动

```java
//让小球的画板实现keyListener接口--实现该接口的三个方法
package com.TankGame.event;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class BallMove extends JFrame{
    MyPanel mp;
    public static void main(String[] args) {
        BallMove ball = new BallMove();
    }
    public BallMove(){
        mp = new MyPanel();
        this.add(mp);
        this.setSize(400, 300);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //给窗口添加键盘事件的监听器
        this.addKeyListener(mp);//addKeyListener()需要实现KeyListener的对象
        this.setVisible(true);
    }
}
class MyPanel extends JPanel implements KeyListener {
    int x = 10, y = 10;
    @Override
    public void paint(Graphics g){
        super.paint(g);

        g.fillOval(x, y, 20, 20);//默认位置默认黑色
    }
    //有字符输出就触发
    @Override
    public void keyTyped(KeyEvent e) {

    }

    //某个键被按下时触发
    @Override
    public void keyPressed(KeyEvent e) {
        //KeyEvent.VK_DOWN方向键向下对应的键盘编码
        if (e.getKeyCode() == KeyEvent.VK_DOWN) {
            y++;
        }
        if (e.getKeyCode() == KeyEvent.VK_UP) {
            y--;
        }
        if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            x++;
        }
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            x--;
        }
        this.repaint();
    }
    //某个键被释放时触发
    @Override
    public void keyReleased(KeyEvent e) {
        System.out.println((char)e.getKeyCode() + "键被释放");
    }
}
```

- 让坦克动起来

```java
//所有程序查看TankGame02
package com.TankGame02;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

/**
 * @version 1.0
 * @auther Meez
 */
//游戏的绘图区
public class MyPanel extends JPanel implements KeyListener {
    Hero hero = null;
    public MyPanel(){
        hero = new Hero(100, 100, 2);//初始化位置
    }
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.fillRect(0, 0, 1000, 750);
        //绘制坦克
        drawTank(hero.getX(), hero.getY(), g, hero.getDir(), 0);
    }
    public void drawTank(int x, int y, Graphics g, int dir, int type){
        switch (type) {
            case 0: //玩家的坦克
                g.setColor(Color.cyan);
                break;
            case 1://敌方坦克
                g.setColor(Color.yellow);
                break;
        }
        switch (dir) {
            case 0://向上
                g.fill3DRect(x, y, 15, 50, false);
                g.fill3DRect(x + 35, y, 15, 50, false);
                g.fill3DRect(x + 15, y + 10, 20, 30, false);
                g.fill3DRect(x + 23, y, 5, 20, false);
                g.fillOval(x + 15, y + 15, 20, 20);
                break;
            case 1://向右
                g.fill3DRect(x, y, 50, 15, false);
                g.fill3DRect(x, y + 35, 50, 15, false);
                g.fill3DRect(x + 10, y + 15, 30, 20, false);
                g.fill3DRect(x + 30, y + 23, 20, 5, false);
                g.fillOval(x + 15, y + 15, 20, 20);
                break;
            case 2://向左
                g.fill3DRect(x, y, 50, 15, false);
                g.fill3DRect(x, y + 35, 50, 15, false);
                g.fill3DRect(x + 10, y + 15, 30, 20, false);
                g.fill3DRect(x, y + 23, 20, 5, false);
                g.fillOval(x + 15, y + 15, 20, 20);
                break;
            case 3://向左
                g.fill3DRect(x, y, 15, 50, false);
                g.fill3DRect(x + 35, y, 15, 50, false);
                g.fill3DRect(x + 15, y + 10, 20, 30, false);
                g.fill3DRect(x + 23, y + 30, 5, 20, false);
                g.fillOval(x + 15, y + 15, 20, 20);
                break;
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_W) {//向上
            hero.setDir(0);
            hero.moveUP();
        } else if (e.getKeyCode() == KeyEvent.VK_D){//向右
            hero.setDir(1);
            hero.moveRight();
        } else if (e.getKeyCode() == KeyEvent.VK_A){//向左
            hero.setDir(2);
            hero.moveULeft();
        } else if (e.getKeyCode() == KeyEvent.VK_S){
            hero.setDir(3);
            hero.moveDown();
        }
        this.repaint();

    }

    @Override
    public void keyReleased(KeyEvent e) {

    }
}
```

- 绘制敌人的坦克

```java
//后续要多线程处理--使用Vector数组存储敌人的坦克
```



### 5.坦克大战大作业0.2

#### 5_1坦克子弹发射

- 思路分析

1. 当发射一颗子弹后，就相当于启动一个线程。
2. Hero有子弹的对象，当按下J时，我们就启动一个发射行为(线程)，让子弹不停的移动，形成一个射击的效果
3. 我们MyPanel需要不停的重绘子弹，才能出现该效果，模拟子弹移动的效果。
4. 当子弹移动到面板的边界/敌方坦克时，就应该销毁(线程销毁)。

### 6.坦克大战大作业0.3

- 增加功能

1. 让敌人的坦克也能够发射子弹(可以有多颗子弹)
   - 在敌人坦克类，使用Vector保存多个Shot
   - 当每创建一个敌人坦克对象，给该敌人坦克对象初始化一个Shot对象，同时启动Shot
   - 在绘制敌人坦克时，需要变量敌人坦克对象Vector,绘制所有的子弹,当子弹isLive == false时，就从Vector移除
2. 当我方坦克击中敌人坦克时，敌人的坦克就消失,如果能做出爆炸效果更好.
3. 让敌人的坦克也可以自由随机的上下左右移动
4. 控制我方的坦克和敌人的坦克在规定的范围移动

```java
//增强for循环里面删除元素会抛出
//Exception in thread "AWT-EventQueue-0" java.util.ConcurrentModificationException
for (Bomb bomb: bombs){
    if (bomb.lift > 6) {
        g.drawImage(boomImg, bomb.x, bomb.y, 50, 50, this);
    } else if (bomb.lift > 3) {
        g.drawImage(boomImg, bomb.x+12, bomb.y+12, 25, 25, this);
    } else {
        g.drawImage(boomImg, bomb.x+20, bomb.y+20, 10, 10, this);
    }
    bomb.lifeDown();
    if (bomb.lift <= 0) {
        bombs.remove(bomb);
    }
}
```

```java
//写并发程序必须考虑什么时候退出线程
```

### 7.坦克大战大作业0.4

- 增加功能1.0

1. 我方坦克在发射的子弹消亡后，才能发射新的子弹 -> 扩展(发多颗子弹怎么办)
2. 让敌人坦克发射的子弹消亡后，可以再发射子弹.
3. 当敌人的坦克击中我方坦克时，我方坦克消失，并出现爆炸效果.

- 增加功能2.0

1. 我方坦克在发射的子弹消亡后，才能发射新的子弹.=>扩展(发多颗子弹怎么办,控制在我们的面板上，最多只有5颗)-》在课后完善.…
2. 让敌人坦克发射的子弹消亡后，可以再发射子弹.
3. 当敌人的坦克击中我方坦克时，我方坦克消失，并出现爆炸效果.

###  IO流作业

```java
//IO作业1
/*
(1)在判断e盘下是否有文件夹mytemp,如果没有就创建mytemp
(2)在e:lImytemp目录下，创建文件 hello.txt
(3)如果hello.txt已经存在，提示该文件已经存在，就不要再重复创建了
(4)并且在hello.txt文件中，写hello,world~
*/
package IOHomework;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class Homework01 {
    public static void main(String[] args) throws IOException {
        String filePath = "./mytemp";
        File file = new File(filePath);
        if (!file.exists()) {
            if (file.mkdirs()) {
                System.out.println("创建" + filePath + "创建成功");
            } else {
                System.out.println("创建" + filePath + "创建失败");
            }
        }
        String filePathText = filePath + "/hello.txt";
        file = new File(filePathText);
        if (!file.exists()) {
            if (file.createNewFile()) {
                System.out.println(filePathText + "创建成功");
                BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePathText));
                bufferedWriter.write("Hello World!!");
                bufferedWriter.close();
            } else {
                System.out.println(filePathText + "创建失败");
            }
        } else {
            System.out.println(filePathText + "已经存在");
            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePathText));
            bufferedWriter.write("Hello World!!");
            bufferedWriter.close();
        }
    }
}
```

```java
//IO作业2
/*
要求:使用βufferedReader读取一个文本文件，为每行加上行号，再连同内容一并输出到屏幕上。
*/
package IOHomework;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Homework02 {
    public static void main(String[] args) throws IOException {
        String filePath = "C:\\Users\\ZYP\\Desktop/test.txt";
        BufferedReader br = null;
        String lineCont = "";
        int lineNum = 0;
        try {
            br = new BufferedReader(new FileReader(filePath));
            while ((lineCont = br.readLine()) != null) {
                System.out.println("(" + ++lineNum + "): " + lineCont);
            }
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } finally {
            assert br != null;
            br.close();
        }
    }
}
//进阶思考：如果文本的编码格式为gbk编码怎么处理
//提示：使用转换流 -> 自己尝试一下怎么写！！！！！！！！
```

```java
//IO作业3
/*
(1)要编写一个dog.properties
name=tom
age=5
color=red
(2)编写Dog类(name,age,color)创建一个dog对象，读取dog.properties用相应的内容完成属性初始化.并输出
(3)将创建的Dog对象，序列化到文件dog.dat文件
*/
import java.io.*;
import java.util.Properties;

public class Homework03 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        String path = "./dog.properties";
        Properties properties = new Properties();
        properties.load(new FileReader(path));
        String name = properties.get("name") + "";
        int age = Integer.parseInt(properties.get("age") + "");
        String color = properties.get("color") + "";
        Dog dog = new Dog(name, age, color);
        System.out.println(dog);
        //序列化
        String serFilePath = "./dog.dat";
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(serFilePath));
        objectOutputStream.writeObject(dog);
        //反序列化
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(serFilePath));
        Dog oldDog = (Dog)ois.readObject();
        System.out.println(oldDog);

    }
}
class Dog implements Serializable {
    private String name;
    private int age;
    private String color;

    public Dog(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }
}
```

### 8.坦克大战大作业0.5

```java
//新增功能
/*
1．防止敌人坦克重叠运动
2.记录玩家的成绩,存盘退出
3．记录当时的敌人坦克坐标存盘退出
4.玩游战时，可以选择是开新游戏还是继续上局游戏
*/
```

### 9.坦克大战大作业0.6

```java
//新增功能
/*
1.游戏开始时，播放经典的坦克大战音乐，[思路,使用一个播放音乐的类，即可]
2.修正下文件存储位等----文件最好跟项目存储在同一个地方src/..
3.处理文件相关异常----储存之前游戏信息的文件不存在
*/
```

# 第三阶段

## 网络编程

### 网络编程的相关概念

#### IP地址

- 基本概念

1. 概念:用于唯一标识网络中的每台计算机
2. 查看ip地址: ipconfig(cmd中输入指令)
3. ip地址的表示形式:点分十进制XX.XX.XX.XX，4个字节表示
4. 每一个十进制数的范围:0~255
5. ip地址的组成=网络地址+主机地址，比如:192.168.16.696. 
6. iPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议,其地址数量号称可以为全世界的每一粒沙子编上一个地址。128位表示地址，可以用冒分16进制表示。
7. 由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题,而且也解决了多种接入设备连入互联网的障碍

- IPV4的地址分类

可以通过IP地址的范围区分类型

1. A类
2. B类
3. C类
4. D类
5. E类
6. 本机：１２７.０.０.１

#### 域名

- 基本概念

1. www.baidu.com
2. 好处:为了方便记忆，解决记ip的困难
3. 概念:将ip地址映射成域名

#### 端口号

- 基本概念

1. 概念:用于标识计算机上某个特定的网络程序
2. 表示形式:以整数形式,范围0~65535(16位整数)
3. **0~1024**已经被占用(尽量不使用这些端口),比如ssh 22, ftp 21, smtp 25 http 80
4. 常见的网络程序端口号:
   tomcat :8080
   mysql:3306
   oracle:1521 
   sqlserver:1433

#### 网络协议

- 基本概念

1. 数据在网络编程中的组织形式就是协议
2. TCP/IP (Transmission Control Protocol/Internet Protocol)的简写,中文译名为传输控制协议/因特网互联协议，又叫网络通讯协议,这个协议是Internet最基本的协议、Internet国际互联网络的基础,简单地说，就是由网络层的IP协议和传输层的TCP协议组成的。
3. TCP/IP模型

- TCP协议(传输控制协议)

1. 使用TCP协议前，须先建立TCP连接，形成传输数据通道
2. 传输前，采用**"三次握手"**方式，是**可靠**的
3. TCP协议进行通信的两个应用进程:客户端、服务端
4. 在连接中可进行大数据量的传输
5. 传输完毕,**需释放**已建立的**连接**，**效率低**

- UDP协议(用户数据协议)

1. 将数据、源、目胸封装成数据包，不需要建立连接
2. 每个数据报的大小限制在64K内，**不适合**传输**大量数据**
3. 因无需连接，故是不可靠的
4. 发送数据结束时无需释放资源(因为不是面向连接的)，**速度快**
5. 举例:厕所通知:发短信

- 网络通信

1.概念:两台设备之间通过网络实现数据传输
2.网络通信:将数据通过网络从一台设备传输到另一台设备
3.java.net包下提供了一系列的类或接口,供程序员使用,完成网络通信

- 网络

1. 概念:两台或多台设备通过一定物
   理设备连接起来构成了网络
2. 根据网络的覆盖范围不同，对网络
   进行分类:
   局域网:覆盖范围最小,仅仅覆盖一个教室或一个机房
   城域网:覆盖范围较大，可以覆盖一个城市
   广域网:覆盖范围最大，可以覆盖全国，甚至全球,万维网是广域网的代表

### InetAddress类

- 相关方法

1. 获取本机lInetAddrEss对象getLocalHost
2. 根据指定主机名/域名获取ip地址对象getByNlame
3. 获取InetAddress对象的主机名getHostName
4. 获取InetAddress对象的地址getHostAddress

### Socket

- 基本介绍

1. 套接字(Socket)开发网络应用程序被广泛采用，以至于成为事实上的标准。
2. 通信的两端都要有Socket，是两台机器间通信的端点
3. 网络通信其实就是Socket间的通信。
4. Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。
5. 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端

```java
//socket读写数据(通信)
socket.getOutputStream();
socket.getInputStream();
```

TCP网络通信编程

- 基本介绍

1. 基于客户端—服务端的网络通信
2. 底层使用的是TCP/IP协议
3. 应用场景举例:客户端发送数据，服务端接受并显示控制台
4. 基于Socket的TCP编程

- TCP网络通讯不为人知的秘密

1. 当客户端连接到服务端后，实际上**客户端**也是通过一个端口和服务端进行通讯的，这个端口是**TCP/IP来分配的**,是不确定的，是随机的.

2. 示意图

3. 程序验证

   使用程序+netstat进行验证

- 应用案例1

1. 编写一个服务器端,和一个客户端
2. 服务器端在9999端口监听
3. 客户端连接到服务器端，发送"hello, server"，然后退出
4. 服务器端接收到客户端发送的信息，输出，并退出

```java
//服务器端
package chapter21;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class SocketServerTest {
    public static void main(String[] args) throws IOException {
    //思路
    //1。在本机的9999端口监听，等待连接
    //细节:要求在本机没有其它服务在监听9999
        ServerSocket serverSocket = new ServerSocket(9999);//ServerSocket可以返回多个Socket对象
    //2．当没有客户端连接9999端口时，程序会阻塞，等待连接
    //  如果有客户端连接，则会返回Socket对象，程序继续
        Socket socket = serverSocket.accept();
        System.out.println("客户端 socket =" + socket.getClass());
    //3．通过socket.getInputStream(） 读取客户端写入到数据通道的数据，显示
        InputStream inputStream = socket.getInputStream();
    //4.IO读取
        byte[] buf = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buf)) != -1) {
            System.out.println(new String(buf, 0, readLen));//根据读取到的实际长度，显示内容
        }
    //5.关闭流和socketinputStream.close();
        inputStream.close();
    }
}

```

```java
//客户端
package chapter21;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class SocketClientTest {
    public static void main(String[] args) throws IOException {
        //思路
        //1．连接服务端(ip ，端口)，如果连接成功，返回Socket对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端 socket =" + socket.getClass());
        //2.连接上后，生成Socket，通过socket.getOutputStream()
        // 得到和socket对象关联的输出流对象
        OutputStream outputStream = socket.getOutputStream();
        //3．通过输出流，写入数据到数据通道
        outputStream.write("hello,server ".getBytes());
        //4。关闭流对象和socket，必须关闭
        outputStream.close();
        socket.close();
        System.out.println("客户端关闭");
    }
}
```

- 应用案例2

1. 编写一个服务端和一个客户端
2. 服务器端在9999端口监听
3. 客户端连接到服务器端,发送"hello, server"，并接收服务器端回发的"hello,client"，再退出
4. 服务器端接收到客户端发送的信息，输出，并发送"hello, client"，再退出

```java
//来往的通信信息都需要添加结束标记
//结束标记
socket.shutownOutput();
socket.shutdownInput();
```

```java
//服务器端
package chapter21;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class SocketServerTest {
    public static void main(String[] args) throws IOException {
    //思路
    //1。在本机的9999端口监听，等待连接
    //细节:要求在本机没有其它服务在监听9999
        ServerSocket serverSocket = new ServerSocket(9999);//ServerSocket可以返回多个Socket对象
    //2．当没有客户端连接9999端口时，程序会阻塞，等待连接
    //  如果有客户端连接，则会返回Socket对象，程序继续
        Socket socket = serverSocket.accept();
        System.out.println("客户端 socket =" + socket.getClass());
    //3．通过socket.getInputStream(） 读取客户端写入到数据通道的数据，显示
        InputStream inputStream = socket.getInputStream();
    //4.IO读取
        byte[] buf = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buf)) != -1) {
            System.out.println(new String(buf, 0, readLen));//根据读取到的实际长度，显示内容
        }
    //结束标记
        socket.getInputStream();
    //5.获取socket相关联的输出流
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write("hello client".getBytes());
    //6.关闭流和socketinputStream.close();
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}
```

```java
//客户端
package chapter21;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class SocketClientTest {
    public static void main(String[] args) throws IOException {
        //思路
        //1．连接服务端(ip ，端口)，如果连接成功，返回Socket对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端 socket =" + socket.getClass());
        //2.连接上后，生成Socket，通过socket.getOutputStream()
        // 得到和socket对象关联的输出流对象
        OutputStream outputStream = socket.getOutputStream();
        //3．通过输出流，写入数据到数据通道
        outputStream.write("hello,server ".getBytes());
        //设置结束标记
        socket.shutdownOutput();
        //4.获取和socket关联的输入流。读取数据(字节)，并显示
        InputStream inputStream = socket.getInputStream();
        byte[] buf = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buf)) != -1) {
            System.out.println(new String(buf, 0, readLen));
        }
        //5.关闭流对象和socket，必须关闭
        inputStream.close();
        outputStream.close();
        socket.close();
        System.out.println("客户端关闭");


    }
}
```

- 应用案例3

1. 编写一个服务端，和一个客户端
2. 服务端在9999端口监听
3. 客户端连接到服务端，发送"hello, server”,并接收服务端回发的"hello,client",再退出
4. 服务端接收到客户端发送的信息，输出，并发送"hello, client",再退出

```java
//客户端->把子节流用转换流转换为字符流
package chapter21;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class SocketClientTest {
    public static void main(String[] args) throws IOException {
        //思路
        //1．连接服务端(ip ，端口)，如果连接成功，返回Socket对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端 socket =" + socket.getClass());
        //2.连接上后，生成Socket，通过socket.getOutputStream()
        // 得到和socket对象关联的输出流对象
        OutputStream outputStream = socket.getOutputStream();
        //3．通过输出流，写入数据到数据通道，使用字符流
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write("hello, server 字符流");
        bufferedWriter.newLine();//插入一个换行符，表示写入的内容结束，注意，要求对方使用readLine() !!!!
        bufferedWriter.flush();//如果使用的字符流，需要手动刷新，否则数据不会写入数据通道
        //设置结束标记
        socket.shutdownOutput();
        //4.获取和socket关联的输入流。读取数据(字节)，并显示
        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String str = bufferedReader.readLine();
        System.out.println(str);
        //5.关闭流对象和socket，必须关闭--关闭外层流
        bufferedReader.close();
        bufferedWriter.close();
        socket.close();
        System.out.println("客户端关闭");
    }
}

```

```java
//服务端
package chapter21;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class SocketServerTest {
    public static void main(String[] args) throws IOException {
    //思路
    //1。在本机的9999端口监听，等待连接
    //细节:要求在本机没有其它服务在监听9999
        ServerSocket serverSocket = new ServerSocket(9999);//ServerSocket可以返回多个Socket对象
    //2．当没有客户端连接9999端口时，程序会阻塞，等待连接
    //  如果有客户端连接，则会返回Socket对象，程序继续
        Socket socket = serverSocket.accept();
        System.out.println("服务端 socket =" + socket.getClass());
    //3．通过socket.getInputStream(） 读取客户端写入到数据通道的数据，显示
        InputStream inputStream = socket.getInputStream();
    //4.IO读取,使用转换流将字节流转换为字符流
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String str = bufferedReader.readLine();
        System.out.println(str);
    //结束标记
        socket.getInputStream();
    //5.获取socket相关联的输出流
        OutputStream outputStream = socket.getOutputStream();
    //字符流回复
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write("hello client 字符流");
        bufferedWriter.newLine();
        bufferedWriter.flush();

    //6.关闭流和socketinputStream.close();
        bufferedWriter.close();
        bufferedReader.close();
        socket.close();
        serverSocket.close();
        System.out.println("服务端关闭");
    }
}
```

- 应用案例4

1. 编写一个服务端,和一个客户端
2. 服务器端在8888端口监听
3. 客户端连接到服务端,发送一张图片e:llqie.png
4. 服务器端接收到客户端发送的图片，保存到src下,发送"收到图片”再退出
5. 客户端接收到服务端发送的“收到图片”，再退出
6. 该程序要求使用 StreamUtils.java

```java
//客户端
package chapter21;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class FileUploadClient {
    public static void main(String[] args) throws Exception {
        //客户端连接服务端8888，得到Socket对象
        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);
        //创建读取磁盘文件的输入流
        String filePath = "C:\\Users\\97359\\Desktop\\14.jpg";
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));
        // bytes就是filePath对应的字节数组
        byte[] bytes = streamToByteArray(bis);
        //通过socket获取到输出流,将bytes数据发送给服务端
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(socket.getOutputStream());
        bufferedOutputStream.write(bytes);
        bis.close();
        socket.shutdownOutput();//一定要有结束标记--否则客户端一直等待数据

        // 回复接受的消息
        InputStream inputStream = socket.getInputStream();
        String str = streamToString(inputStream);
        System.out.println(str);

        inputStream.close();
        bufferedOutputStream.close();
        socket.close();

    }

    public static byte[] streamToByteArray(InputStream is) throws Exception {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象
        byte[] b = new byte[1024];//字节数组
        int len;
        while ((len = is.read(b)) != -1) {//循环读取
            bos.write(b, 0, len);//把读取到的数据,写入bos
        }
        return bos.toByteArray();
    }

    public static String streamToString(InputStream is) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        StringBuilder builder = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line).append("\r\n");
        }
        return builder.toString();
    }

}
```

```java
//服务端
package chapter21;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @version 1.0
 * @auther Meez
 */
public class FileUploadServer {
    public static void main(String[] args) throws Exception {
        //1.服务端在本机监听8888端口
        ServerSocket serverSocket = new ServerSocket(8888);
        System.out.println("服务端正在8888端口监听...");
        //2.等待连接
        Socket socket = serverSocket.accept();
        //3.读取客户端发送的数据
        //通过Socket得到输入流
        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        byte[] bytes = streamToByteArray(bis);
        //4.将得到 bytes数组，写入到指定的路径，就得到一个文件了
        String destFilePath = "./test.png";
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath));
        bos.write(bytes);


        //向客户端回复"收到图片"
        //通过socket获取到输出流(字符)
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
        bufferedWriter.write("已收到图片");
        bufferedWriter.flush();
        socket.shutdownOutput();

        //关闭所有资源
        bos.close();
        bis.close();
        socket.close();
        serverSocket.close();
        bufferedWriter.close();

    }
    public static byte[] streamToByteArray(InputStream is) throws Exception {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象
        byte[] b = new byte[1024];//字节数组
        int len;
        while ((len = is.read(b)) != -1) {//循环读取
            bos.write(b, 0, len);//把读取到的数据,写入bos
        }
        return bos.toByteArray();
    }
}
```

### netstat指令

1. netstat -an可以查看当前主机网络情况，包括**端口监听**情况和**网络连接**情况
2.  netstat -an | more可以分页显示
3. 要求在dos控制台下执行win+r

- 说明：

1.  Listening表示某个端口在监听
2.  如果有一个外部程序(客户端)连接到该端口,就会显示一条连接信息.
3.  crtl + c 退出指令
4.  netstat -anb 管理员身份

UDP网络通信编程(了解)

- 基本介绍

1. 类 DatagramSocket和 DatagramPacket(数据包/数据报)实现了基于UDP 协议网络程序。
2. UDP数据报通过**数据报套接字DatagramSocket**发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。

3. DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和
端口号以及接收端的IP地址和端口号。
3. UDP协议中每个数据报都给出了完整的地址信息，因此**无须建立**发送方和接收方
的**连接**

- 说明

1. 没有明确的服务端和客户端,演变成数据的**发送端和接收端**。(可以互相转换)
2. 接收数据和发送数据是通过 DatagramSocket 对象完成
3. 将数据封装到DatagramPacket 对象/装包
4. 当接收到 DatagramPacket 对象,需要进行拆包，取出数据
5. DatagramSocket可以**指定**在哪个**端口**接收数据

- 基本流程

1. 核心的两个类/对象DatagramSocket与DatagramPacket
2. 建立发送端，接收端(没有服务端和客户端概念)
3. 发送数据前，建立数据包/报 DatagramPacket对象
4. 调用DatagramSocket的发送、接收方法
5. 关闭DatagramSocket

- 应用案例

```java
//端口A
package InterneComChapter;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPReceiverA {
    public static void main(String[] args) throws IOException {
        //1.创建一个DatagramSocket对象,准备在8888接收数据
        DatagramSocket datagramSocket = new DatagramSocket(8888);
        //2.构建一个DatagramPacket 对象,准备接收数据
        //在前面讲解UDP协议时，一个数据包最大64k
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);
        //3.调用接收方法,将通过网络传输的 DatagramPacket对象
        //填充到 packet对象
        //提示：当有数据包发送到本机的8888端口时，就会接收到数据
        //如果没有数据包发送到本机的8888端口，就会阻塞等待.
        System.out.println("接收端A 等待接收数据...");
        datagramSocket.receive(packet);
        System.out.println("接收端A 数据接收完毕！");
        //4.可以把packet 进行拆包,取出数据，并显示。
        int length = packet.getLength();//实际接收的数据长度
        byte[] data = packet.getData();//接收到的数据
        String str = new String(data, 0, length);
        System.out.println(str);
        //===回复信息给B端
        //将需要发送的数据，封装到DatagramPacket对象
        data = "好的，明天见".getBytes();
        packet = new DatagramPacket(data, data.length, InetAddress.getLocalHost(), 9999);
        datagramSocket.send(packet);
        datagramSocket.close();
        System.out.println("A端 退出");
    }
}
```

```java
//端口B
package InterneComChapter;

import java.io.IOException;
import java.net.*;

public class UDPSenderB {
    public static void main(String[] args) throws IOException {
        //创建DatagramSocket对象,准备在9998端口接收数据
        DatagramSocket socket = new DatagramSocket(9999);//设置接收数据的端口
        //2.将需要发送的数据，封装到 DatagramPacket对象
        byte[] data = "hello 明天吃火锅".getBytes();
        //说明:封装的 DatagramPacket对象 data内容字节数组，data.length ，主机(IP)，发送的端口
//        DatagramPacket packet =
//                new DatagramPacket(data, data.length, InetAddress.getByName("192.168.31.102"), 8888);
        DatagramPacket packet =
                new DatagramPacket(data, data.length, InetAddress.getLocalHost(), 8888);
        socket.send(packet);
        //3.接收信息
        byte[] buf = new byte[1024];
        DatagramPacket packetGet = new DatagramPacket(buf, buf.length);
        System.out.println("接收端B 等待接收数据...");
        socket.receive(packetGet);
        System.out.println("接收端B 数据接收完毕！");
        //4.可以把packet 进行拆包,取出数据，并显示。
        int length = packetGet.getLength();//实际接收的数据长度
        data = packetGet.getData();//接收到的数据
        String str = new String(data, 0, length);
        System.out.println(str);
        //关闭资源
        socket.close();
        System.out.println("B端退出");
    }
}
```

## 反射

### 反射机制***

- 反射的引出

1. 根据配置文件 re.properties 指定信息,创建Cat对象并调用方法hi

```java
//配置文件
//re.properties
classFullPath=CatX
method=hi //可以不修改源码调用不同的方法--修改配置文件即可
```

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class ReflectionTest {
    public static void main(String[] args) throws IOException {
        //1.使用Properties 类，可以读写配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\lre.properties"));
        String classFullPath = properties.get("classfullpath").toString();
        String method = properties.get("method").toString();
        System.out.println("classfullpath = " + classFullPath );
        System.out.println( "method=" + method);
        //2.创建对象
        //new classFullPath 中classFullPath不是类名--无法完成
    }
}
```

```java
//CatX类
public class CatX {
    public void hi() {
        System.out.println("Hi!Miao!Miao!");
    }
    public void cry() {
        System.out.println("wuwuwu!");
    }
}
```

2. 这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码情况下，来控制程序。这种需求符合设计模式的ocp原则(开闭原则：不修改源码扩展功能)
3. 使用反射机制解决以上问题

优势：可以不修改源码调用不同的方法--修改配置文件即可

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

public class ReflectionTest {
    public static void main(String[] args)
            throws IOException, ClassNotFoundException, InstantiationException,
            IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        //1.使用Properties 类，可以读写配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\re.properties"));
        String classFullPath = properties.get("classFullPath").toString();
        String method = properties.get("method").toString();
        System.out.println("classfullpath = " + classFullPath );
        System.out.println( "method=" + method);
        //2.创建对象
        //new classFullPath 中classFullPath不是类名--无法完成

        //3.使用反射机制解决这个问题
        //(1) 加载类,返回Class类型的对象cls
        Class<?> cls = Class.forName(classFullPath);
        //(2)通过cls得到你加载的类 com.hspedu.Cat的对象实例
        Object o = cls.newInstance();
        System.out.println(o.getClass());
        //(3）通过cls 得到你加载的类com. hspedu.Cat的 methodName"hi"的方法对象
        // 即:在反射中，可以把方法视为对象（万物皆对象)
        Method method1 = cls.getMethod(method);
        //(4）通过method1 调用方法:即通过方法对象来实现调用方法
        method1.invoke(o);//传统方法对象.方法(，反射机制方法.invoke(对象)
    }
}
```

- 反射机制

1. 反射机制允许程序在执行期借助于**Reflection API**取得任何**类的内部信息**(比如成员变量，构造器，成员方法等等)并能操作对象的属性及方法。反射在设计模式和框架底层都会用到。
2. 加载完类之后，在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为:反射。

<img src=".\Java入门markdown图片\Java的反射机制1.png" alt="Java的反射机制1" style="zoom:50%;" />

- 反射相关的主要类 java.lang.reflection

1. java.lang.Class:代表一个类，Class对象表示**某个类**加载后在堆中的**对象**
2.  java.lang.reflect.Method:代表类的方法, Method对象表示某个**类的方法**
3.  java.lang.reflect.Field:代表类的成员变量, Field对象表示某个类的**成员变量**
4. java.lang.reflect.Constructor:代表类的构造方法,Constructor对象表示**构造器**

```java
//getField获取public的属性
//使用反射机制解决这个问题
//(1) 加载类,返回Class类型的对象cls
Class<?> cls = Class.forName(classFullPath);
//(2)通过cls得到你加载的类 com.hspedu.Cat的对象实例
Object o = cls.newInstance();
System.out.println(o.getClass());
//(3）通过cls 得到你加载的类com. hspedu.Cat的 methodName"hi"的方法对象
// 即:在反射中，可以把方法视为对象（万物皆对象)
Method method1 = cls.getMethod(method);
//(4）通过method1 调用方法:即通过方法对象来实现调用方法
method1.invoke(o);//传统方法对象.方法(，反射机制方法.invoke(对象)
//(5)得到name字段
Field nameField = cls.getField("name");
System.out.println(nameField.get(o));
//(6)获得类的构造器
Constructor constructor = cls.getConstructor();
System.out.println(constructor);
Constructor constructor1 = cls.getConstructor(String.class);
System.out.println(constructor1);
```

- 反射机制的优缺点--反射调用性能优化

1. 优点:可以动态的创建和使用对象(也是框架底层核心),使用灵活，没有反射机制，框架技术就失去底层支撑。
2. 缺点:使用反射基本是解释执行，对执行速度有影响。

```java
//运行速度测试
package ReflectionTest;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @version 1.0
 * @auther Meez
 */
public class ReflectionSpeedTest {
    public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException {
        m1();
        m2();
    }
    public static void m1() {
        CatX catX = new CatX();
        long s = System.currentTimeMillis();
        for (int i = 0; i < 900000000; i++) {
            catX.hi();
        }
        long e = System.currentTimeMillis();
        System.out.println("m1使用的时间" + (e - s));
    }
    public static void m2() throws InvocationTargetException, IllegalAccessException, ClassNotFoundException, InstantiationException, NoSuchMethodException {
        Class<?> cls = Class.forName("ReflectionTest.CatX");
        Object o = cls.newInstance();
        Method method = cls.getMethod("hi");
        //method.setAccessible(true);//取消访问安全检查
        long s = System.currentTimeMillis();
        for (int i = 0; i < 900000000; i++) {
            method.invoke(o);
        }
        long e = System.currentTimeMillis();
        System.out.println("m2使用的时间" + (e - s));
    }
}

```

- 反射调用优化-关闭访问检查

1. Method和Field、Constructor对象都有setAccessible()方法。
2. setAccessible作用是启动和禁用访问安全检查的开关。
3. 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查。

```java
//取消访问安全检查
method.setAccessible(true);
```

### Class类**

- 基本介绍

1. Class也是**类**，因此也继承Object类[类图]
2. Class类对象是系统创建的，不是new出来的。[演示]
3. 对于某个类的Class类对象，在内存中只有一份，因为**类只加载一次**[演示]
4. 每个类的实例都会记得自己是由哪个Class实例所生成
5. 通过Class对象可以得到一个类的完整结构，使用一系列API(Class类的方法)。
6. Class对象是存放在**堆**的
7. 类的字节码二进制数据，存放在方法区，有的地方称为类的**元数据**(包括方法代码，变量名，方法名，访问权限等等)[示意图]

```java
public class ClassLoaderTest {
    public static void main(String[] args) throws ClassNotFoundException {
        //2.Class类对象是系统创建的，不是new出来的
        //(1)传统new对象
        CatX catX = new CatX();
        //(2〕反射方式.需要注销Cat cat，类只会加载一次
        /*
        clasLoader类，仍然是通过ClassLoader类加载Cat类的 Class对象
        public Class<?> loadClass(String name) throws ClassNotFoundException {
            return loadClass(name,false);
        }
        */
        Class<?> cls = Class.forName("ReflectionTest.CatX");
    }
}

```

- Class类的常用方法

```java
public class ClassTest {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        String classAllPath = "ReflectionTest.CatX";
        //1.获取到Car类对应的Class对象
        Class<?> cls = Class.forName(classAllPath);
        //2.输出cls
        System.out.println(cls);//显示cls对象是哪一个类获取的Class对象
        System.out.println(cls.getClass());//显示cls的运行类型
        //3.得到包名
        System.out.println(cls.getPackage().getName());
        //4.得到全类名
        System.out.println(cls.getName());
        //5.通过cls创建对象实例
        CatX catX = (CatX) cls.newInstance();
        System.out.println(catX);
        //6.通过反射获取属性--私有属性的获取后面单独讲解
        Field name = cls.getField("name");
        System.out.println(name.get(catX));
        //7.通过反射给属性赋值
        name.set(catX, "咖啡猫");
        System.out.println(catX);
        //8.获得所有属性(字段)
        Field[] fields = cls.getFields();
        for (Field f: fields) {
            System.out.println(f.getName());
        }

    }
}
```

- 获取Class类对象

1. 前提：已知一个**类的全类名**，且该类在类路径下，可通过Class类的**静态方法forName()**获取，可能抛出ClassNotFoundException。

   实例： Class cls1 =Class.forName( "java.lang.Cat")；
   应用场景：多用于**配置文件**,读取类全路径，加载类。

2. 前提：若已知具体的类,通过类的class 获取，该方式最为安全可靠,程序性能

   最高实例： Class cls2 = Cat.class;
   应用场景：多用于**参数传递**，比如通过反射得到对应**构造器对象**。

3. 前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象。

   实例：Class cls3 = 对象.getClass();
   应用场景：通过创建好的对象,获取Class对象。

4. 其他方式
   ClassLoader cl =对象.getClass(0).getClassLoader();

   Class cls4 = cl.loadClass("类的全类名");

5. 基本数据(int,char,boolean,float, double,byte,long,short)按如下方式得到Class类对象

   Class cls = 基本数据类型.class

6. 基本数据类型对应的包装类,可以通过.type得到Class类对象

   Class cls = 包装类.TYPE

```java
        //1.Class.forName
        String classAllPath = "ReflectionTest.CatX";
        Class<?> cls1 = Class.forName(classAllPath);
        System.out.println(cls1);
        //2.类名.class，应用场景：用于参数传递
        Class<?> cls2 = CatX.class;
        System.out.println(cls2);
        System.out.println(CatX.class);
        //3.对象.getClass()，应用场景，有对象实例
        CatX catX = new CatX();
        Class<?> cls3 = catX.getClass();
        System.out.println(cls3);
        //4.通过类加载器【4中】来获取到类的Class对象
        //(1)先得到类加载器catX
        ClassLoader classLoader = catX.getClass().getClassLoader();
        //(2)通过类加载器得到Class对象
        Class<?> cls4 = classLoader.loadClass(classAllPath);
        System.out.println(cls4);
        //5.基本数据类型
        Class<Integer> integerClass = int.class;
        System.out.println(integerClass);
        //6.基本数据类型对应的包装类
        Class<Integer> type = Integer.TYPE;
        System.out.println(type);//输出对应的基本数据类型
    }
}
```

- 拥有Class类对象的类型

1. 外部类，成员内部类,静态内部类,局部内部类，匿名内部类
2. interface：接口
3. 数组
4. enum:枚举
5. annotation:注解
6. 基本数据类型
7. void

```java
import java.io.Serializable;
public class TypeClassTest {
    public static void main(String[] args) {
        Class<String> cls1 = String.class;//外部类
        Class<Serializable> cls2 = Serializable.class;//接口
         Class<Integer[]> cls3 = Integer[].class; //数组
        Class<float[][]> cls4 = float[][].class;//二维数组
         Class<Deprecated> cls5 = Deprecated.class;//注解//枚举
        Class<Thread.State> cls6 = Thread.State.class;
        Class<Long> cls7 = long.class;
        Class<Void> cls8 = void.class;
        Class<Class> cls9 = Class.class;
        System.out.println(cls1);
        System.out.println(cls2);
        System.out.println(cls3);
        System.out.println(cls4);
        System.out.println(cls5);
        System.out.println(cls6);
        System.out.println(cls7);
        System.out.println(cls8);
        System.out.println(cls9);
    }
}
```

### 类加载***

- 基本说明

反射机制是java实现**动态语言**的关键，也就是通过反射实现**类动态加载**。

1. 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强

```java
//编译时加载，尽管可能用不上
switch(key) {
    case "1" :
        Dog dog = new Dog();//静态加载--没有Dog类会报错
        break;
    case "2" :
        System.out.println("ok");
        break;
    default:
        System.out.println("do nothing");
        break;
}
```

2. 动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性

```java
//反射--动态加载--运行到反射相关代码才会加载--类不存在编译也不会报错
```

- 类的加载时机

1. 当创建对象时(new)//静态加载
2. 当子类被加载时//静态加载
3. 调用类中的静态成员时//静态加载
4. 通过反射//动态加载

- 类的加载(不是new的过程)

类的加载的三个阶段

1. 将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成。
2. 将类的二进制数据合并到JRE中
3. JVM负责对类进行初始化，这里主要是指静态成员

类的加载示意图** 面试 **--三个阶段

![类的加载1](.\Java入门markdown图片\类的加载1.png)

- 加载阶段

JVM 在该阶段的主要目的是将**字节码**从不同的数据源(可能是 class 文件、也可能是jar 包，甚至网络)转化为**二进制字节流加载到内存中**，并生成一个代表该类的java.lang.Class 对象

- 连接阶段--验证

1. 目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
2. 包括: 文件格式验证(是否以魔数 oxcafebabe开头)、元数据验证、字节码验证和符号引用验证[举例说明]
3. 可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。

- 连接阶段--准备

JVM 会在该阶段对静态变量，分配内存并初始化(对应数据类型的**默认初始化**如 0、0L、null、false 等) 。这些变量所使用的内存都将在方法区中进行分配。

```java
class A {
    //1.n1 是实例属性，不是静态变量，因此在准备阶段，是不会分配内存
    //2.n2 是静态变量，分配内存 n2 是默认初始化 ，而不是20
    //3.n3 是static final 是常量，他和静态变量不一样，因为一旦赋值就不变 n3 = 30
    public int n1 = 10:
    public static int n2 = 20;
	public static final int n3 = 30
}
```

- 连接阶段--解析

虚拟机将常量池内的符号引用替换为直接引用的过程。

- 初始化(lnitialization)

1. 到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行< clinit >()方法的过程。
2. < clinit >()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有**静态变量**的赋值动作和**静态代码块**中的语句，并进行合并。

```java
class B {
	static {
		System.out.printLn("B 静态代码块被执行"):
        num = 300;
    }
	static int num = 100;
    public B() {
    System.out.println("B() 构造器被执行");
    }
}
//初始化阶段合并所有静态代码块
clinit() {
    System.out.printLn("B 静态代码块被执行"):
    //num = 300;//合并: num = 100
    num = 100;
}
```

3. 虚拟机会保证一个类的 < clinit >() 方法在多线程环境中被正确地**加锁、同步**，如果多个线程同时去初始化一个类，那么只会有**一个线程去执行**这个类的 < clinit >()方法，其他线程都需要阻塞等待，直到活动线程执行 < clinit >()方法完毕 。[debug源码]

### 反射获取类的结构信息***

#### 第一组API--Class

```java
/*
第一组：java.lang.Class类
1.getName:获取全类名
2.getSimpleName:获取简单类名
3.getFields:获取所有public修饰的属性，包含本类以及父类的
4.getDeclaredFields:获取本类中所有属性
5.getMethods:获取所有public修饰的方法，包含本类以及父类的
6.getDeclaredMethods:获取本类中所有方法
7.getConstructors:获取所有public修饰的构造器，所有公共的构造器
8.getDeclaredConstructors:获取本类中所有构造器
9.getPackage:以Package形式返回 包信息
10.getSuperClass:以Class形式返回父类信息
11.getInterfaces:以Class[]形式返回接口信息
12.getAnnotations:以Annotation[] 形式返回注解信息
*/
import org.junit.Test;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectionUtilsTest {
    public static void main(String[] args) {

    }
    @Test
    public void api01() throws ClassNotFoundException {
        /*
        第一组：java.lang.Class类
        1.getName:获取全类名
        2.getSimpleName:获取简单类名
        3.getFields:获取所有public修饰的属性，包含本类以及父类的
        4.getDeclaredFields:获取本类中所有属性
        5.getMethods:获取所有public修饰的方法，包含本类以及父类的
        6.getDeclaredMethods:获取本类中所有方法
        7.getConstructors:获取所有public修饰的构造器，包含本类以及父类的
        8.getDeclaredConstructors:获取本类中所有构造器
        9.getPackage:以Package形式返回 包信息
        10.getSuperClass:以Class形式返回父类信息
        11.getInterfaces:以Class[]形式返回接口信息
        12.getAnnotations:以Annotation[] 形式返回注解信息
        */
        Class<?> oneClass = Class.forName("ReflectionUtilsTest.Person");
        //1.getName:获取全类名
        System.out.println(oneClass.getName());
        //2.getSimpleName:获取简单类名
        System.out.println(oneClass.getSimpleName());
        //3.getFields:获取所有public修饰的属性，包含本类以及父类的
        Field[] fields = oneClass.getFields();
        System.out.println();
        for (Field field : fields) {
            System.out.println(field.getName());
        }
        //4.getDeclaredFields:获取本类中所有属性
        Field[] declaredFields = oneClass.getDeclaredFields();
        System.out.println();
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField.getName());
        }
        //5.getMethods:获取所有public修饰的方法，包含本类以及父类的
        Method[] methods = oneClass.getMethods();
        System.out.println();
        for (Method method : methods) {
            System.out.println(method.getName());
        }
        //6.getDeclaredMethods:获取本类中所有方法
        Method[] declaredMethods = oneClass.getDeclaredMethods();
        System.out.println();
        for (Method declaredMethod : declaredMethods) {
            System.out.println(declaredMethod.getName());
        }
        //7.getConstructors:获取所有public修饰的构造器，包含所有公共的构造器
        Constructor<?>[] constructors = oneClass.getConstructors();
        System.out.println();
        for (Constructor<?> constructor : constructors) {
            System.out.println(constructor);
        }
        //8.getDeclaredConstructors:获取本类中所有构造器
        Constructor<?>[] declaredConstructors = oneClass.getDeclaredConstructors();
        System.out.println();
        for (Constructor<?> declaredConstructor : declaredConstructors) {
            System.out.println(declaredConstructor);
        }
        //9.getPackage:以Package形式返回 包信息
        System.out.println(oneClass.getPackage());
        //10.getSuperClass:以Class形式返回父类信息
        Class<?> superClass = oneClass.getSuperclass();
        System.out.println(superClass);
        //11.getInterfaces:以Class[]形式返回接口信息
        Class<?>[] interfaces = oneClass.getInterfaces();
        System.out.println();
        for (Class<?> anInterface : interfaces) {
            System.out.println(anInterface.getName());
        }
        //12.getAnnotations:以Annotation[] 形式返回注解信息
        Annotation[] annotations = oneClass.getAnnotations();
        System.out.println();
        for (Annotation annotation : annotations) {
            System.out.println(annotation);
        }
    }
}
interface IA {}
interface IB {}
class PersonFather implements IA {
    public String fatherName;

    public PersonFather() {
    }

    public PersonFather(String fatherName) {
        this.fatherName = fatherName;
    }
}
@Deprecated
class Person extends PersonFather implements IB {
    public Person(String name) {
        this.name = name;
    }
    public Person() {

    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    private Person(int age) {
        this.age = age;
    }
    public String name;
    protected int age;
    String job;
    private double sal;
    //方法
    public void m1() {
    }
    protected void m2() {
    }
    void m3() {

    }
    private void m4() {
    }
}
```

#### 第二组API--Field

```java
/*
java.lang.reflect.Field类
1.getModifiers:以int形式返回修饰符
[说明: 默认修饰符是0，public是1，private是2，protected是4，static是8，final是16]
2.getType:以Class形式返回类型
3.getName:返回属性名
*/
public void api02() throws ClassNotFoundException {
    Class<?> oneClass = Class.forName("ReflectionUtilsTest.Person");
    Field[] declaredFields = oneClass.getDeclaredFields();
    System.out.println();
    for (Field declaredField : declaredFields) {
        System.out.println("属性名：" + declaredField.getName() + "修饰符值：" + declaredField.getModifiers() +
                           "该属性的类型" + declaredField.getType());
    }//组合值会将所有修饰符值相加
}
```

#### 第三组API--Method

```java
/*
java.lang.reflect.Method类
1.getModifiers:以int形式返回修饰符
[说明: 默认修饰符是0，public是1，private是2，protected是4，static是8，final是16]
2.getReturnType:以Class形式获取 返回类型
3.getName:返回方法名
4.getParameterTypes:以Class[]返回参数类型数组
*/
@Test
public void api03() throws ClassNotFoundException {
    Class<?> oneClass = Class.forName("ReflectionUtilsTest.Person");
    Method[] declaredMethods = oneClass.getDeclaredMethods();
    System.out.println();
    for (Method declaredMethod : declaredMethods) {
        System.out.println("方法名为：" + declaredMethod.getName() + "方法的访问修饰值" + declaredMethod.getModifiers()
                           + "方法的返回类型" + declaredMethod.getReturnType());
        Class<?>[] parameterTypes = declaredMethod.getParameterTypes();
        if (parameterTypes.length != 0) {
            StringBuilder s = new StringBuilder();
            s.append(declaredMethod.getName()).append("方法的参数有");
            for (Class<?> parameterType : parameterTypes) {
                s.append(parameterType.getName());
            }
            System.out.println(s);
        }
    }
}
```

#### 第四组API--Constructor

```java
/*
java.lang.reflect.Constructor类
1.getModifiers:以int形式返回修饰符
2.getName:返回构造器名 (全类名)
3.getParameterTypes:以Class[] 返回参数类型数组
*/
@Test
public void api04() throws ClassNotFoundException {
    Class<?> oneClass = Class.forName("ReflectionUtilsTest.Person");
    Constructor<?>[] declaredConstructors = oneClass.getDeclaredConstructors();
    System.out.println();
    for (Constructor<?> declaredConstructor : declaredConstructors) {
        System.out.println("构造器：" + declaredConstructor);
        Class<?>[] parameterTypes = declaredConstructor.getParameterTypes();
        if (parameterTypes.length > 0) {
            StringBuilder s = new StringBuilder(declaredConstructor + "构造器的参数类型为\t");
            for (Class<?> parameterType : parameterTypes) {
                s.append(parameterType.getName());
            }
            System.out.println(s);
        }
    }
}
```

#### 通过反射创建对象

- 基本方法

1. 方式一:调用类中的public修饰的无参构造器
2. 方式二:调用类中的指定构造器
3. Class类相关方法
   newlnstance : 调用类中的**无参构造器**，获取对应类的对象
   getConstructor(Class...clazz):根据**参数列表**，获取对应的公开构造器对象
   getDecalaredConstructor(Class...clazz):根据**参数列表**，获取对应的构造器对象
4. Constructor类相关方法
   setAccessible:暴破
   newlnstance(Object...obj):调用构造器

- 演示案例--创建实例

```java
//反射爆破--创建实例
package ReflectionTest;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ReflectionCreateTest {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        //1.先获取到User类的cLass对象
        Class<?> userCls = Class.forName("ReflectionTest.User");//注意类别选错了
        //2.通过public的无参构造器创建实例
        Object o = userCls.newInstance();
        System.out.println(o);
        //3.通过public的有参构造器创建实例
        Constructor<?> constructor = userCls.getConstructor(int.class);
        Object Max = constructor.newInstance(19);
        System.out.println(Max);
        //4.通过非public的有参构造器创建实例
        Constructor<?> declaredConstructor = userCls.getDeclaredConstructor(int.class, String.class);
        declaredConstructor.setAccessible(true);//爆破-暴力破坏封装特性
        Object Min = declaredConstructor.newInstance(12, "Panda");//不爆破直接创建会出错，构造器是私有的
        System.out.println(Min);
    }
}
class User{
    private int age = 18;
    private String name = "Meez";
    public User() {

    }
    public User(String name) {
        this.name = name;
    }
    public User(int age) {
        this.age = age;
    }
    private User(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
```

- 演示案例--访问属性

1. 根据属性名获取Field对象

   Field f = clazz对象.getDeclaredField(属性名);

2. 暴破 : f.setAcessible(true); //f 是Field的实例
3. 访问
   f.set(o,值);//o表示对象的实例
   syso(f.get(o));
4. 如果是静态属性，则set和get中的参数，可以写成null

```java
//爆破访问非公开属性
package ReflectionTest;
import java.lang.reflect.Field;
public class ReflectionAccessProperty {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        //1.得到Student类对应的 Class对象
        Class<?> stuCls = Class.forName("ReflectionTest.Student");
        //2.创建对象
        Object o = stuCls.newInstance();
        System.out.println(o.getClass());
        //3.使用反射得到age属性对象--公开属性
        Field age = stuCls.getField("age");
        age.set(o, 20);//反射设置属性
        System.out.println(o);
        //4.使用反射操作name 属性--非公开属性
        Field name = stuCls.getDeclaredField("name");
        name.setAccessible(true);
        name.set(o, "Pandaaaai");//不爆破没法直接设置--非公开属性
        System.out.println(o);
        name.set(null, "MaoMao");//静态属性对象可以设置为null
        System.out.println(o);
        System.out.println(name.get(o));
        System.out.println(name.get(null));//获取也同理
    }
}
class Student {
    public int age;
    private static String name;
    public Student() {

    }

    @Override
    public String toString() {
        return "Student{" +
                "age=" + age +
                "\tname=" + name +
                '}';
    }
}
```

- 演示案例--访问方法

1. 根据**方法名**和**参数列表**获取Method方法对象 : Method m = clazz.getDeclaredMethod(方法名，XX.class);//本类所有方法
2. 获取对象: Object o=clazz.newlnstance(0);
3. 暴破 : m.setAccessible(true);
4. 访问 : Object returnValue = m.invoke(o,实参列表)
5. 注意: 如果是静态方法，则invoke的参数o，可以写成null!

```java
package ReflectionTest;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @version 1.0
 * @auther Meez
 */
public class ReflectionMethodTest {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        //1.得到Boss类对应的CLass对象
        Class<?> oneBoss = Class.forName("ReflectionTest.Student");
        //2.创建对象
        Object o = oneBoss.newInstance();
        //3.调用public的hi()方法
        Method hi = oneBoss.getMethod("hi", String.class);
        //4.调用
        hi.invoke(o, "注意形参列表");
        //5.调用非public的say()方法
        Method say = oneBoss.getDeclaredMethod("say");
        say.setAccessible(true);//爆破私有方法
        //6.调用
        say.invoke(o);
        //7.在反射中，如果方法有返回值，统一返回object，运行类型和返回类型一致
        Object reVal = say.invoke(o);
        System.out.println(reVal);
    }
}
class Student {
    public int age;
    public Student() {

    }
//    private static String say(int n, String s, char c) {
//        return "";
//    }
    public void hi(String s) {
        System.out.println(s);
    }
    private String say(){
        System.out.println("say被调用");
        return "返回值";
    }
}
```

## MySQL

### MySQL安装和配置

- 安装教程

1. 软件下载

2. 安装失败/重新安装

```java
sc delete mysql //删除已经安装好的mysql服务
```

3. 安装

[MySQL数据库下载及安装教程（最最新版）-CSDN博客](https://blog.csdn.net/weixin_39289696/article/details/128850498)

4. 添加环境变量：path添加MySQL的安装目录/bin

5. 启动mysql

   net start mysql

6. 关闭mysql

   net stop mysql

7. 修改root密码

- 使用命令行窗口连接MySQL数据库

1. mysql-h 主机名 -P 端口 -u 用户名 -p密码(-p后面不能有空格/或者不写-再输入密码)
2. 登录前，保证服务启动
   - 服务方式启动(界面)
   - net stop mysql(终止)
   - net strat mysql(启动)

3. 配置文件设置的端口为mysql的监听窗口(可能有其他服务与他冲突，-P 设置新的端口号)

<img src=".\Java入门markdown图片\MySQL服务连接.png" alt="MySQL服务连接" style="zoom:50%;" />

- 图形化MySQL管理界面

1. 下载/安装/使用
   - Navicat(付费)
   - SQLyog(免费)

### 数据库

- 数据库三层结构

1. 所谓安装Mysql数据库，就是在主机安装一个数据库管理系统(DBMS)，这个管理程序可以管理多个数据库。DBMS(database manage system)
2. 一个数据库中可以创建多个表，以保存数据(信息)。
3. 数据库管理系统(DBMS)、数据库和表的关系如图所示:

<img src="C:\Users\97359\Desktop\Java学习\Java从入门到入土\Java入门markdown笔记\Java入门markdown图片\数据库结构示意图.png" alt="数据库结构示意图" style="zoom:50%;" />

- 数据再数据库中的存储方式

表的一行称之为一条记录 -> 在java 程序中，一行记录往往使用**对象**表示

<img src="C:\Users\97359\Desktop\Java学习\Java从入门到入土\Java入门markdown笔记\Java入门markdown图片\数据库的数据结构.png" alt="数据库的数据结构" style="zoom: 67%;" />

- SQL语句分类

1. DDL: 数据定义语句[create 表，库...]
2. DML : 数据操作语句 [增加 insert，修改 update，删除 delete]
3. DQL: 数据查询语句 [select]
4. DCL: 数据控制语句[管理数据库：比如 用户权限 grand revoke]

#### JAVA操作数据库

- 简单案例演示

1. 创建一个商品hsp_goods表,选用适当的数据类型
2. 添加2条数据
3. 删除表goods

#### 创建

- 创建数据库

1. CHARACTER SET: 指定数据库采用的字符集，如果不指定字符集 ，默认utf8
2. COLLATE: 指定数据库字符集的校对规则(常用的utf8_bin[区分大小写]、utf8_general_ci[不区分大小写] 注意默认是 utf8_general_ci)[举例说明]

- 练习

1. 创建一个名称为hsp_db01的数据库。[图形化和指令--演示]
2. 创建一个使用utf8字符集的hsp_db02数据库
3. 创建一个使用utf8字符集，并带校对规则的hsp_db03数据库

```mys
#1.图形化界面
#直接右键创建->设置数据库名称-基字符集-数据库排列规则
#2.使用指令创建
DROP DATABASE testdb;#删除数据库 testdb--数据库的名称
CREATE DATABASE testdb;#创建数据库--没有指定字符集时默认为utf8,没有指定数据库字符集的校对规则时默认为utf8_general_ci.
# 指定字符集
CREATE DATABASE testdb1 CHARACTER SET utf8;
# 指定字符集和校对规则
CREATE DATABASE testdb2 CHARACTER SET utf8 COLLATE utf8_bin;
# 查询语句
# select 查询 *表示所有字段 EROM 从哪个表
# WHERE 从哪个字段 NAME =tom 查询名字是tom
SELECT * FROM testtable WHERE NAME = 'tom';
```

注意：数据库中的表没有指定字符集和校验规则就会使用数据库的字符集和校验规则

#### 查看/删除

```mysql
#显示数据库语句
SHOW DATABASES
#显示数据库创建语句
SHOW CREATE DATABASE db name
#数据库删除语句
DROP DATABASE [IF EXISTS] db name
#删除和查询数据库
# 查看所有数据库
SHOW DATABASES;
# 查看创建db_name数据库的定义信息
SHOW CREATE DATABASE testdb1;
# 在创建数据库,表的时候，为了规避关键字，可以使用反引号``(波浪号)解决
CREATE DATABASE `CREATE`;

```

#### 备份/恢复

- 备份数据库(注意:在DOS执行)
  mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n > 文件名.sql
- 恢复数据库(注意: 进入MySQL命令行再执行：mysql -u root -p)
  Source 文件名.sql

```mysql
# 备份数据库
mysqldump -u root -p -B testdb1 testdb2 > c:\\bak1.sql(文件存放目录)
#恢复
#1.进入mysql
mysql -u root -p
#恢复数据
source xx.sql(文件目录)
source c:\\bak.sql
#2.复制sql文件的内容到query窗口执行
```

```mysql
# 备份表
mysqldump -u root -p -B 数据库 表1 表2 > c:\\bak1.sql(文件存放目录)
```

### 表

#### 创建

- 基本语法

```mysql
CREATE TABLE table name
(field1 datatype,
field2 datatype,
field3 datatype
)character set 字符集 collate 校对规则 engine 存储引擎
field 指定列名 datatype 指定列类型(字段类型)
character set: 如不指定则为所在数据库字符集
collate 如不指定则为所在数据库校对规则
engine 引擎(这个涉及内容较多，后面讲解)
```

1. 可视化管理系统创建表
2. MySQL指令创建表

```my
CREATE TABLE USERtestINFO 
(
id INT,
`name` VARCHAR(255),
`password` VARCHAR(255),
`birthday` DATE
)
CHARACTER SET utf8 COLLATE utf8_bin;
```

#### 删除

```mysql
-- 删除表
DROP TABLE student;
```

#### 修改

- 使用 ALTER TABLE 语句追加，修改，或删除列的语法

1. 添加列

```mysql
ALTER TABLE tablename
ADD	(column datatype [DEFAULT expr]
    [，column datatype]...);

#添加
ALTER TABLE t11 ADD image VARCHAR(32) NOT NULL DEFAULT '' AFTER resume;
DESC t11;
```

2. 修改列

```mysql
ALTER TABLE tablename
MODIFY (column datatype [DEFAULT expr]
[, column datatype]
#修改列--VARCHAR(60)的长度
ALTER TABLE t11 MODIFY job VARCHAR(60) NOT NULL DEFAULT '';
#删除sex列
ALTER TABLE t11 DROP sex;
#修改表名字
RENAME TABLE t11 TO employee;
#修改字符集
ALTER TABLE employee CHARACTER SET utf8;
#修改列名称
ALTER TABLE employee CHANGE NAME user_name VARCHAR(32) NOT NULL DEFAULT '';
```

3. 删除列

```mysql
ALTER TABLE tablename
DROP (column);
查看表的结构: desc 表名;-- 可以查看表的列
```

4. 修改表名: Rename table 表名 to 新表名
5. 修改表字符集: alter table 表名 character set 字符集

### MySQL常用数据类型(列类型)**

- 数据类型(列类型)

1. 数值类型
   - 整型 tinyint[1个字节] smallint[2个字节] mediumint[3个字节] **int[4个字节]** bigint[8个字节]
   - 小数类型 float[单精度 4个字节] **double[双精度 8个字节]** **decimal[M, D] [大小由M和D确定 M表示长度 D表示位数]**
2. 文本类型(字符串类型) **char[0-255 固定长度 M个字符] varchar[0-2^16-1 可变长度 字节] text[0-2^16-1]** longtext[0-2^32-1] 带符号就正负均分
3. 二进制数据类型 **blob[0-2^16-1]** longblob[0-2^32-1] 位类型 bit[M 1-64 默认1] M指定位数
4. 日期类型 date[日期 年月日] time[时间 时分秒] **datetime[年月日时分秒 YYYY-MM-DD HH:mm:ss]** **timestamp[时间戳]**

- 数值类型(整型)的基本使用

1. 说明，使用规范:在能够满足需求的情况下，尽量选择占用空间小

![MySQL整数类型](.\Java入门markdown图片\MySQL整数类型.png)

2. 案例演示

```mysql
# 越界测试
CREATE TABLE t3 
(
# 如果没有unsigned就是有符号类型
id TINYINT
);
INSERT INTO t3 VALUES(128);
SELECT * FROM t3;
```

```mysql
CREATE TABLE t4 
(
# 如果没有unsigned就是有符号类型
id TINYINT UNSIGNED
);
INSERT INTO t4 VALUES(222);
SELECT * FROM t4;
```

- 数值型(bit)的使用

1. 基本使用

```mys
CREATE TABLE t5 
(
# 1.bit(m) m在1-64 添加数据的范围
num BIT(8)
);
INSERT INTO t5 VALUES(1);
INSERT INTO t5 VALUES(8);
SELECT * FROM t5;
```

2. 细节说明
   - bit 字段显示时，按照 位的方式显示
   - 查询的时候仍然可以用使用 添加的数值
   - 如果一个值只有 0/1 可以考虑使用 bit(1)可以节约空间
   - 位类型。M指定位数，默认值1，范围1-64
   - 使用不多

- 数值型(小数)的基本使用

1. FLOAT/DOUBLE[UNSIGNED]
2. DECIMAL[M, D] [UNSIGNED]
   - 可以支持更加精确的小数位。**M是小数总位数**(精度)，**D**是**小数点(标度)后**面的位数。(位数不够后面会补0)
   - 如果D是0，则值没有小数点或分数部分。M最大65。D最大是30。如果D被省略，默认是0。如果M被省略，默认是10。
   - 建议:如果希望小数的精度高，推荐使用decimal

3. 演示

```mysql
CREATE TABLE t6 
(
# 1.bit(m) m在1-64 添加数据的范围
num1 FLOAT,
num2 DOUBLE,
num3 DECIMAL(30,20)
);
INSERT INTO t6 VALUES(123.123456789123,123.123456789123,123.123456789123);
SELECT * FROM t6;
```

- 字符串的基本使用

1. CHAR(size 0-255字符大小)固定长度字符串 最大255字符
2. VARCHAR(size 0~65535字节大小)可变长度字符串 最大65532字节：[utf8编码最大21844字符(能存储的字符和编码格式有关系) **1-3个**
   **字节**用于**记录大小**]

3. 应用案例

```mysql
CREATE TABLE t7 
(
# 1.bit(m) m在1-64 添加数据的范围
`name` CHAR(255),
`info` VARCHAR(200) CHARSET gkb
);
SELECT * FROM t7;
```

- 字符串的使用细节

1. char(4) //这个4表示字符数(最大255)，不是字节数,不管是中文还是字母都是放四个,按字符计算.
2. varchar(4)//这个4表示字符数，不管是字母还是中文都以**定义好的表的编码**来存放数据.
3. char(4)是定长(固定的大小)，就是说，即使你 插入aa'，也会占用分配的4个字符的空间.
4. varchar(4) 是变长，如果你插入了“aa,实际占用空间大小并不是4个字符，而是按照实际占用空间来分配(说明: varchar本身还需要占分配用1-3个字节来记录存放内容长度)

5. 定长度的内容使用char比如：md5码、邮编、手机号、身份证号
6. 不定长度的内容使用varchar比如：留言、文章 -- 存放文本类型也可以使用text类型
7. 查询速度：char > varchar

```mysql
CREATE TABLE t8
(
# 1.bit(m) m在1-64 添加数据的范围
`content1` TEXT,
`content2` MEDIUMTEXT,
`content3` LONGTEXT
);
INSERT INTO t8 VALUES('计算机视觉', '计算机视觉1000', '计算机视觉1000000');
SELECT * FROM t8;
```

- 时间日期

1. 基本使用

```mysql
CREATE TABLE t9
(
# 1.bit(m) m在1-64 添加数据的范围
`birthday` DATE,
`jobtime` DATETIME,
# timestamp设置自动更新--列表更新就自动更新
`logintime` TIMESTAMP
NOT NULL DEFAULT CURRENT_TIMESTAMP
ON UPDATE CURRENT_TIMESTAMP
);
INSERT INTO t9(`birthday`, `jobtime` ) VALUES('2022-11-11', '2022-11-11 10:07:11');
SELECT * FROM t9;
```

- 数据类型的练习

```mysql
CREATE TABLE t11
(
# 1.bit(m) m在1-64 添加数据的范围
`id` INT,
`name` VARCHAR(32),
`sex` char(1),
`birthday` DATE,
`entry_date` DATETIME,
job VARCHAR(32),
salary DOUBLE,
`resume` TEXT
); CHARSET SET utf8 COLLATE SET utf8_bin;
INSERT INTO t11 VALUES(100, '小妖怪', '男', '2000-11-11', '2010-11-10 11:11:11', '巡山', 2800, '大王叫我来巡山');
SELECT * FROM t11;
```

### 数据库的CRUD**

#### Insert

- 基本语法

```mysql
#列表和值有对应关系
INSERT INTO table name [(column [, column...])]
VALUES (value [, value...]);
#
CREATE TABLE goods (
id INT,
goods_name VARCHAR(10),
price DOUBLE NOT NULL DEFAULT 100
);
INSERT INTO goods (id, goods_name, price)
VALUES(123, '果冻', 12.00);
```

- 细节说明

1. **插入的数据**应与字段的**数据类型相同**。比如 把 abo' 添加到 int 类型会错误
2. 数据的**长度**应在列的**规定范围内**，例如: 不能将一个长度为80的字符串加入到长度为40的列中
3. 在values中列出的**数据位置**必须与被加入的列的**排列位置相对应**。
4. **字符和日期型数据**应包含在**单引号**中。
5. 列可以插入**空值**[前提是该字段**允许为空**]，insert into table value (null)
6. insert into tab name (列名..) values (), (), () 形式添加多条记录
7. 如果是给表中的**所有字段添加数据**，可以**不写**前面的**字段名称**
8. 默认值的使用，当不给某个字段值时，如果有默认值就会添加，否则报错

#### Update

- 基本语法

```mysql
UPDATE tbl_name
	SET col_name1=expr1 [, col name2=expr2 ...]
	[WHERE where definition]
# 没有WHERE where definition 就是修改所有行的该列信息
UPDATE employee SET salary = 5000;
# 指定修改 where
UPDATE employee SET salary = 1000 + salary
WHERE user_name = '小旋风'
```

- 使用细节

1. UPDATE语法可以用新值更新原有表行中的各列。
2. SET子句指示要**修改的列**和**赋值**。
3. WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行。
4. 如果需要修改多个字段，可以通过 set 字段1=值1, 字段2=值2..

#### Delete

- 基本语法

```mysql
# 删除某个记录
DELETE FROM employee WHERE user_name = '小旋风';
# 删除所有记录
DELETE FROM employee;
# 显示
SELECT * FROM employee;
```

- 删除的使用细节

1. 如果不使用where子句，将删除表中所有数据
2. Delete语句**不能删除某一列**的值 (可使用update 设为 null 或者)
3. 使用**delete语句仅删除记录**，不删除表本身。如要**删除表**，使用**drop table**语句。drop table 表名

#### Select**

- 基本语法

1. 单表查询

```mysql
# 单表
#
SELECT [DISTINCT] *|{columnl, column2. column3..}
FROM tablename;
# 
```

- 注意事项

1. Select 指定查询哪些列的数据。
2. column指定列名。
3. *号代表查询所有列
4. From指定查询哪张表
5. DISTINCT可选，指显示结果时，**是否去掉重复数据**

- 案例展示-常用操作

```mys
# 创建表
CREATE TABLE student(
id INT NOT NULL DEFAULT 1,
NAME VARCHAR(20) NOT NULL DEFAULT '',
chinese FLOAT NOT NULL DEFAULT 0.0,
english FLOAT NOT NULL DEFAULT 0.0,
math FLOAT NOT NULL DEFAULT 0.0
);
# 插入数据
INSERT INTO student(id, NAME,chinese, english, math) VALUES(1, '韩顺平',89,78,90);
INSERT INTO student(id, NAME,chinese, english, math) VALUES(2, '张飞',67,98,56) ;
INSERT INTO student(id, NAME,chinese, english, math) VALUES(3, '宋江',87,78,77) ;
INSERT INTO student(id, NAME,chinese, english, math) VALUES(4, '关羽',88,98,90) ;
INSERT INTO student(id, NAME,chinese, english, math) VALUES(5, '赵云',82,84,67) ;
INSERT INTO student(id, NAME,chinese, english, math) VALUES(6, '欧阳锋',55,85,45);
INSERT INTO student(id, NAME,chinese, english, math) VALUES(7, '黄蓉',75,65,30);
# 查看表
SELECT * FROM student;
# 查询表中所有学生的信息。
SELECT * FROM student;
# 查询表中所有学生的姓名和对应的英语成绩
SELECT `name`, english FROM student;
# DISTINCT 需要查询的每一列都相同才去重复
# 过滤表中重复数据 distinct
SELECT DISTINCT english FROM student;
```

- 其他操作

1. 使用表达式对查询的列进行运算

```mysql
SELECT *|{columnl | expression, column2 | expression, ..}
FROM tablename;
```

2. 在select语句中可使用as语句--取别名

```mys
SELECT column name as 别名 from 表名;
```

3. 在where子句中经常使用的运算符
   - 比较运算符

```mysql
#1. 大于、小于、大于(小于)等于、不等于 > < >= <= = !=
#2. 显示在某一区间的值 BETWEEN ...AND.. 
#3. 显示在in列表中的值，例: in(100,200) IN(set)
#4.模糊查询 LIKE“张pattern NOT LIKE
#5.判断是否为空 IS NULL
```

- - 逻辑运算符

```mysql
#多个条件同时成立 and
#多个条件任一成立 or
#不成立，例: where not(salary>100); not 
```

4. order by 子句查询排序结果
   - Order by 指定排序的列，排序的列既可以是表中的列名，也可以是select语句后指定的列名。
   - Asc 升序[默认]、Desc 降序
   - ORDER BY 子句应位于**SELECT语句的结尾**

```mysql
# 默认升序
SELECT * FROM student ORDER BY math;
# 降序
SELECT * FROM student ORDER BY math DESC;
#
SELECT `name`, (chinese + english + math) as total_score FROM student
ORDER BY total_score;
# 姓韩的同学数学成绩升序排列
SELECT * FROM student WHERE `NAME` LIKE '韩%' ORDER BY math ASC;
```

5. 使用group by 子句对列进行分组

```mysql
SELECT column1, column2, column2 FROM table
group by column
```

6. 使用having 子句对分组后的结果进行过滤

```mysql
SELECT column1, column2, column3..
FROM table
group by column having ...
```

- 演示案例-其他操作

```mysql
# 查询总分
SELECT `name`, (chinese + english + math) FROM student;
# 取别名
SELECT `name`, (chinese + english + math) AS total_name FROM student;
SELECT `name` AS '名字', (chinese + english + math) AS total_name FROM student;
```

```mysql
SELECT * FROM student WHERE `name` = '赵云';
SELECT * FROM student WHERE english > 90;
SELECT * FROM student WHERE (chinese + english + math) > 200;
SELECT * FROM student WHERE math > 60 AND id > 4;
SELECT * FROM student WHERE english > chinese;
SELECT * FROM student WHERE (chinese + english + math) > 200 AND math < chinese;
# 名字以张结尾的人
SELECT * FROM student WHERE (chinese + english + math) > 200 AND math < chinese AND `NAME` LIKE '张%';
# between and 是闭区间
SELECT * FROM student WHERE english BETWEEN 80 and 90;
# 在(90, 91, 89)内的数据
SELECT * FROM student WHERE math IN (90, 91, 89);
```

```mysql
# 多表查询
# 创建表
# 部门表
CREATE TABLE dept (
deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,
dname VARCHAR(20) NOT NULL DEFAULT '',
loc VARCHAR(13) NOT NULL DEFAULT ''
);
INSERT INTO dept 
VALUES(10, 'ACCOUNTING', 'NEW YORK'), (20, 'RESEARCH', 'DALLAS'),
(30, 'SALES', 'CHICAGO'),(40, 'OPERATIONS', 'BOSTON');
SELECT * FROM dept;

# 员工表
CREATE TABLE emp
(empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*编号*/
ename VARCHAR(20) NOT NULL DEFAULT '',/*名字*/
job VARCHAR(9) NOT NULL DEFAULT '',/*工作*/
mgr MEDIUMINT UNSIGNED,/*上级编号*/
hiredate DATE NOT NULL,/*入职时间*/
sal DECIMAL(7,2) NOT NULL,/*新水*/
comm DECIMAL(7,2),/*红利*/
deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0/*部门编号*/
);

INSERT INTO emp 
VALUES(7369, 'SMITH', 'CLERK', 7902,'1990-12-17', 800.00, NULL, 20),
(7499, 'ALLENS','ALESMAN', 7698,'1991-2-20', 1600.00, 300.00, 30),
(7788,'SCOTT', 'ANALYST',7566,'1997-4-19', 3000.00, NULL,20),
(7839, 'KING', 'PRESIDENT', NULL, '1991-11-17',5000.00,NULL,10),
(7844,'TURNER', 'SALESMAN',7698,'1991-9-8', 1500.00, NULL, 30),
(7900,'JAMES', 'CLERK',7698, '1991-12-3', 950.00, NULL, 30),
(7902,'FORD', 'ANALYST',7566, '1991-12-3', 3000.00, NULL, 20),
(7934, 'MILLER', 'CLERK', 7782,'1992-1-23',1300.00, NULL, 10);
SELECT * FROM emp;

# 工资级别表
CREATE TABLE salgrade(
grade MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,
losal DECIMAL(17,2) NOT NULL,
hisal DECIMAL(17,2) NOT NULL
);

INSERT INTO salgrade VALUES (1,700,1200);
INSERT INTO salgrade VALUES (2,1201,1400);
INSERT INTO salgrade VALUES (3,1401,2000);
INSERT INTO salgrade VALUES (4,2001,3000);
INSERT INTO salgrade VALUES (5,3001,9999);
SELECT * FROM salgrade;

# 查询
# 各个部门的平均工资-最高工资
SELECT AVG(sal), MAX(sal), deptno
FROM emp GROUP BY deptno;
# 各个部门的各岗位的平均工资和最低工资
SELECT AVG(sal), MAX(sal), deptno, job
FROM emp GROUP BY deptno, job;
# 平均工资大于2000的部门和部门号
# group by... 和 having ... 配合使用
SELECT AVG(sal), deptno
FROM emp GROUP BY deptno
HAVING AVG(sal) > 2000;
# 使用别名
SELECT AVG(sal) AS avg_sal, deptno
FROM emp GROUP BY deptno
HAVING avg_sal > 2000;
```

#### 查询增强

- where子句

```mysql
-- mysql中时间可以直接进行比较
-- 查询入职时间 ＞ '1992-01-01'的员工
SELECT * FROM emp WHERE hiredate > '1992-01-01';
-- 首字母位s的员工姓名和工资
SELECT ename, sal FROM emp WHERE ename LIKE 'S%';
-- 第三个字母为大写O  '_'一个下划线表示任意字符 '%'表示0到任意字符
SELECT ename, sal FROM emp WHERE ename LIKE '__O%';
-- 查询上级为空的员工
SELECT * FROM emp WHERE mgr IS NULL;
-- 查询表结构
DESC emp;
```

- order by 子句

```mysql
-- 工资升序
SELECT * FROM emp ORDER BY sal;
-- 排序之后再排序
-- 先按照部门号升序-工资降序
SELECT * FROM emp ORDER BY deptno ASC, sal DESC;
```

- 分页查询

1. 按雇员的id号升序取出，每页显示3条记录，请分别显示 第1页，第2页，第3页
2. 基本语法: select ... limit start, rows
   表示从start+1 行开始取,取出rows行,start 从0开始计算

```mys
-- 数据量非常大的时候-涉及数据信息的分页问题
-- 第一页
SELECT * FROM emp ORDER BY empno 
LIMIT 0, 3;
-- 第二页
SELECT * FROM emp ORDER BY empno 
LIMIT 3, 3;
```

- select语句的执行顺序

如果select语句同时包含有group by ，having，limit，order by 那么他们的顺序是group by，having，order by，limit

```mysql
SELECT column1, column2, column3 .. FROM table
    group by column
    having condition
    order by column
    limit start, rows;
```

```mysql
-- 演示案例
/*
应用案例: 请统计各个部门group by 的平均工资 avg，
并且是大于1000的 having，并且按照平均工资从高到低排序，order by
取出前两行记录 limit
*/
SELECT deptno, AVG(sal) AS avg_sal
FROM emp
GROUP BY deptno
HAVING avg_sal > 1000
ORDER BY avg_sal DESC
LIMIT 0, 2
```

- 案例演示

使用分组函数和分组子句 group by

1. 显示每种岗位的雇员总数、平均工资
2. 显示雇员总数，以及获得补助的雇员数
3. 显示管理者的总人数。
4. 显示雇员工资的最大差额

```mysql
-- 1.
SELECT COUNT(*), AVG(sal), job
FROM emp
GROUP BY job;
-- 2.
SELECT COUNT(*), COUNT(comm) FROM emp;
-- 没有获得补助的人数
SELECT COUNT(*), COUNT(IF(comm IS NULL,1,NULL)) FROM emp;
-- 3.
-- mgr统计并去重复
SELECT COUNT(DISTINCT mgr) FROM emp;
-- 4.
SELECT MAX(sal) - MIN(sal)
FROM emp;
```

#### 多表查询/内连接

- 说明

多表查询是指基于两个和两个以上的表查询.在实际应用中，查询单个表可能不能满足需求。

(如下面的课堂练习)，需要使用到(dept表和emp表)。

- 演示案例

```mysql
-- 直接查询两张表 
-- 1.第一张表的每一行跟第二张表的每一行进行组合
-- 2.返回的总行数=第一张表行数*第二张表行数
-- 3.这种多表查询的默认返回结果称为，笛卡尔集
-- 4.多表查询的关键是对笛卡尔集的where过滤条件
SELECT * FROM emp, dept;
-- 显示员工名称-工资-所在部门
SELECT ename, sal, dname
FROM emp, dept
WHERE emp.deptno = dept.deptno;
-- 当两个表有同名的列时，需要指定表名
SELECT ename, sal, dname, emp.deptno
FROM emp, dept
WHERE emp.deptno = dept.deptno;
```

注意：多表查询的过滤条件数 不少于 **表的个数-1** 否则 还是存在笛卡尔集

```mysql
-- 部门号为10的部门名员工名和工资
SELECT ename, sal, dname, emp.deptno
FROM emp, dept
WHERE emp.deptno = dept.deptno AND emp.deptno = 10
-- 显示所有员工的姓名、工资和工资级别
SELECT ename, sal, grade
FROM emp, salgrade
WHERE sal BETWEEN losal AND hisal;
-- 员工名、工资和所在部门，且部门降序排列
SELECT ename, sal, dname, emp.deptno
FROM emp, dept
WHERE emp.deptno = dept.deptno
ORDER BY emp.deptno DESC
```

##### 自连接

- 基本说明

自连接是指在同一张表的连接查询。

- 案例

```mysql
-- 案例分析：显示员工和员工上级的名字
-- 在同一个表内但是没有明确的列类型
-- 通过同一个表的关联实现
-- 把一张表当作两张表使用-需要给表取不同的别名：
-- 表名 别名
SELECT worker.ename AS '职员名', boss.ename AS '上级名'
FROM emp worker, emp boss
WHERE worker.mgr = boss.empno
```

#### 子查询

- 基本说明

1. 什么是子查询 ？
   子查询是指嵌入在其它sql语句中的select语句,也叫嵌套查询
2. 单行子查询：单行子查询是指只返回一行数据的子查询语句
   请思考: 如何显示与SMITH同一部门的所有员工?
3. 多行子查询：多行子查询指返回多行数据的子查询
   使用关键字 in

- 案例演示

```mysql
-- 子查询
-- 显示和smith一个部门的所有员工
-- 1. 查询 smith 的部门号
-- 2. 把第一步的select语句当作子查询
SELECT * FROM emp
WHERE deptno = (
SELECT deptno FROM emp WHERE ename= 'SMITH'
)
-- 显示不是10号部门的员工的名字、岗位、工资、部门号
SELECT ename, job, sal, deptno
FROM emp
WHERE job IN (
SELECT DISTINCT job
FROM emp
WHERE deptno = 10
) AND deptno != 10;
```

- 子查询结果当作临时表

```mysql
-- 查询各类商品最高价格的名称
-- 各类的最高价格
SELECT cat_id, MAX(shop_price)
FROM ecs_goods
GROUP BY cat_id;
-- 查询商品id、类别id、商品名称、价格
SELECT goods_id, cat_id, goods_name, shop_price
FROM ecs_goods
-- 查询各类商品最高价格的名称
SELECT goods_id, ecs_goods.cat_id, goods_name, shop_price
FROM (
SELECT cat_id, MAX(shop_price) AS max_price
FROM ecs_goods
GROUP BY cat_id
) temp, ecs_goods
WHERE temp.cat_id = ecs_goods.cat_id
AND temp.max_price = ecs_goods.shop_price
```

- 在多行子查询中使用all操作符

```mysql
-- 查询显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号
SELECT ename, sal, deptno
FROM emp
WHERE sal > ALL(
SELECT sal FROM emp WHERE deptno = 30
);
-- 等效于
SELECT ename, sal, deptno
FROM emp
WHERE sal > (
SELECT MAX(sal) FROM emp WHERE deptno = 30
);
```

- 在多行子查询中使用any操作符

```mysql
-- 查询显示工资比部门30的任意一个员工的工资高的员工的姓名、工资和部门号
SELECT ename, sal, deptno
FROM emp
WHERE sal > ANY(
SELECT sal FROM emp WHERE deptno = 30
);
-- 等效于
SELECT ename, sal, deptno
FROM emp
WHERE sal > (
SELECT MIN(sal) FROM emp WHERE deptno = 30
);
```

- 多列子查询

多列子查序则是指查询返回多个列数据的子查询语句

```mysql
-- 查询与smith的部门和岗位完全相同的所有雇员(并且不含smith本人)
-- 1. 获得smith的部门和岗位
SELECT deptno, job
FROM emp
WHERE ename = 'SMITH';
-- 2. 把上摸按的查询当作子查询使用，并且使用多列子查询的语法进行匹配
SELECT * FROM emp
WHERE (deptno, job) = (
SELECT deptno, job
FROM emp
WHERE ename = 'SMITH'
) AND ename != 'SMITH'
```

- 在from子句中使用子查询

```mysql
-- 查询工资大于平均工资的员工
-- 1.得到部门的号码 和 对应的平均工资
SELECT deptno, AVG(sal)
FROM emp GROUP BY deptno;
-- 2.把上面的结果当作子查询，进行多表查询
SELECT ename, sal, temp.avg_sal, emp.deptno
FROM emp, (
SELECT deptno, AVG(sal) AS avg_sal
FROM emp
GROUP BY deptno
) temp
WHERE emp.deptno = temp.deptno AND emp.sal > temp.avg_sal;
-- 查询各部门工资最高的员工
SELECT ename, sal, temp.max_sal, emp.deptno
FROM emp, (
SELECT deptno, MAX(sal) AS max_sal
FROM emp
GROUP BY deptno
) temp
WHERE emp.deptno = temp.deptno AND emp.sal = temp.max_sal;
```

```mysql
-- 查询每个部门的信息(包括: 部门名,编号,地址)和人员数量
-- 1. 获取各部门的人数 - 临时表
SELECT COUNT(*), deptno
FROM emp
GROUP BY deptno
-- 2. 子查询
SELECT dname, dept.deptno, loc, tmp.per_num
FROM dept, (
SELECT COUNT(*) AS per_num, deptno
FROM emp
GROUP BY deptno
) tmp
WHERE tmp.deptno = dept.deptno;
-- 等效于
-- 表名.* 表示该表的所有列
SELECT tmp.*, dname, loc
FROM dept, (
SELECT COUNT(*) AS per_num, deptno
FROM emp
GROUP BY deptno
) tmp
WHERE tmp.deptno = dept.deptno;
```

#### 表的复制

##### 蠕虫复制

- 自我复制数据(蠕虫复制)

为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据。

```mysql
--直接自我复制
-- 创建-生成表
CREATE TABLE my_tab01
( id INT,
`name` VARCHAR(32),
sal DOUBLE,
job VARCHAR(32),
deptno INT);

DESC my_tab01

INSERT INTO my_tab01
(id, `name`, sal, job, deptno)
SELECT empno, ename, sal, job, deptno FROM emp;
-- 自我复制
INSERT INTO my_tab01
SELECT * FROM my_tab01;
```

```mysql
-- 删除表中重复的记录
CREATE TABLE my_tab02 like emp; -- 复制emp表的结构
desc my_tab02
INSERT INTO my_tab02 SELECT * FROM emp;-- 复制表里的内容
SELECT * FROM my_tab02;

-- 创建临时表
-- distinct关键字去重复
-- 原表所有记录
-- 把临时表的结果复制过来
-- drop掉临时表
CREATE TABLE my_tmp LIKE my_tab02;
INSERT INTO my_tmp SELECT DISTINCT * FROM my_tab02;
DELETE FROM my_tab02;
INSERT INTO my_tab02 SELECT * FROM my_tmp;
DROP TABLE my_tmp;
```

#### 合并查询

- 基本介绍

有时在实际应用中，为了合并多个select语句的结果，可以使用集合操作符号union , union all

1. union all

该操作符用于取得两个结果集的并集。当使用该操作符时，不会取消重复行。

```mys
SELECT ename, sal, job FROM emp WHERE sal < 2500
UNION ALL
SELECT ename, sal, job FROM emp WHERE job = 'CLERK';
```

2. union

该操作赋与union all 相似，但是会自动去掉结果集中重复行。

```mysql
SELECT ename, sal, job FROM emp WHERE sal < 2500
UNION
SELECT ename, sal, job FROM emp WHERE job = 'CLERK';
```

#### 外连接**

- 问题引出

1. 前面我们学习的查询，是利用 where 子句对两张表或者多张表，形成的笛卡尔积进行筛选，根据**关联条件**，显示所有匹配的记录，匹配不上的，不显示
2. 比如: 列出部门名称和这些部门的员工名称和工作，同时要求 显示出那些**没有员工的部门**。
3. 没有员工的的部门在两个表之间没有连接 -引出> 外连接
3. 通常的开发情况还是内连接

```mysql
-- 左外连接
SELECT dname, ename, job
FROM dept LEFT JOIN emp
ON dept.deptno = emp.deptno
-- 右外连接
SELECT dname, ename, job
FROM emp RIGHT JOIN dept
ON dept.deptno = emp.deptno
```

- 外连

1. 左外连接:(如果**左侧**的表**完全显示**我们就说是左外连接)
2. 右外连接:(如果**右侧**的表**完全显示**我们就说是右外连接)

```mys
-- 创建stu表
CREATE TABLE stu (
id INT,
`name` VARCHAR(32)
);
INSERT INTO stu VALUES
(1, 'jack'), (2, 'tom'), (3, 'kity'), (4, 'nono');
SELECT * FROM stu;
-- 创建exam表
CREATE TABLE exam(
id INT,
grade INT
);
INSERT INTO exam VALUES
(1, 56), (2, 78), (11, 26);
```

3. 左连接-要求：使用左连接(显示所有人的成绩，如果没有成绩，也要显示该人的姓名和id号,成绩显示为空)

```mysql
-- 只能显示有成绩的人
SELECT `name`, stu.id, grade
FROM stu, exam
WHERE stu.id = exam.id;
-- 左外连接
select .. from 表1 left join 表2 on 筛选条件
-- 左表存在和右表没有匹配的记录，也会显示左表的记录
SELECT `name`, stu.id, grade
FROM stu LEFT JOIN exam
ON stu.id = exam.id;
```

4. 右连接-要求：使用右外连接(显示所有成绩，如果没有名字匹配，显示空)

```ms
-- 右表存在和左表没有匹配的记录，也会显示右表的记录
SELECT `name`, stu.id, grade
FROM stu RIGHT JOIN exam
ON stu.id = exam.id;
```

### 函数**

#### 统计函数

- 常用方法

1. Count 返回行的总数、

```mysql
Select count(*)|count(列名) from tablename
[WHERE where_definition]
#统计总人数
SELECT COUNT(*) FROM student;# 满足条件的总行数
SELECT COUNT(*) FROM student WHERE math > 90;
# count(*) 刊 count(y)X列
# 解释 :count(*) 返回满足条件的记录的行数
# count(列名): 统计满足条件的某列有多少行，但是会排除为null的情况
CREATE TABLE t15(
`name` VARCHAR(10)
);
INSERT INTO t15 VALUES('tom');
INSERT INTO t15 VALUES('jack');
INSERT INTO t15 VALUES('mary');
INSERT INTO t15 VALUES(NULL);
SELECT COUNT(`name`) FROM t15;
SELECT COUNT(*) FROM t15;
```

2. sum函数:返回满足where条件的行的和- 一般使用在**数值列**

```mysql
Select sum(列名) {,sum(列名}... from tablename
[WHERE where_definition]
# 数学总分
SELECT SUM(math) FROM student;
SELECT SUM(math) AS math_total, SUM(chinese) AS chinese_total FROM student;
# 语文平均分
SELECT SUM(chinese)/COUNT(*) FROM student;
```

3. avg平均值

```mysql
select avg(列) {,avg(列名)...} from tablename
[WHERE where definition]
#
SELECT AVG(math) FROM student;
SELECT AVG(math + english + chinese) FROM student;
```

4. Max/Min

```mysql
SELECT MAX(math) FROM student;
SELECT MAX(math + english + chinese), MIN(math + english + chinese) FROM student;
```

#### 字符串函数

- 字符串相关函数

1. 返回字串字符集 CHARSET(str)
2. 连接字串 CONCAT (string2 [.... ])
3. 返回substring在string中出现的位置,没有返回0 INSTR (string ,substring)
4. 转换成大写 UCASE (string2)
5. 转换成小写 LCASE (string2)
6. 从string2中的左边起取length个字符 LEFT (string2 ,length)
7. string长度[按照字节] LENGTH (string)
8. 在str中用replace str替换search str  REPLACE (str, search_str, replace_str)
9. 逐字符比较两字串大小 STRCMP (string1 ,string2) ascll码比较
10. 从str的position开始[从1开始计算],取length个字符 SUBSTRING (str , position [,length])
11. 去除前端空格或后端空格 LTRIM (string2)-去除左边的空格 RTRIM-去除右边的空格 (string2) trim-去除两端的空格

```mysql
# 返回字符集
SELECT CHARSET(ename) FROM emp;
# 拼接字符串
SELECT CONCAT(ename,'job is ', job) FROM emp;
# idxof
SELECT INSTR('imhappy', 'happy');
SELECT INSTR('imhappy', 'happy') FROM DUAL;# DUAL 亚元表/系统表 测试用
# 大小写转换
SELECT UCASE(ename) FROM emp;
SELECT LCASE(ename) FROM emp;
# 取字符
SELECT LEFT(ename, 2) FROM emp;
SELECT RIGHT(ename, 2) FROM emp;
# 返回字节长度
SELECT LENGTH(ename) FROM emp;
# 替换
SELECT LENGTH(ename) FROM emp;
SELECT ename, REPLACE(job,'MANAGER','经理') FROM emp;
# 比较字符
SELECT STRCMP('zyp','syj');
# 截取字符串
SELECT SUBSTRING(ename,2,2) FROM emp;#从1开始
# 去除空格
SELECT LTRIM('  xixi ');
SELECT RTRIM(' xixi  ');
SELECT TRIM('  xixi  ');
# 练习
SELECT CONCAT(LCASE(SUBSTRING(ename, 1, 1)), SUBSTR(ename,2)) FROM emp;
```

#### 数学函数

- 数学相关函数

1. 绝对值 ABS(num)
2. 十进制转二进制 BIN (decimal number)
3. 向上取整，得到比num2 大的最小整数 CEILING (number2 )
4. 进制转换 CONV (number2,from_base,to_base)
5. 向下取整,得到比 num2 小的最大整数 FLOOR (number2 )
6. 保留小数位数 FORMAT(number,decimal_places)
7. 转十六进制 HEX (DecimalNumber)
8. 求最小值 LEAST (number, number2 [...])
9. 求余 MOD (numerator ,denominator)
10. RAND([seed])其范围为 0<=v<=1.0  RAND([seed])

```mys
-- 绝对值
SELECT ABS(-10) FROM DUAL;
-- 二进制
SELECT BIN(10) FROM DUAL;
-- 向上取整-比x大的最小整数
SELECT CEILING(3.14) FROM DUAL;
-- 进制转换
SELECT CONV(8,10,4);--8从10进制转换为4进制
-- 向下取整--小于x的最大整数
SELECT FLOOR(-4.4);
-- 保留小数位数
SELECT FORMAT(78.123456789,2) FROM DUAL;
-- 最小值
SELECT LEAST(0.1,-10,101);
-- 余数
SELECT MOD(10, 3);
-- 返回随机数--设置种子返回固定随机数
SELECT RAND();
SELECT RAND(100);
```

#### 日期函数

- 日期相关函数

1. 当前日期 CURRENT_DATE ()
2. 当前时间 CURRENT_TIME ()
3. 当前时间戳 CURRENT_TIMESTAMP ()
4. 返回datetime的日期部分 DATE(datetime)
5. 在date2中加上日期或时间 DATE ADD (date2, INTERVAL d_value d_type)
6. 在date2上减去一个时间 DATE SUB (date2, INTERVAL d_value d_type )
7. 两个日期差(结果是天) DATEDIFF (date1 ,date2)
8. 两个时间差(多少小时多少分钟多少秒)  TIMEDIFF(datel,date2)
9. 当前时间 NoW ()
10. 年月日 YEAR|Month|DATE (datetime) FROM UNIXTIMEO

```mysql
-- 查询当前日期
SELECT CURRENT_DATE() FROM DUAL;
-- 查询当前时间
SELECT CURRENT_TIME() FROM DUAL;
-- 当前时间戳
SELECT CURRENT_TIMESTAMP() FROM DUAL;
--
CREATE TABLE mes(
id INT,
content VARCHAR(30),
send_time DATETIME
);
INSERT INTO mes
VALUES(1, '北京新闻', CURRENT_TIMESTAMP());
```

```mysql
-- 现在的日期和时间
SELECT NOW() FROM DUAL;
-- 
INSERT INTO mes
VALUES(1, '北京新闻', CURRENT_TIMESTAMP()),
(2, '四川新闻', NOW()),
(3, '重庆新闻', NOW());
--只显示日期不显示时间
SELECT id, content, DATE(send_time) FROM mes;
-- 显示20分钟内的消息
SELECT * FROM mes WHERE DATE_ADD(send_time,INTERVAL 20 MINUTE) >= NOW();
-- 查看日期相差的天数
SELECT DATEDIFF('2011-11-11','1990-01-01') FROM DUAL;
SELECT DATEDIFF(DATE_ADD('2000-01-31',INTERVAL 80 YEAR),'2000-01-31') FROM DUAL;
-- 时间差
SELECT TIMEDIFF('10:11:11',CURRENT_TIME);
```

```mysql
-- 单独获取年月日
SELECT YEAR(NOW()) FROM DUAL;
SELECT MONTH(NOW()) FROM DUAL;
SELECT DAY(NOW()) FROM DUAL;
SELECT MONTH('2011-11-12');
SELECT MONTH('2011-11-12 11:01:31');
-- 1970-1-1到现在的毫秒数
-- 把毫秒时间/UNIX_TIMESTAMP转换为格式化时间
-- 实际开发中常用int保存unix时间戳
SELECT UNIX_TIMESTAMP() FROM DUAL;
SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y-%m-%d') FROM DUAL;
SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y-%m-%d %H:%i:%s') FROM DUAL;
SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y') FROM DUAL;
```

#### 加密函数/系统函数

- 常用函数

1. 查询用户 USER()
2. 数据库名称 DATABASE()
3. 为字符串算出一个 MD5码 32的字符串，(用户密码)加密 MD5(str)

4. 从原文密码str 计算并返回密码字符串,通常用于对mysql数据库的用户密码加密 PASSWORD(str)
   select * from mysql.user \G

```mysql
-- 查询使用用户
SELECT USER();
-- 查询当前数据库的名称
SELECT DATABASE();
-- MD5码
SELECT MD5('zyp') FROM DUAL;

CREATE TABLE user_md5(
id INT,
`name` VARCHAR(32) NOT NULL DEFAULT '',
pwd char(32) NOT NULL DEFAULT '');
INSERT INTO user_md5 VALUES(100, 'Meez', MD5('123456'));
SELECT * FROM user_md5;
SELECT * FROM user_md5 WHERE `name` = 'Meez' AND pwd = MD5('123456');
-- password() -- mysql用户密码的加密方式
SELECT PASSWORD('123456');
-- 数据库.表 查询信息
SELECT * FROM mysql.`user`;
```

#### 流程控制函数

- 常用流程控制函数

1. IF(expr1,expr2,expr3) 如果expr1为True,则返回 expr2 否则返回expr3
2. IFNULL(expr1,expr2) 如果expr1 不为空NULL，则返回expr1，否则返回expr2
3. SELECT CASE WHEN expr1 THEN expr2 WHEN expr3 THEN expr4 ELSE expr5 END;[类似多重分支]   如果expr1 为TRUE，则返回expr2，如果expr2为TRUE，返回 expr4，否则返回 expr5

```mysql
-- IF 语句
SELECT IF(TRUE,'成都','重庆');
-- IFNULL 语句
SELECT IFNULL('not NULL', 'NULL');
SELECT IFNULL(NULL, 'NULL_sec');
-- 为空就置为0 -- 判断是否位NULL要用 IS NULL
SELECT ename, IF(comm IS NULL, 0, comm)
FROM emp;
SELECT ename, IFNULL(0, comm)
FROM emp;
-- 多分支语句
SELECT ename, (SELECT CASE 
	WHEN job = 'CLERK' THEN '职员'
		WHEN job = 'MANAGER' THEN '经理'
		WHEN job = 'SALESMAN' THEN '销售'
	ELSE job END) AS 'job'
FROM emp;
```



### 约束

- 基本结束

**约束**用于确保数据库的数据满足特定的商业规则。在mysql中，约束包括: not null,unique,primary key,foreign key和check五种。

#### primary key(主键)

- 基本使用

```mysql
-- 语法
字段名 字段类型 primary key
-- 
CREATE TABLE t17
(
id INT PRIMARY KEY,
`name` VARCHAR(32),
email varchar(32)
);
-- 主键列的值不可以重复
INSERT INTO t17 
VALUES(1, 'jack', 'jack@qq.com');
INSERT INTO t17 
VALUES(1, 'tom', 'tom@qq.com');
-- 查看 primary key
DESC t17
```

- 使用细节

1. primary key**不能重复**而且**不能为null**。
2. 一张表最多只能有一个主键，但可以是**复合主键**
3. 主键的指定方式有两种
   - 直接在字段名后指定: 字段名 primakry key
   - 在表定义最后写 primary key(列名);

4. 使用desc表名，可以看到primary key的情况
5. 实际开发中，每个表都有设计主键

```mysql
-- 复合主键
CREATE TABLE t18
(
id INT,
`nmae` VARCHAR(32),
email VARCHAR(32),
PRIMARY KEY (id, `nmae`)
);

DESC t18
-- 此时id和`nmae`同时相同才违反主键规则
```

#### not null(非空)

如果在列上定义了not null,那么当插入数据时，必须为列提供数据。

```mysql
字段名 字段类型 not null
CREATE TABLE t18
(
id INT NOT NULL,
`nmae` VARCHAR(32),
email VARCHAR(32),
PRIMARY KEY (id, `nmae`)
);
```

#### unique(唯一)

当定义唯一约束后，该列值是不能重复的(除了NULL)。

```mysql
字段名 字段类型 unique

CREATE TABLE t19
(
id INT UNIQUE,
`nmae` VARCHAR(32),
email VARCHAR(32)
);
INSERT INTO t19 VALUES(1, 'tom', 'tom@qq.com');
INSERT INTO t19 VALUES(1, 'jack', 'jack@qq.com');
```

- unique注意细节

1. 如果没有指定 not null，则 unique 字段可以有多个null。可以使用unique not null 进行限制。
2. 一张表可以有多个unique字段

#### foreign key(外键)

- 基本说明

用于定义**主表**和**从表**之间的关系: 外键约束要定义在从表上，主表则必须具有主
键约束或是unique约束.当定义外键约束后，要求外键列数据必须在主表的主
键列存在或是为null(学生/班级 示意图)

<img src=".\Java入门markdown图片\外键约束.png" alt="外键约束" style="zoom:50%;" />

```mysql
FOREIGN KEY (本表字段名) REFERENCES 主表名
```

```mysql
CREATE TABLE my_class(
id INT PRIMARY KEY,
`name` VARCHAR(32) NOT NULL DEFAULT ''
);

CREATE TABLE my_stu(
id INT PRIMARY KEY,
`name` VARCHAR(32) NOT NULL DEFAULT '',
class_id INT,
FOREIGN KEY (class_id) REFERENCES my_class(id)
);

INSERT INTO my_class VALUES(100, 'java'), (200, 'web');

INSERT INTO my_stu VALUES(1, 'tom', 100);
INSERT INTO my_stu VALUES(2, 'jack', 200);
INSERT INTO my_stu VALUES(3, 'joe', 300); -- 失败，不存在300班级
```

- 使用细节

1. 外键指向的表的字段，要求是primary key 或者是unique
2. 表的类型是**innodb**，这样的表才支持外键
3. 外键字段的**类型**要和主键字段的**类型一致**(长度可以不同)
4. 外键字段的值，必须在主键字段中**出现过**，或者**为null** [前提是外键字段允许为null]
5. 一旦建立主外键的关系，数据不能随意删除了，进行外键约束的数据不能直接删。需要把副表中指向主表某一行数据的所有数据删除，才能删除该主表的行。

#### check

- 基本说明

1. 用于强制行数据必须满足的条件,假定在sal列上定义了check约束,并要求sal列值在1000~2000之间如果不再1000~2000之间就会提示出错。
2. 提示:oracle 和 sql server 均支持check ,但是mysql5.7目前还不支持check,只做语法校验，但不会生效。

```mysql
列名 类型 check (check条件)
```

```mysql
-- 生效测试 - 5.7版本不生效
-- oracle 和 sql server 支持
CREATE TABLE t23 (
id INT PRIMARY KEY,
`name` VARCHAR(32),
sex VARCHAR(6) CHECK (sex IN('man', 'woman')),
sal DOUBLE CHECK (sal > 1000 AND sal < 2000)
);

INSERT INTO t23 VALUES(1, 'jack', 'mid', 1);
SELECT * FROM t23;
```

- 约束综合作业

```mysql
-- 创建商品表
CREATE TABLE goods (
goods_id INT PRIMARY KEY,
goods_name varchar(64) NOT NULL DEFAULT '',
unitprice DECIMAL(10, 2) NOT NULL DEFAULT 0
CHECK (unitprice >= 1.0 AND unitprice <= 9999.99),
category INT NOT NULL DEFAULT 0,
provider VARCHAR(64) NOT NULL DEFAULT ''
);
-- 客户表
CREATE TABLE customer(
customer_id CHAR(8) PRIMARY KEY,
`name` VARCHAR(64) NOT NULL DEFAULT '',
address VARCHAR(64) NOT NULL DEFAULT '',
email VARCHAR(64) UNIQUE NOT NULL,
sex ENUM('男', '女') NOT NULL,
-- 这里老师使用的枚举类型，可以生效
card_id CHAR(18));
-- 购买表
CREATE TABLE purchase (
order_id INT UNSIGNED PRIMARY KEY,
customer_id CHAR(8) NOT NULL DEFAULT '', -- 外键约束在后
goods_id INT NOT NULL DEFAULT 0, -- 外键约束在后
nums INT NOT NULL DEFAULT 0,
FOREIGN KEY (customer_id) REFERENCES customer(customer_id),
FOREIGN KEY (goods_id) REFERENCES goods(goods_id));
```

#### 自增长

- 基本介绍

在某张表中，存在一个id列(整数)，我们希望在添加记录的时候该列从1开始，自动的增长，怎么处理?

```mysql
字段名 整型 primary key auto_increment
```

```mysql
CREATE TABLE t24 (
id INT PRIMARY KEY AUTO_INCREMENT,
email VARCHAR(32) NOT NULL DEFAULT '',
`name` VARCHAR(32) NOT NULL DEFAULT ''
);
DESC t24;
INSERT INTO t24 VALUES(NULL, 'tom@qq.com', 'tom');
INSERT INTO t24 VALUES(NULL, 'jack@qq.com', 'jack');
INSERT INTO t24 (email, `name`) VALUES('john@qq.com', 'john');
INSERT INTO t24 VALUES(666, 'Max@qq.com', 'Max');
INSERT INTO t24 VALUES(NULL 'test@qq.com', 'tset');
SELECT * FROM t24;
```

- 使用细节

1. 一般来说自增长是和**primary key** 配合使用的
2. 自增长也可以单独使用[但是需要配合一个**unique**]
3. 自增长修饰的字段为**整数型**(虽然小数也可以但是非常非常少这样使用)
4. 自增长**默认从 1开始**，你也可以通过如下命令修改

alter table 表 auto increment = xxx -- 修改自增长的开始值

5. 若赋值时指定了自增长的值，也可以成立，后面的值以该值开始自增长(通常不这样使用)

### 索引**

- 索引的原理

1. 当表内不存在索引的时候，会进行全表遍历查找，找到目标数据还是会继续遍历整个表，速度慢，时间复杂度O(N)
2. 索引结构--引入高效的数据结构--如：创建搜索二叉树
   - 磁盘占用
   - 对dml(update delete insert)语句的效率影响
     一般的项目中select[90%] 比其他操作多很多，update,delete,insert 

- 索引的类型

1. 主键索引，主键自动的为主索引(类型Primary key)

某个列被设置为主键，他就是主键索引。

2. 唯一索引(UNIQUE)

某个列被设置为UNIQUE，他就是UNIQUE索引。

3. 普通索引(INDEX)

4. 全文索引(FULLTEXT)[适用于MyISAM]

一般开发，不使用mysql自带额全文索引，而是使用 :全文搜索Solr和 ElasticSearch (ES)

- 索引使用

1. 添加索引

```mysql
-- 基本语法
create [UNIQUE] index index_name on tbl_name (col_name [(length)]
[ASC | DESC], .....);
-- 
alter table table_name ADD INDEX [index name] (index_col_name,...)
```

```mysql
-- 方式1--创建表的时候添加
-- 方式2--对创建好的表进行添加

-- 创建表
CREATE TABLE t25(
id INT,
`name` VARCHAR(32)
);
-- 查询是否有索引
SHOW INDEX FROM t25;
-- 添加唯一索引
CREATE UNIQUE INDEX id_idx on t25 (id);
-- 添加普通索引1
CREATE INDEX id_idx1 on t25 (id);
-- 添加普通索引2
ALTER TABLE t25 ADD INDEX id_idx2 (id);
-- 如何选择
-- 1.如果某列的值，是不会重复的，则优先考虑使用unique索引，否则使用普通索引

-- 添加主键索引
ALTER TABLE t25 ADD PRIMARY KEY (id);
```

2. 删除索引

```mysql
-- 查询是否有索引
SHOW INDEX FROM t25;
-- 删除索引
DROP INDEX id_idx ON t25;
-- 删除主键索引
ALTER TABLE t25 DROP PRIMARY KEY;
-- 修改索引，删除再添加
```

3. 查询索引

```mysql
-- 查询索引1
SHOW INDEX FROM t25;
-- 查询索引2
SHOW INDEXES FROM t25;
-- 查询索引3
SHOW KEYS FROM t25
-- 查询索引4
DESC t25;
```

- 小结-适合创建索引的字段

1. **较频繁的作为查询条件**字段应该创建索引
   select * from emp where empno = 1
2. **唯一性太差**的字段**不适合**单独创建索引，即使频繁作为查询条件
   select * from emp where sex = ''男'
3. **更新非常频繁**的字段**不适合创建索引**
   select * from emp where logincount = 1
4. **不会出现**在**WHERE子句**中字段不该创建索引

### 事务

- 什么是事务

事务用于保证数据的一致性,它由**一组相关的dml语句(增删改)组成**,该组的dml语句要么全部成功，要么全部失败。如:转账就要用事务来处理，用以保证数据的一致性。

- 事务和锁

当执行事务操作时(dml语句),mysql会在表上加锁,防止其它用户改表的数据。这对用户非常重要。

#### 事务的重要操作

1. start transaction -- 开始一个事务
2. savepoin!保存点名 -- 设置保存点
3. rollback to 保存点名 -- 回退事务
4. rollback -- 回退全部事务
5. commit -- 提交事务所有的操作生效,不能回退

<img src=".\Java入门markdown图片\事务的操作流程示意图.png" alt="事务的操作流程示意图" style="zoom:50%;" />

```mysql
-- 1. 创建表
CREATE TABLE t27(
id INT,
`name` VARCHAR(32));
-- 2.开始事务
START TRANSACTION
-- 3.设置保存点
SAVEPOINT a;
-- 执行dml 操作
INSERT INTO t27 VALUES(100, 'tom');
SELECT * FROM t27;
SAVEPOINT b;
-- 执行dm1操作
INSERT INTO t27 VALUES(200, 'jack');

-- 回退到b
ROLLBACK TO b;
-- 回退到a
ROLLBACK TO a;

-- 执行commit会保存前面的操作-并删除所有的保存点
```

- 回退事务

1. 保存点是事务中的点.用于取消部分事务,当结束事务时,会自动的删除该事务所定义的所有保存点.
2. 当执行回退事务时，通过指定保存点可以回退到指定的点.
3. 从某一点c回退到某保存点a,a-c中间的点都会被删除

- 提交事务

1. 使用commit语句可以提交事务.当执行了commit语句子后,会确认事务的变化、结束事务、删除保存点、释放锁，数据生效。当使用commit语句结束事务子后，其它会话将可以查看到事务变化后的新数据。

- 事务细节套路

1. 如果不开始事务，**默认情况**下，dml操作是自动提交的，**不能回滚**
2. 如果开始一个事务，你**没有创建保存点**.你可以执行 rollback，默认就是**回退到**事务**开始的状态**.
3. 你也可以在这个事务中(还没有提交时),创建多个保存点.比如: savepoint aaa; 执行 dml, savepoint bbb;
4. 你可以在事务没有提交前，选择回退到哪个保存点。
5. mysql的事务机制需要**innodb的存储引擎**还可以使用,myisam不支持。
6. 开始一个事务 start transaction, set autocommit = off;

#### 隔离级别**

- 基本介绍

1. **多个连接**开启各自事务操作数据库中数据时，数据库系统要负责**隔离**操作，以保证各个连接在获取数据时的**准确性**。(通俗解释)
2. 如果不考虑隔离性，可能会引发如下问题:
   - 脏读(dirty read)：当一个事务读取另一个事务尚未提交的修改时，产生脏读
   - 不可重复读(nonrepeatable read)：同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生不可重复读
   - 幻读 (phantom read): 同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读。

- 事务隔离界别

Mysql隔离级别定义了事务与事务之间的隔离程度。

![事务隔离级别](.\Java入门markdown图片\事务隔离级别.png)

- 案例演示

```mysql
-- 演示mysql事务的隔离级别
-- 1. 开了两个mysql的控制台

-- 2. 查询mysql的隔离级别
SELECT @@tx_isolation;

+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+

-- 3. 把其中一个控制台的隔离级别设置 Read uncommitted
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 4. 启动事务-隔离级别是跟事务相关的概念
START TRANSACTION;


-- 创建表
use 约束测试;

CREATE TABLE `account`(
id INT,
`name` VARCHAR(32),
money INT
);

SELECT * FROM account;

INSERT into account 
VALUES(1, 'tom', 1000);
-- 该事务该没提交-另一个终端已经可以查询该数据--脏读

-- 修改和插入
UPDATE account set money = 800 WHERE id = 1;
INSERT into account VALUES(2, 'jack', 2000);
-- 不可重复读和幻读

-- 一个终端设置为读已提交
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT @@tx_isolation; -- 查看
-- 另一个添加
INSERT into account VALUES(4, 'Chow', 22000);
-- 此时无法查看
```

```mysql
-- 可重复读
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 一个表修改
update account set money = 2600 where id = 4;
-- 可串行化
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

INSERT into account VALUES(5, 'TIM', 1333000);
-- 此时无法查看-会等待前面的操作直到COMMIT
```

- 设置隔离级别

```mysql
-- 1. 查看隔离级别
SELECT @@tx_isolation;
-- 2. 查看系统当前隔离级别
SELECT @@GLOBAL.tx_isolation;
-- 3. 设置当前会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 4.设置系统当前隔离级别
SET GLOBAL SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 5. mysql 默认的事务隔离级别是 repeatable read,一般情况下，没有特殊要求，没有必要修改 (因为该级别可以满足绝大部分项目需求)

-- 6. 修改默认隔离级别
-- 全局修改，修改my.ini配置文件，在最后加上
-- 可选择参数：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.
-- 默认REPEATABLE-READ
-- [mysqld]
-- transaction-isolation = REPEATABLE-READ
```



#### ACID

- 事务的ACID特性

1. **原子性**(Atomicity)：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要
   么都不发生。
2. **一致性** (Consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
3. **隔离性** (lsolation)：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事
   务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
4. **持久性** (Durability)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的
   接下来即使数据库发生故障也不应该对其有任何影响。

### 表类型和存储引擎

- 基本介绍

1. MySQL的表类型由存储引擎 (Storage Engines) 决定，主要包括MyISAM、innoDB、Memory等.
2. MySQL 数据表主要支持六种类型 ，分别是: CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、InnoBDB.
3. 这六种又分为两类，一类是”**事务安全型**”(transaction-safe)，比如:lnnoDB; 其余都属于第二类，称为”**非事务安全型**”(non-transaction-safe)[mysiam 和 memoryl].

- 主要的存储引擎/表类型的特点

![主要存储引擎的特点](.\Java入门markdown图片\主要存储引擎的特点.png)

```mysql
-- 查看存储引擎
SHOW ENGINES
```

- 细节说明

重点介绍三种: MyISAM、InnoDB、MEMORY

1. MyISAM**不支持事务、也不支持外键**，但其访问速度快，对事务完整性没有要求
2. lnnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，lnnoDB写的处理效率差一些并且会占**用更多的磁盘空间**以保留数据和索引。
3. MEMORY存储引擎使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的**数据是放在内存**中的，并且默认使用HASH索引。但是一旦**服务关闭**，表中的**数据**就会**丢失**,表的结构还在。

```mysql
-- innodb 存储引擎，前面使用过
-- 1.支持事务 2.支持外键 3.支持行级锁

-- myisam存储引擎
-- 1.添加速度快 2.不支持外键和事务 3.支持表级锁
CREATE TABLE t28(
id INT,
`name` VARCHAR(32)
) ENGINE MYISAM;
START TRANSACTION;
SAVEPOINT t1;
INSERT INTO t28 VALUES(1, 'jack');
SELECT * FROM t28;
ROLLBACK to t1;
-- 回滚失效

-- memory 存储引擎
-- 1.数据存储在内存中(关闭了mysq1服务，数据丢失，但是表结构还在) 2.执行速度很快(没有IO读写) 3.默认支持索引(hash表)
-- 适用于反复修改的数据
CREATE TABLE t29 (
id INT,
`name` VARCHAR(32)
) ENGINE MEMORY;
INSERT INTO t29 VALUES(1, 'tom'), (2, 'jack'), (3, 'hsp');
SELECT * FROM t29;
DESC t29;

-- 修改存储引擎
ALTER TABLE t29 engine = INNODB;
```

### 视图

- 一个需求

不同的用户，查看数据的内容是有区别的

- 基本概念

1. 视图是一个**虚拟表**，其内容由查询定义。
2. 同真实的表一样，视图包含列,其**数据**来自对应的**真实表(基表)**
3. 基表和视图的修改会互相修改/影响

- 视图的基本使用

1. create view 视图名 as select语句
2. alter view 视图名 as select语句
3. SHOW CREATE VIEW 视图名
4. drop view 视图名1视图名2

```mysql
-- 创建视图
CREATE VIEW emp_view01
AS
SELECT empno, ename, job, deptno FROM emp;
-- 查看视图
DESC emp_view01;
SELECT * FROM emp_view01;
-- 修改基表 -> 影响视图
UPDATE emp SET job = 'manager'
WHERE empno = 7369;
-- 可以使用视图再创建视图 - 数据来源均为基表
CREATE VIEW emp_view02
AS
SELECT empno, ename FROM emp_view01;
SELECT * FROM emp_view02;
```

- 视图最佳实现

1. 安全。一些数据表有着重要的信息。有些字段是保密的，不能让用户直接看到。这时就可以创建一个视图，在这张视图中只保留一部分字段。这样，用户就可以查询自己需要的字段，不能查看保密的字段。
2. 性能。关系数据库的数据常常会分表存储，使用外键建立这些表的之间关系。这时数据库查询通常会用到连接 (JOIN)。这样做不但麻烦，效率相对也比较低。如果建立一个视图，将相关的表和字段组合在一起，就可以避免使用JOIN查询数据。
3. 灵活。如果系统中有一张旧的表，这张表由于设计的问题，即将被废弃。然而，很多应用都是基于这张表，不易修改。这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。

- 案例演示--多表视图

```mysql
CREATE VIEW emp_view03
AS 
SELECT empno, ename, dname, grade
FROM emp, dept, salgrade
WHERE emp.deptno = dept.deptno AND
(sal BETWEEN losal and hisal);
DESC emp_view03;
SELECT * FROM emp_view03;
```

### MYSQL管理

#### MYSQL用户

- MYSQL的用户

mysql中的用户都存储在系统数据库mysql中 user 表中

- user表的重要字段

1. host:允许登录的“位置”，localhost表示该用户只允许本机登录，也可以指定ip地址，比如:192.168.1.100
2. user:用户名:
3. authentication_string: 密码，是通过mysql的password0函数加密之后的密码。

- 常用操作

1. 创建用户

create user **'用户名' @ '允许登录位置'** identified by '密码'
说明: 

- 创建用户，同时指定密码;
- **@左右不能有空格**，用户名和登录地址是一个整体
- 不同用户根据权限可以操作和查看的表不同

2. 删除用户

drop user  '用户名' @ '允许登录位置'' ;

```mysql
-- 1.创建用户
-- 'localhost'为登录地址
-- '123456'为加密前的密码
CREATE USER 'zyp_edu'@'localhost' IDENTIFIED BY '123456';
SELECT * FROM mysql.user;

-- 2.删除用户
DROP USER 'zyp_edu'@'localhost'

-- 3.修改密码
-- 自己的密码
SET PASSWORD = PASSWORD('abcdef');
-- 修改别人的密码(需要权限)
SET PASSWORD FOR 'zyp_edu'@'localhost' = PASSWORD('abcdef');
```

#### 管理权限

- 基本权限

![mysql权限](.\Java入门markdown图片\mysql权限.png)

- 给用户授权

1. 基本语法

```mysql
-- 基本语法
grant 权限列表 on 库.对象名 to 用户名’@’登录位置 [identified by '密码']
```

2. 说明

```mysql
-- 1. 权限列表，多个权限用逗号分开
grant select on .......
grant select, delete, create on ....
grant all [privileges] on ..... //表示赋予该用户在该对象上的所有权限
-- 2. 特别说明
*.*:代表本系统中的所有数据库的所有对象(表，视图，存储过程)
库.*:表示某个数据库中的所有数据对象(表，视图，存储过程等)
-- 3. identified by可以省略，也可以写出
(1)如果用户存在，就是修改该用户的密码
(2)如果该用户不存在，就是创建该用户!
-- 4. 回收用户授权
revoke 权限列表 on 库对象名 from 用户名"@"登录位置;
-- 5. 权限生效指令
FLUSH PRIVILEGES; -- MYSQL5.7赋值就生效
```

- 案例演示

```mysql
-- 创建用户
CREATE USER 'Meez_edu'@'localhost' IDENTIFIED BY '123456';
-- root用户创建表
CREATE DATABASE testdbx;
CREATE TABLE news (
id INT,
content VARCHAR(32)
);
INSERT INTO news VALUES(100, '四川新闻');
SELECT * FROM news;
-- 给 'Meez_edu'@'localhost' 分配查看 news 表和 添加news的权限
GRANT SELECT, INSERT
ON testdbx.news
TO 'Meez_edu'@'localhost';
```

```mysql
-- user查询
SELECT * FROM news;
INSERT INTO news VALUES(2, '成都新闻');
UPDATE news SET content = '攀枝花新闻'
WHERE id = 1;
-- 回收所有权限
REVOKE SELECT, UPDATE, INSERT ON testdbx.news FROM 'Meez_edu'@'localhost';
REVOKE ALL ON testdbx.news FROM 'Meez_edu'@'localhost'; -- 回收所有权限
```

- 细节说明

1. 在创建用户的时候，如果不指定Host, 则为%，%表示表示**所有IP**都有**连接权限**create user xxx
2. 你也可以这样指定create user'xxx@'192.168.1.%’表示 xxx用户在 192.168.1.*的ip可以登录mysql
3. 在删除用户的时候，如果 host 不是 %，需要明确指定'用户@'host值'

```mysql
-- 删除
drop user jack -- 等效于 drop user 'jack'@'%'
```

## JDBC和连接池

### JDBC概述

- 基本介绍

1. JDBC(Java DataBase Connectivity)为访问**不同的数据库**提供了**统一的接口**，为使用者屏蔽了细节问题 -- Java程序员只需要面向这套接口编程即可。
2. Java程序员使用JDBC，可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。
3. JDBC的基本原理
4. 模拟JDBC com.hspedu.jdbc.myjdbc

<img src=".\Java入门markdown图片\JDBC原理示意图.png" alt="JDBC原理示意图" style="zoom:50%;" />

### JDBC快速入门

- JDBC程序编写步骤

1. 注册驱动 - 加载Driver 类
2. 获取连接 - 得到Connection
3. 执行增删改查 - 发送SQL 给mysql执行
4. 释放资源 - 关闭相关连接

- 快速入门--程序1

```mysql
-- 创建测试表 演员表
CREATE TABLE actor (
id INT PRIMARY KEY AUTO_INCREMENT,
`name` VARCHAR(32) NOT NULL DEFAULT '',
sex CHAR(1) NOT NULL DEFAULT '女',
borndate DATETIME,
phone VARCHAR(12));

SELECT * FROM actor;
```

```java
// 使用Java程序操作数据库
package com.jdbc;

import com.mysql.jdbc.Driver;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;
public class jdbc01 {
    public static void main(String[] args) throws SQLException {
        //1.注册驱动
        Driver driver = new Driver();
        //2.得到连接
        // (1) jdbc:mysql:// 规定好表示协议，通过jdbc的方式连接mysql
        // (2) LocaThost 主机，可以是ip地
        // (3) 3306 表示mysql监听的端口
        // (4) mysql的连接本质就是socket
        String url = "jdbc:mysql://localhost:4306/testdbx";
        Properties properties = new Properties();
        properties.setProperty("user", "root");
        properties.setProperty("password", "z123456");
        Connection connect = driver.connect(url, properties);
        //3.执行sql
//        String sql = "insert into actor values(null, '刘德华', '男', '1970-11-11', '110')";
        String sql = "update actor set name = '周星驰' where id = 1";
        // statement 用于执行静态SQL语句并返回其生成的结果的对象
        Statement statement = connect.createStatement();
        int rows = statement.executeUpdate(sql); // 如果是dml语句，返回受影响的行数
        System.out.println(rows > 0 ? "成功" : "失败");
        //4.关闭连接资源
        statement.close();
        connect.close();
    }
}
```

### JDBC API**

- 基本结构

![jbdc API](.\Java入门markdown图片\jbdc API.png)

#### 获取数据库连接的5中方式

- 第一种：Driver类对象

```java
// 静态加载
// 获取Driver实现类对象
Driver driver = new com.mysql.jdbc.Driver();
String url = "jdbc:mysql://localhost:4306/testdbx";
Properties info = new Properties();
properties.setProperty("user", "root");
properties.setProperty("password", "z123456");
Connection connect = driver.connect(url, properties);
System.out.println(conn):
```

- 第二种：反射机制动态加载

```java
// 反射机制动态加载
public static void connect02() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {
    // 使用反射加载
        Class<?> aClass = Class.forName("com.mysql.jdbc.Driver"); // 配置信息写在配置文件里面
        Driver driver = (Driver) aClass.newInstance();
        String url = "jdbc:mysql://localhost:4306/testdbx";
        //将 用户名和密码放入到Properties 对象
        Properties properties = new Properties();
        //说明 user 和 password 是规定好，后面的值根据实际情况写
        properties.setProperty("user", "root"); // 用户
        properties.setProperty("password", "z123456"); // 密码
        Connection connect = driver.connect(url, properties);
        System.out.println("方式2" + connect);
    }
```

- 第三种：driverManager创建

```java
@Test
    public void connect03() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {
        // 使用反射加载
        Class<?> aClass = Class.forName("com.mysql.jdbc.Driver"); // 配置信息可以写在配置文件里面
        Driver driver = (Driver) aClass.newInstance();
        // 创建url 和 user 和 password
        String url = "jdbc:mysql://localhost:4306/testdbx";
        String user = "root";
        String password = "z123456";
        DriverManager.registerDriver(driver); // 注册
        //说明 user 和 password 是规定好，后面的值根据实际情况写

        Connection connect = DriverManager.getConnection(url, user, password);
        System.out.println("方式3" + connect);
    }
```

- 第四种：对比第三种方法--加载driver类自动完成注册。

```java
// 实际开发中使用的最多的方法
    @Test
    public void connect04() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {
        // 使用反射加载Driver类
        // 完成Driver类加载时，自动完成注册
        Class.forName("com.mysql.jdbc.Driver"); // 可以不调用
        // 创建url 和 user 和 password
        String url = "jdbc:mysql://localhost:4306/testdbx";
        String user = "root";
        String password = "z123456";
        //说明 user 和 password 是规定好，后面的值根据实际情况写
        Connection connect = DriverManager.getConnection(url, user, password);
        System.out.println("方式4" + connect);
    }
```

提示：

1. mysqL驱动5.1.6可以无需CLass.forName("com.mysqljdbc.Driver");// 无需显示调用
2. jar包下META-INF\services\java.sql.Driver文本中的类名称去注册从idk1.5以后使用了jdbc4,不再需要显示调用class.forName(注册驱动而是自动调用驱动
3. 但是建议显示调用一下，增加可读性

- 第五种：通过配置文件调用

最推荐使用第5种方法

```properties
// 配置文件
user=root
password=z123456
url=jdbc:mysql://localhost:4306/testdbx
driver=com.mysql.jdbc.Driver
```

```java
@Test
    public void connect05() throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException, IOException {
        // 通过Properties对象获取配置文件的信息
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\mysql.properties"));
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
        String url = properties.getProperty("url");
        Class.forName(driver);
        Connection connection = DriverManager.getConnection(url, user, password);
        System.out.println("方式5" + connection);
}
```

- 注意：

1. resultset的数据和相关信息保存在rowData里面
2. 所有数据存储在rows(Arraylist)中，在elementData(object[] 数组)表示不同行的数据，internalRowData(byte[] 数组)表示各列数据

#### Statement

- 基本介绍

1. Statement对象 用于执行静态SQL语句并返回其生成的结果的对象
2. 在连接建立后，需要对数据库进行访问，执行 命名或是SQL语句，可以通过
   - Statement(存在sql注入)
   - **PreparedStatement**
   - CallableStatement

3. Statement对象执行SQL 语句，存在**SQL注入**风险
4. SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL 语句段或命令,恶意攻击数据库。
5. 要防范 SQL 注入，只要用 **PreparedStatement**(从Statement扩展而来) 取代 Statement 就可以了

- sql注入--案例演示

```mysql
-- 创建表
CREATE TABLE admin (
`name` VARCHAR(32) NOT NULL UNIQUE,
pwd VARCHAR(32) NOT NULL DEFAULT ''
) CHARACTER SET utf8;

INSERT INTO admin VALUES('tom', '123');
SELECT * 
	FROM admin
	WHERE `name` = 'tom' AND pwd = '123';
-- SQL中
-- user 输入 1' or
-- pwd 输入 or '1' = '1
SELECT *
	FROM admin
	WHERE NAME = '1' OR 'AND pwd = ' OR '1' = '1';
-- where 的结果永远为1
```

- Java的statement的注入风险演示

```java
package JBDCTest;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.*;
import java.util.Properties;
import java.util.Scanner;

public class StatementTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {
        // 获取管理员的信息
        Scanner scanner = new Scanner(System.in);
        // 输入用户和密码
        System.out.println("输入管理员的名字：");
        String admin_name = scanner.nextLine();// 注意区别next()和nextLine()方法
        System.out.println("输入管理员的密码：");
        String admin_pwd = scanner.nextLine();

        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\mysql.properties"));
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
        String url = properties.getProperty("url");
        //1.注册驱动
        Class.forName(driver);
        // 2.得到连接
        Connection connection = DriverManager.getConnection(url, user, password);
        // 3.得到statement
        Statement statement = connection.createStatement();
        // 4. 组织sql
        String sql = "select name, pwd from admin " +
                "where name = '" + admin_name + "'and pwd='" + admin_pwd + "'";
        ResultSet resultSet = statement.executeQuery(sql);
        if (resultSet.next()) {
            System.out.println("登录成功");
        } else {
            System.out.println("登录失败");
        }
        // 关闭连接
        resultSet.close();
        statement.close();
        connection.close();
    }
}
```

```properties
// 配置文件
user=root
password=123456
url=jdbc:mysql://localhost:4306/testdbx
driver=com.mysql.jdbc.Driver
```

```java
// 注入测试
// 输入 user
// 1' or
// 输入密码
// or '1'= '1
```

#### PreparedStatement

- 基本介绍

1. PreparedStatement 执行的 SQL 语句中的**参数用问号(?)**来表示，调用PreparedStatement 对象的 setXxx0 方法来设置这些参数. setXxx()方法有两个参数, 第一个参数是要设置的SQL语句中的参数的索引(**从 1 开始, 第一个占位符的位置**)，第二个是设置的 SQL 语句中的**参数的值**
2. 调用 executeQuery()，返回 ResultSet 对象
3. 调用 executeUpdate(): 执行更新，包括增、删、修改

- 预处理的好处

1. 不再使用+ 拼接sql语句，**减少语法错误**
2. 有效的**解决sql注入**问题!
3. 大大减少了编译次数，效率较高

- 案例演示-预处理DML

```java
package com;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.*;
import java.util.Properties;
import java.util.Scanner;

public class PreparedStatementTest {
    public static void main(String[] args) throws IOException, SQLException, ClassNotFoundException {
        Scanner scanner = new Scanner(System.in);
        // 输入用户和密码
        System.out.println("输入管理员的名字：");
        String admin_name = scanner.nextLine();// 注意区别next()和nextLine()方法
        System.out.println("输入管理员的密码：");
        String admin_pwd = scanner.nextLine();

        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\mysql.properties"));
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
        String url = properties.getProperty("url");
        // 1. 注册驱动
        Class.forName(driver);
        // 2. 得到连接
        Connection connection = DriverManager.getConnection(url, user, password);
        // 3.获取PreparedStatement
        // 组织sql ? 相当于 占位符
        String sql = "select name, pwd from admin where name = ? and pwd = ?";
        // 返回的是实现preparedStatement的类对象
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        // 赋值 ?
        preparedStatement.setString(1, admin_name);
        preparedStatement.setString(2, admin_pwd);
        // 这里执行executeQuery不需要在加sql
        ResultSet resultSet = preparedStatement.executeQuery();
        if (resultSet.next()) {
            System.out.println("登录成功");
        } else {
            System.out.println("登录失败");
        }
        // 关闭连接
        resultSet.close();
        preparedStatement.close();
        connection.close();

    }
}
```

- 案例演示--DML(增删改)

```java
// 添加
package com;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.*;
import java.util.Properties;
import java.util.Scanner;

public class PreparedStatementTest {
    public static void main(String[] args) throws IOException, SQLException, ClassNotFoundException {
        Scanner scanner = new Scanner(System.in);
        // 输入用户和密码
        System.out.println("输入添加管理员的名字：");
        String admin_name = scanner.nextLine();// 注意区别next()和nextLine()方法
        System.out.println("输入添加管理员的密码：");
        String admin_pwd = scanner.nextLine();

        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\mysql.properties"));
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
        String url = properties.getProperty("url");
        // 1. 注册驱动
        Class.forName(driver);
        // 2. 得到连接
        Connection connection = DriverManager.getConnection(url, user, password);
        // 3.获取PreparedStatement
        // 添加
        String sql = "insert into admin values(?, ?)";
        // 返回的是实现preparedStatement的类对象
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        // 赋值 ?
        preparedStatement.setString(1, admin_name);
        preparedStatement.setString(2, admin_pwd);
        // 这里执行executeQuery不需要在加sql
        int rows = preparedStatement.executeUpdate();
        System.out.println(rows > 0 ? "成功" : "失败");
        // 关闭连接
        preparedStatement.close();
        connection.close();
    }
}
```

```java
// 更新
String sql = "update admin set pwd = ? where name = ?";
preparedStatement.setString(1, admin_pwd);
preparedStatement.setString(2, admin_name);
```

```java
// 删除
String sql = "delete from admin where name = ?";
preparedStatement.setString(1, admin_name);
```

- 课堂测试



#### DriverManager

- 驱动管理类

#### ResultSet

- 基本说明

1. 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。
2. 光标位于第一行之前Resultset对象保持一个光标指向其当前的数据行。
3. next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集。

- 案例演示

```java
resultSet.getInt("id");// key获取
resultSet.getInt(1);// idx获取
```

### JDBCUtils

- 基本说明

1. 在jdbc 操作中，**获取连接**和**释放资源**是经常使用的操作，可以将其封装JDBC连接的工具类 JDBCUtils
2. **获取连接**和**释放资源**是数据库操作的通用代码

- 演示案例

```java
// Utils类
package com.jdbc;

import com.PreparedStatementTest;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.*;
import java.util.Properties;

public class JDBCUtils {
    private static String user;
    private static String password;
    private static String url;
    private static String driver;
    // 使用static代码块初始化
    static {
        try {
            Properties properties = new Properties();
            properties.load(new FileInputStream("src\\mysql.properties"));
            user = properties.getProperty("user");
            password = properties.getProperty("password");
            driver = properties.getProperty("driver");
            url = properties.getProperty("url");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }
    public static Connection getConnection() {
        try {
            return DriverManager.getConnection(url, user, password);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

    }
    // Statement类可以接受 Statement 和 PreparedStatement的对象
    public static void close(ResultSet set, Statement statement, Connection connection) {

        try {
            if (set != null) {
                set.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
```

```java
//使用Utils -- dml 和 查询
package com;

import com.jdbc.JDBCUtils;
import org.junit.Test;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * @version 1.0
 * @auther Meez
 */
public class JDBCUtils_Use {
    public static void main(String[] args) {
    }

@Test
    public void testDML() { // dml : insert/update/delete
        // 1. 连接
        Connection connection = JDBCUtils.getConnection();
        // 2. sql
        String sql = "update actor set name = ? where id = ?";
        // 3. 创建
        PreparedStatement preparedStatement = null;
        try {
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, "周星驰");
            preparedStatement.setInt(2, 2);
            preparedStatement.executeUpdate();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            // 关闭资源
            JDBCUtils.close(null, preparedStatement, connection);
        }
    }
    @Test
    public void testSelect() { // 查询
        // 1. 连接
        Connection connection = JDBCUtils.getConnection();
        // 2. sql
        String sql = "select * from actor";
        // 3. 创建
        PreparedStatement preparedStatement = null;
        ResultSet set = null;
        try {
            preparedStatement = connection.prepareStatement(sql);
            set = preparedStatement.executeQuery();
            while (set.next()) {
                int id = set.getInt("id");
                String name = set.getString("name");
                String sex = set.getString("sex");
                String borndate = set.getString("borndate");
                String phone = set.getString("phone");
                System.out.println(id + "\t" + name + "\t" + sex + "\t" + borndate + "\t" + phone);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            // 关闭资源
            JDBCUtils.close(set, preparedStatement, connection);
        }
    }
}
```



### 事务**

- 基本介绍

1. JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务：每次执行一个SQL 语句时，如果执行成功，就会向数据库**自动提交**，而不能回滚。
2. JDBC程序中为了让多个 SQL 语句作为一个整体执行，需要**使用事务**。
3. 调用 Connection 的 setAutoCommit(false) 可以**取消自动提交事务**。
4. 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务。
5. 在其中某个操作失败或出现异常时调用 rollback(); 方法回滚事务。

- 应用案例--模拟转账

```mysql
// 创建表
CREATE TABLE ACCOUNT (
id INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(32) NOT NULL DEFAULT '',
balance DOUBLE NOT NULL DEFAULT 0)
CHARACTER SET utf8 ;

INSERT INTO ACCOUNT VALUES(NULL, '马化腾', 3000), (NULL, '马云', 10000);
SELECT * FROM ACCOUNT;
```

- 不实现事务时

```java
package com;

import com.jdbc.JDBCUtils;
import org.junit.Test;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TransactionTest {


    @Test
    public void testDML() { // dml : insert/update/delete
        // 1. 连接
        Connection connection = null;
        // 2. sql
        String sql1 = "update account set balance = balance - 100 where id = 1";
        String sql2 = "update account set balance = balance + 100 where id = 2";
        // 3. 创建
        PreparedStatement preparedStatement = null;
        try {
            connection = JDBCUtils.getConnection();
            preparedStatement = connection.prepareStatement(sql1);
            preparedStatement.executeUpdate();
            int i = 1/0; // 操作中存在异常导致第二个语句没有执行
            preparedStatement = connection.prepareStatement(sql2);
            preparedStatement.executeUpdate();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            // 关闭资源
            JDBCUtils.close(null, preparedStatement, connection);
        }
    }
}
```

- 实现事务

```java
package com;

import com.jdbc.JDBCUtils;
import org.junit.Test;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TransactionTest {


    @Test
    public void testDML() { // dml : insert/update/delete
        // 1. 连接
        Connection connection = null;
        // 2. sql
        String sql1 = "update account set balance = balance - 100 where id = 1";
        String sql2 = "update account set balance = balance + 100 where id = 2";
        // 3. 创建
        PreparedStatement preparedStatement = null;
        try {
            connection = JDBCUtils.getConnection();
            connection.setAutoCommit(false); // 相当于开启事务
            preparedStatement = connection.prepareStatement(sql1);
            preparedStatement.executeUpdate();
            int i = 1/0; // 操作中存在异常导致第二个语句没有执行
            preparedStatement = connection.prepareStatement(sql2);
            preparedStatement.executeUpdate();
            // 提交事务
            connection.commit();
        } catch (Exception e) {
            try {
                System.out.println("发生异常，回滚事务");
                if (connection != null) {
                    connection.rollback(); // 默认回滚到事务开始的地方
                }
            } catch (SQLException ex) {
                throw new RuntimeException(ex);
            }
            throw new RuntimeException(e);
        } finally {
            // 关闭资源
            JDBCUtils.close(null, preparedStatement, connection);
        }
    }
}
```



### 批处理

- 基本介绍

1. 当需要成批插入或者更新记录时。可以采用Java的**批量更新机制**，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。
2. JDBC的批量处理语句包括下面方法:
   addBatch()：添加需要批量处理的SQL语句或参数
   executeBatch()：执行批量处理语句:
   clearBatch()：清空批处理包的语句
3. JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements=true
4. 批处理往往和PreparedStatement一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高

- 案例演示

```mysql
// 创建测试表
CREATE TABLE admin2 (
id INT PRIMARY KEY auto_increment,
`username` VARCHAR(32) NOT NULL UNIQUE,
`PASSWORD` VARCHAR(32) NOT NULL 
);
```

```java
// 传统处理方法
@Test
    public void norBatch() throws SQLException {
        Connection connection = JDBCUtils.getConnection();
        String sql = "insert into admin2 values(null, ?, ?)";
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        System.out.println("开始执行");
        long start = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            preparedStatement.setString(1, "jack" + i);
            preparedStatement.setString(2, "666");
            preparedStatement.executeUpdate();
        }
        long end = System.currentTimeMillis();
        System.out.println("结束执行" + "\t" + "执行时间为：" + (end - start));
        JDBCUtils.close(null, preparedStatement, connection);

    }
/*
开始执行
结束执行	执行时间为：3429
*/
```

```java
@Test
    public void Batch() throws SQLException {
        Connection connection = JDBCUtils.getConnection();
        String sql = "insert into admin2 values(null, ?, ?)";
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        System.out.println("开始执行");
        long start = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            preparedStatement.setString(1, "jack" + i);
            preparedStatement.setString(2, "666");
            preparedStatement.addBatch();
            if ((i + 1) % 1000 == 0) {// 每一千条批量执行一次
                preparedStatement.executeBatch();
                preparedStatement.clearBatch();
            }
        }
        long end = System.currentTimeMillis();
        System.out.println("结束执行" + "\t" + "批量执行时间为：" + (end - start));
        JDBCUtils.close(null, preparedStatement, connection);

    }
/*
未添加该语句 ?rewriteBatchedStatements=true
开始执行
结束执行	批量执行时间为：3443
*/
/*
添加后
开始执行
结束执行	批量执行时间为：61
*/
```

```properties
// 添加批处理语句的配置文件
user=root
password=z123456
url=jdbc:mysql://localhost:4306/testdbx?rewriteBatchedStatements=true
driver=com.mysql.jdbc.Driver
```

- addBatch()源码

1. 在BatchedArgs(ArrayList)中保存url--满足ArrayList的扩容机制
2. 减少网络通信的开销和编译次数(执行次数)

### 连接池**

- 5k次连接数据库问题

1. 编写程序完成连接MySQL5000次的操作
2. 看看有什么问题，耗时又是多久。= > 数据库连接池

```java
@Test
    public void testCon() {
        for (int i = 0; i < 5000; i++) {
            Connection connection = JDBCUtils.getConnection();
        }
}
/*
抛出异常
Too many connections
*/
```

```java
// 执行连接和关闭
@Test
    public void testCon() {
        // 查看连接关闭的使用时间
        System.out.println("开始连接");
        long start = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            Connection connection = JDBCUtils.getConnection();
            // 执行关闭
            JDBCUtils.close(null, null, connection);
        }
        long end = System.currentTimeMillis();
        System.out.println("结束时间" + "\t" + "使用时间为" + (end - start));
}
/*
开始连接
结束时间	使用时间为3182
*/
```

- 传统获取Connection问题分析

1. 传统的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中再**验证IP地址**，**用户名和密码**(0.05s~ 1s时间)。需要数据库连接的时候就向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源容易造成服务器崩溃。
2. 每一次数据库连接，使用完后**需要断开连接**，如果程序出现异常而未能关闭，将导致数据库**内存泄漏**，最终将导致重启数据库。
3. 传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，MySQL崩溃。
4. 解决传统开发中的数据库连接问题，可以采用数据库**连接池技术**(connection pool)。

- 数据库连接池基本介绍

1. 预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池'中取出一个，使用完毕之后**再放回去**。
2. 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序**重复使用**一个现有的数据库连接，而不是重新建立一个。
3. 当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到**等待队列**中。

<img src=".\Java入门markdown图片\连接池原理示意图.png" alt="连接池原理示意图" style="zoom: 67%;" />

- 数据库的连接池种类

1. JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource只是一个接口，该接口通常由第三方提供实现。
2. **C3P0** 数据库连接池，速度相对较慢，稳定性不错(hibernate, spring)。
3. DBCP数据库连接池，速度相对c3p0较快，但不稳定。
4. Proxool数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点。
5. BoneCP 数据库连接池，速度快。
6. **Druid**(德鲁伊)是阿里提供的数据库连接池，集DBCP 、C3PO 、Proxool**优点**于一身的数据库连接池.

#### C3P0

- 前期准备

1. C3P0的jar包
2. 配置文件--放至项目的src目录

```xml
<!--配置文件 c3p0-config.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
    <named-config name="zyp_config">
    <!--数据库驱动-->
    <property name="driverClass">com.mysql.jdbc.Driver</property>
    <!--数据库的url-->
    <property name="jdbcUrl">jdbc:mysql://localhost:4306/testdbx</property>
    <!--用户名写自己的-->
    <property name="user">root</property>
    <!--密码写自己的-->
    <property name="password">z123456</property>
    <!--初始连接数-->
    <property name="initialPoolSize">10</property>
    <!--最大连接数-->
    <property name="maxPoolSize">100</property>
    <!--最小连接数-->
    <property name="minPoolSize">10</property>
    </named-config>
</c3p0-config>
```

- 案例演示--连接方式1

```java
@Test
    public void testC3P0_1() throws IOException, PropertyVetoException, SQLException {
        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\mysql.properties"));
        //
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
        String url = properties.getProperty("url");
        // 设置数据源 comboPooledDataSource 的相关参数
        comboPooledDataSource.setDriverClass(driver);
        comboPooledDataSource.setJdbcUrl(url);
        comboPooledDataSource.setUser(user);
        comboPooledDataSource.setPassword(password);
        // 设置初始化连接数
        comboPooledDataSource.setInitialPoolSize(10);
        // 最大连接数
        comboPooledDataSource.setMaxPoolSize(50);
        long start = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            Connection connection = comboPooledDataSource.getConnection();
            connection.close();
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时" + (end - start));
    }
/*
耗时233
*/
```

- 案例演示--连接方式2：配置文件连接

```java
@Test
    public void testC3P0_2() throws IOException, PropertyVetoException, SQLException {
        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource("zyp_config");
        long start = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            Connection connection = comboPooledDataSource.getConnection();
            connection.close();
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时" + (end - start));
    }
```

#### Druid

- 前期准备

1. jar包
2. 配置文件--放至项目的src目录

```properties
#key=value
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:4306/testdbx?rewriteBatchedStatements=true
#url=jdbc:mysql://Localhost:4306/testdbx
username=root
password=z123456
#initial connection Size
initialSize=10
#min idle connecton size
minIdle=5
#max active connection size
maxActive=20
#max wait time (5000 mil seconds)
maxWait=5000
```

- 案例

```java
public class DruidTest {
    @Test
    public void testDruid() throws Exception {
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\druid.properties"));
        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
        long start = System.currentTimeMillis();
        for (int i = 0; i < 5000; i++) {
            Connection connection = dataSource.getConnection();
            connection.close();
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时" + (end - start));
    }
}
```

- JDBCUtils实现Druid的连接和关闭

```java
package com;

import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class JDBCUtilsByDruid {
    private static DataSource ds;
    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream("src\\druid.properties"));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
    // druid技术的close不是断开连接，而是把连接放回连接池
    public static void close(ResultSet resultSet, Statement statement, Connection connection) {
        try {
            if (resultSet != null) {
                resultSet.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
```

```java
//测试
package com;

import com.alibaba.druid.pool.DruidDataSourceFactory;
import com.jdbc.JDBCUtils;
import org.junit.Test;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.*;
import java.util.Properties;

public class JDBCUtilsByDruid {
    private static DataSource ds;
    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream("src\\druid.properties"));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }
    // druid技术的close不是断开连接，而是把连接放回连接池
    public static void close(ResultSet resultSet, Statement statement, Connection connection) {
        try {
            if (resultSet != null) {
                resultSet.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
    @Test
    public void testSelect() { // dml : insert/update/delete
        // 1. 连接
        Connection connection = null;
        // 2. sql
        String sql = "select * from actor";
        // 3. 创建
        PreparedStatement preparedStatement = null;
        ResultSet set = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            preparedStatement = connection.prepareStatement(sql);
            set = preparedStatement.executeQuery();
            while (set.next()) {
                int id = set.getInt("id");
                String name = set.getString("name");
                String sex = set.getString("sex");
                String borndate = set.getString("borndate");
                String phone = set.getString("phone");
                System.out.println(id + "\t" + name + "\t" + sex + "\t" + borndate + "\t" + phone);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            // 关闭资源
            JDBCUtilsByDruid.close(set, preparedStatement, connection);
        }
    }
}
```

注意：statement是接口，不同的连接池实现的内容不一样

#### DataSource

#### DBCP

#### Proxool

#### BoneCP

### Apache-DBUtils

- 问题引出

1. 关闭connection 后，resultSet 结果集无法使用
2. resultSet 不利于数据的管理--可能需要复用
3. 为每一行数据创建一个对象
4. 需要将表里所有的记录存在ArrayList<对象>

<img src=".\Java入门markdown图片\DBUtils引出.png" alt="DBUtils引出" style="zoom: 80%;" />

- 手动实现的案例

```java
//actor类
package com;

import java.util.Date;

/**
 * @version 1.0
 * @auther Meez
 */
public class Actor {
    private Integer id;
    private String name;
    private String sex;
    private Date borndate;
    private String phone;

    public Actor() {
    }

    public Actor(Integer id, String name, String sex, Date borndate, String phone) {
        this.id = id;
        this.name = name;
        this.sex = sex;
        this.borndate = borndate;
        this.phone = phone;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public Date getBorndate() {
        return borndate;
    }

    public void setBorndate(Date borndate) {
        this.borndate = borndate;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    @Override
    public String toString() {
        return "Actor{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                ", borndate=" + borndate +
                ", phone='" + phone + '\'' +
                '}';
    }
}
```

```java
@Test
public void testDML() { // dml : insert/update/delete
    // 1. 连接
    Connection connection = null;
    // 2. sql
    String sql = "select * from actor";
    // 3. 创建
    PreparedStatement preparedStatement = null;
    // 4. 创建ArrayList
    ArrayList<Actor> actors = new ArrayList<>();
    try {
        connection = JDBCUtilsByDruid.getConnection();
        preparedStatement = connection.prepareStatement(sql);
        ResultSet resultSet = preparedStatement.executeQuery();

        while (resultSet.next()) {
            int id = resultSet.getInt("id");
            String name = resultSet.getString("name");
            String sex = resultSet.getString("sex");
            Date borndate = resultSet.getDate("borndate");
            String phone = resultSet.getString("phone");
            actors.add(new Actor(id, name, sex, borndate, phone));
        }
        System.out.println(actors);
    } catch (SQLException e) {
        throw new RuntimeException(e);
    } finally {
        // 关闭资源
        JDBCUtilsByDruid.close(null, preparedStatement, connection);
    }
}
```

- 基本介绍

commons-dbutils 是 Apache 组织提供的一个**开源 JDBC工具类库**，它是对JDBC的封装使用dbutils能极大简化jidbc编码的工作量。

- DbUtils类

1. QueryRunner类: 该类封装了SQL的执行，是**线程安全**的。可以实现增、删、改、查、批处理
2. 使用QueryRunner类实现查询
3. ResultSetHandler接口: 该接口用于处理 java.sgl.ResultSet，将数据按要求转换为另一种形式

- 常见方法

1. ArrayHandler: 把结果集中的第一行数据转成对象数组。
2. ArrayListHandler: 把结果集中的每一行数据都转成一个数组，再存放到List中
3. BeanHandler: 将结果集中的第一行数据封装到一个对应的JavaBean实例中。
4. BeanListHandler: 将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里
5. ColumnListHandler: 将结果集中某一列的数据存放到List中。
6. KevedHandler(name): 将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。
7. MapHandler: 将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。
8. MapListHandler: 将结果集中的每一行数据都封装到一个Map里，然后再存放到List

- 前期准备

1. dbutils的Jar包--放至项目目录

- 案例演示

```java
@Test
public void testQueryMany() throws SQLException {
    //1.得到 连接 (druid)
    Connection connection = JDBCUtilsByDruid.getConnection();
    //2.使用 DBUtils 类和接口 ，先引入DBUtils 相关的jar ，加入到本Project
    //3.创建 OueryRunner
    QueryRunner queryRunner = new QueryRunner();
    //4.就可以执行相关的方法，返回 ArrayList 结果集
    String sql = "select * from actor where id >= ?";
    //1) query 方法就是执行sql 语句，得到resultset ---封装到 --> ArrayList 集合中
    //2) 返回集合
    //3)connection:连接
    //4)sql : 执行的sql语句
    //5)new BeanListHandler<>(Actor,class): 在将resultset -> Actor 对象 -> 封装到 ArrayList
    //底层使用反射机制 去获取Actor 类的属性，然后进行封装
    //6) 1 就是给 sl 语句中的? 赋值，可以有多个值，因为是可变参数
    List<Actor> list = queryRunner.query(connection, sql, new BeanListHandler<>(Actor.class), 1);// 查看query的底层代码
    //显示内容
    for (Actor actor: list) {
        System.out.println(actor);
    }
    // 关闭资源
    JDBCUtilsByDruid.close(null, null, connection);
}
// 详细内容看源码
```

- 应用案例 -- 查询

使用DBUtils+数据连接池(德鲁伊)方式，完成对表actor的crud

```java
// 查询单个对象
@Test
public void testQuerySingle() throws SQLException {
    // 1. 获取连接
    Connection connection = JDBCUtilsByDruid.getConnection();
    // 2. 创建QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    // 3. 获取结果集
    String sql = "select * from actor where id = ?";
    Actor query = queryRunner.query(connection, sql, new BeanHandler<>(Actor.class), 2);
    System.out.println(query);
    // 关闭资源
    JDBCUtilsByDruid.close(null, null, connection);
}
```

```java
// 查询单行单列对象
@Test
public void testScalar() throws SQLException {
    // 1. 获取连接
    Connection connection = JDBCUtilsByDruid.getConnection();
    // 2. 创建QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    // 3. 获取结果集
    String sql = "select name from actor where id = ?";
    Object query = queryRunner.query(connection, sql, new ScalarHandler<>(), 2); // 单行单列查询
    System.out.println(query);
    // 关闭资源
    JDBCUtilsByDruid.close(null, null, connection);
}
```

- 应用案例 -- dml

使用DBUtils+数据连接池(德鲁伊)方式，完成对表actor的crud

```java
// 修改
@Test
public void testDML1() throws SQLException {
    // 1. 获取连接
    Connection connection = JDBCUtilsByDruid.getConnection();
    // 2. 创建QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    // 3. 获取结果集
    String sql = "update actor set name = ? where id = ?";
    //(1) 执行dm[ 操作是 queryRunner.update()
    //(2) 返回的值是受影响的行数
    int row = queryRunner.update(connection, sql, "张三丰", 2);
    System.out.println(row > 0 ? "执行成功" : "表没有受到影响");

    // 关闭资源
    JDBCUtilsByDruid.close(null, null, connection);

}
```

```java
// insert
@Test
public void testDML2() throws SQLException {
    // 1. 获取连接
    Connection connection = JDBCUtilsByDruid.getConnection();
    // 2. 创建QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    // 3. 获取结果集
    String sql = "insert into actor values(null, '林俊杰', '男', '1970-11-11', '133')";
    //(1) 执行dm[ 操作是 queryRunner.update()
    //(2) 返回的值是受影响的行数
    int row = queryRunner.update(connection, sql);
    System.out.println(row > 0 ? "执行成功" : "表没有受到影响");
    // 关闭资源
    JDBCUtilsByDruid.close(null, null, connection);
}
```

```java
// delete
@Test
public void testDML3() throws SQLException {
    // 1. 获取连接
    Connection connection = JDBCUtilsByDruid.getConnection();
    // 2. 创建QueryRunner
    QueryRunner queryRunner = new QueryRunner();
    // 3. 获取结果集
    String sql = "delete from actor where id = ?";
    //(1) 执行dm[ 操作是 queryRunner.update()
    //(2) 返回的值是受影响的行数
    int row = queryRunner.update(connection, sql, 1000);
    System.out.println(row > 0 ? "执行成功" : "表没有受到影响");
    // 关闭资源
    JDBCUtilsByDruid.close(null, null, connection);
}
```

- 表和Java的类型映射关系

1. 数值类型--直接用对应的基本数据类型
2. 表中的char和varchar对应String类型
3. 表的date类型对应Java.util.date

### DAO增删改查-BasicDao**

- 问题引出

1. SQL 语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行**增删改查**
2. 对于select 操作，如果有返回值，**返回类型不能固定**，需要使用泛型
3. 将来的表很多，业务需求复杂,不可能只靠一个Java类完成
4. 引出-->BasicDAO ---- 把对数据库中所有表实现增删改查的公共部分集合在 BasicDAO 中

<img src=".\Java入门markdown图片\DAO_数据访问对象.png" alt="DAO_数据访问对象" style="zoom:67%;" />

- 基本说明

1. DAO：data access object 数据访问对象
2. 这样的通用类，称为 BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。
3. 在BaiscDao 的基础上，实现一张表 对应一个Dao，更好的完成功能，比如 Customer表-Customerjava类(iavabean)-CustomerDao.java

- 实用案例

1. daoTest.utils // 工具类
2. daoTest.domain // javabean
3. daoTest.dao // 存放XxxDAO 和BasicDAO
4. daoTest.test // 写测试类

```java
//dao
package com.daoTest.DAO;

import com.JDBCUtilsByDruid;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/**
 * @version 1.0
 * @auther Meez
 */
public class BasicDAO<T> {
    private QueryRunner qr = new QueryRunner();
    public int update(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            return qr.update(connection, sql, parameters);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }
    // 查询多行
    public List<T> queryMulti(String sql, Class<T> clazz, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            return qr.query(connection, sql, new BeanListHandler<T>(clazz), parameters);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }
    // 查询单行
    public T querySingle(String sql, Class<T> clazz, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            return qr.query(connection, sql, new BeanHandler<T>(clazz), parameters);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }
    // 查询单行单列
    public Object queryScalar(String sql, Object... parameters) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            return qr.query(connection, sql, new ScalarHandler<>(), parameters);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }
}
```

```java
//actor类--domain
package com.daoTest.domain;

import java.util.Date;

public class Actor {
    private Integer id;
    private String name;
    private String sex;
    private Date borndate;
    private String phone;

    public Actor() {
    }

    public Actor(Integer id, String name, String sex, Date borndate, String phone) {
        this.id = id;
        this.name = name;
        this.sex = sex;
        this.borndate = borndate;
        this.phone = phone;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public Date getBorndate() {
        return borndate;
    }

    public void setBorndate(Date borndate) {
        this.borndate = borndate;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    @Override
    public String toString() {
        return "Actor{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                ", borndate=" + borndate +
                ", phone='" + phone + '\'' +
                '}';
    }
}
```

```java
// test
package com.daoTest.Test;

import com.daoTest.DAO.ActorDAO;
import com.daoTest.domain.Actor;
import org.junit.Test;

import java.util.List;

public class TestDAO {

    @Test
    public void testActorDAO() {
        ActorDAO actorDAO = new ActorDAO();
        // 1. 查询多行 -- 底层建立连接-获取数据-关闭连接--一次完成
        List<Actor> actors = actorDAO.queryMulti("select * from actor where id >= ?", Actor.class, 1);
        System.out.println("显示多值对象");
        for (Actor actor: actors) {
            System.out.println(actor);
        }
        // 2. 查询多行
        Actor actor = actorDAO.querySingle("select * from actor where id = ?", Actor.class, 2);
        System.out.println("显示单值对象");
        System.out.println(actor);
        // 3. 查询单行单列
        Object o = actorDAO.queryScalar("select name from actor where id = ?", 2);
        System.out.println(o);
        // 4. dml
        int update = actorDAO.update("insert into actor values(null, '张艺兴', '男', '2000-1-1', '999')");
        System.out.println(update > 0 ? "修改成功" : "未影响表");
    }
}
```

```java
// actorDAO
package com.daoTest.DAO;
import com.daoTest.domain.Actor;

public class ActorDAO extends BasicDAO<Actor> {
}
```

```java
//utils--见JDBCUtilsByDruid
```



## 正则表达式

### 快速入门

- 提取文章中所有的英文单词
- 提取文章中所有的数字
- 提取文章中所有的英文单词和数字
- 提取百度热榜 标题

```java
package com.zyp.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @version 1.0
 * @auther Meez
 */
public class RegexpTest {
    public static void main(String[] args) {
        String content = "String content = 1995年，互联网的蓬勃发展给了0ak机会。业界为了使死板、单调的\n" +
                "静态网页能够“灵活\"起来，急需一种软件技术来开发一种程序，这种程序可以通\n" +
                "过网络传播并且能够跨平台运行。于是，世界各大IT企业为此纷纷投入了大量的\n" +
                "人力、物力和财力。这个时候，Sun公司想起了那个被搁置起来很久的0ak，并且\n" +
                "重新审视了那个用软件编写的试验平台，由于它是按照嵌入式系统硬件平台体系结\n" +
                "构进行编写的，所以非常小，特别适用于网络上的传输系统，而0ak也是一种精简的\n" +
                "语言，程序非常小，适合在网络上传输。Sun公司首先推出了可以嵌入网页并且可以\n" +
                "随同网页在网络上传输的Applet (Applet是一种将小程序嵌入到网页中进行执行的技术)，\n" +
                "三十并将0ak更名为Java (在申请注册商标时，发现Oak已经被人使用了，再想了一系列\n" +
                "名字之后，最终，使用了提议者在喝一杯Java咖啡时无意提到的Java词\n" +
                "语)。5月23日，Sun公司在Sun world会议上正式发\n" +
                "布Java和HotJava浏览器。IBM、Apple、DEC、Adobe、HP、Oracle、Netscape和微软\n" +
                "等各大公司都纷纷停止了自己的相关开发项目，竟相购买了Java使用许可证，并为自己的产\n" +
                "品开发了相应的Java平台";
        // 提取文章中所有的英文单词
        // 传统方法。使用遍历方式，代码量大，效率不高
        // 正则表达式技术
        // 1.先创建一个Pattern对象 ， 模式对象，可以理解成就是一个正则表达式对象
//        Pattern pattern = Pattern.compile("[a-zA-Z]+"); // 单次
//        Pattern pattern = Pattern.compile("[0-9]+"); // 数字
        Pattern pattern = Pattern.compile("([0-9]+)|([a-zA-Z]+)");
        // 2.创建一个匹配器对象
        // matcher 匹配器按照 pattern(模式/样式)，到 content 文本中去匹配
        // 找到就返回true,否则就返回false
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }

    }
}
```

### 正则表达式基本语法

- 基本介绍
- 正则表达式：regular expression -> regExp

1. 一个正则表达式，就是用某种模式去匹配字符串的一个公式。
2. 大多数编程语言都支持正则表达式。

- 正则表达式底层实现

```java
package com.zyp.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @version 1.0
 * @auther Meez
 */
public class RegTheory {
    public static void main(String[] args) {
        String content = "1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了\n" +
                "第二代Java平台 (简称为Java2) 的3个版本:J2ME (Java2 Micro Edition，Java2平台的微型\n" +
                "版)，应用于移动、无线及有限资源的环境:J2SE (Java 2 Standard Edition，Java 2平台的\n" +
                "标准版)，应用于桌面环境; J2EE (Java 2Enterprise Edition，Java 2平台的企业版)，应\n" +
                "用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个\n" +
                "里程碑，标志着Java的应用开始普及9889";
        // 目标：匹配所有4个数字
        // 1. \\d 表示任意数字
        String regStr = "\\d\\d\\d\\d";
        // 2. 创建模式对象[正则表达式]
        Pattern pattern = Pattern.compile(regStr);
        // 3. 创建匹配器
        Matcher matcher = pattern.matcher(content);
        // 4. 开始匹配
        // matcher.find() 完成的工作
        // (1):根据规则定位满足规则的子字符串
        // (2):找到后，将子字符串的开始的索引记录到 matcher对象的属性 int[] groups;
        //groups[0] = 0，把该子字符串的结束的索引+1的值记录到 groups[1] = 4 (下次执行开始的位置)
        /* 源代码
        group == 0时
        public String group(int group) {
        if (first < 0)
            throw new IllegalStateException("No match found");
        if (group < 0 || group > groupCount())
            throw new IndexOutOfBoundsException("No group " + group);
        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
            return null;
        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
    }
    */
    	// groups[group * 2]表示第group组开始的位置，groups[group * 2 + 1]表示
        // 第group组结束的位置
        // 根据groups[0]和groups[1]截取[groups[0], groups[1])位置的值
        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

- 分组

```java
String regStr = "(\\d\\d)(\\d\\d)";
// 正则表达式出现分组
// 一个小括号表示一个分组
// groups[0]记录整体开始的位置 groups[1]记录整体结束的位置 
// 记录第一组匹配结果 开始 groups[2] = 0 结束 groups[3] = 2 
// 记录第二组匹配结果 开始 groups[4] = 2 结束 groups[3] = 4 
// ...(更多分组)
```

```java
package com.zyp.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegTheory {
    public static void main(String[] args) {
        String content = "1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了\n" +
                "第二代Java平台 (简称为Java2) 的3个版本:J2ME (Java2 Micro Edition，Java2平台的微型\n" +
                "版)，应用于移动、无线及有限资源的环境:J2SE (Java 2 Standard Edition，Java 2平台的\n" +
                "标准版)，应用于桌面环境; J2EE (Java 2Enterprise Edition，Java 2平台的企业版)，应\n" +
                "用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个\n" +
                "里程碑，标志着Java的应用开始普及9889";
        // 目标：匹配所有4个数字
        // 1. \\d 表示任意数字
        String regStr = "(\\d\\d)(\\d\\d)";
        // 2. 创建模式对象[正则表达式]
        Pattern pattern = Pattern.compile(regStr);
        // 3. 创建匹配器
        Matcher matcher = pattern.matcher(content);
        // 4. 开始匹配
        // matcher.find() 完成的工作
        // (1):根据规则定位满足规则的子字符串
        // (2):找到后，将子字符串的开始的索引记录到 matcher对象的属性 int[] groups;
        //groups[0] = 0，把该子字符串的结束的索引+1的值记录到 groups[1] = 4 (下次执行开始的位置)
        /* 源代码
        group == 0时
        public String group(int group) {
        if (first < 0)
            throw new IllegalStateException("No match found");
        if (group < 0 || group > groupCount())
            throw new IndexOutOfBoundsException("No group " + group);
        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
            return null;
        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
    }
         */
        // 根据groups[0]和groups[1]截取[groups[0], groups[1])位置的值
        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
            System.out.println("第一组匹配的值：" + matcher.group(1));
            System.out.println("第二组匹配的值：" + matcher.group(2));
            // 没有更多分组会越界
        }
    }
}
```



### 元字符

- 元字符的分类

1. 限定符
2. 选择匹配符
3. 分组组合和反向引用符
4. 特殊字符
5. 字符匹配符
6. 定位符

- 转义符

\ \符号 说明: 在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错的。案例: 用 $ 去匹配“abc$(”会怎样 ?用( 去匹配“abc$(”会怎样 ?

提醒：在 Java 的正则表达式中，两个代表其他语言中的一个

```java
package com.zyp.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegExp02 {
    public static void main(String[] args) {
        String content = "abc$(abc(123(";
        // 匹配
        String regStr = "\\(";
//         String regStr = "("; // 不加转移符号会报错
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);

        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

#### 字符匹配符

- 可接收的字符列表：[ ]

1. 示例： [efgh] 

2. 含义：e、f、g、h中的任意1个字符

- 不可接收的字符列表：[ ^ ]

1. 示例： [ ^ abc] 
2. 含义：除a、b、c之外的任意1个字符，包括数字和特殊符号

- 连字符： -

1. 示例：A-Z
2. 任意单个大写字母

- 其他：

![字符匹配符1](.\Java入门markdown图片\字符匹配符1.png)

**注意**:   .  在()内表示任意字符， 在[]内表示 . 这个符号

- 应用案例

1. [a-z] 说明：[a-z] 表示可以匹配a-z中任意一个字符

```java
package com.zyp.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegExp03 {
    public static void main(String[] args) {
        String content = "a11c8";
//        String regStr = "[a-z]"; // 匹配a-z之间的任意一个字符
        String regStr = "[A-Z]";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);

        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

2. java正则表达式**默认是区分字母大小写**，如何实现不区分大小写
   - (?i)abc 表示abc都不区分大小写
   - a(?i)bc 表示bc不区分大小写
   - a((?i)b)c 表示只有b不区分大小写
   - Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE); // 创建正则表达式对象时指定Pattern.CASE_INSENSITIV -> 不区分大小写

```java
package com.zyp.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegExp03 {
    public static void main(String[] args) {
        String content = "a11c8ABCabcd";
//        String regStr = "[a-z]"; // 匹配a-z之间的任意一个字符
        String regStr = "abc";
        Pattern pattern = Pattern.compile(regStr, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(content);

        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

```java
public class RegExp03 {
    public static void main(String[] args) {
        String content = "a11c8ABCabcd";
//        String regStr = "[a-z]"; // 匹配a-z之间的任意一个字符
        String regStr = "(?i)abc";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);

        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

3.  [ ^ a - z ] 

说明：[ ^ a - z ] 表示可以匹配不是a-z中的任意一个字符

```java
package com.zyp.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @version 1.0
 * @auther Meez
 */
public class RegExp03 {
    public static void main(String[] args) {
        String content = "a11c8ABCabcd";
        String regStr = "[^a-z]{2}"; // 连续两个
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);

        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

4. [abcd] 表示可以匹配abcd中的任意一个字符
5. [^abcd] 表示可以匹配不是abcd中的任意一个字符
6. \ \d表示可以匹配0-9的任意一个数字,相当于[0-9]
7. \ \D表示可以匹配不是0-9中的任意一个数字,相当于[ ^ 0 - 9 ]
8. \ \w 匹配任意英文字符、数字和下划线,相当于[a-ZA-Z0-9_ ]
9. \ \W 相当于 [ ^ a - z A - Z 0 - 9 _]是 w 刚好相反
10. \ \s 匹配任何空白字符(空格,制表符等)
11. \ \S匹配任何非空白字符，和s刚好相反
12.  .  匹配出\n之外的所有字符中的任意一个字符。匹配 . 本身则需要使用 \ \ .

#### 选择匹配符

- 选择匹配符号：|

1. 匹配"|"之前或之后的表达式
2. 示例：ab | cd  表示  ab或者cd

#### 限定符

- 限定符：用于指定其前面的字符和组合项连续出现多少次

![正则匹配_限定符](.\Java入门markdown图片\正则匹配_限定符.png)

![正则匹配_限定符2](.\Java入门markdown图片\正则匹配_限定符2.png)

1. ？的作用范围
   - abc？:只作用在c (abc)? 作用在abc上
2. {n, m}匹配时是**贪婪匹配**，会尽可能多的匹配

```java
public class RegExp03 {
    public static void main(String[] args) {
//        String content = "11111a"; // 只会匹配前4个1
        String content = "111111a"; // 先匹配4个1再匹配两个1
        String regStr = "\\d{2,4}";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);

        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

#### 定位符

- 定位符：规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置。

![正则表达式_定位符](.\Java入门markdown图片\正则表达式_定位符.png)

- 案例演示

1. 指定起始字符

```java
String content = "123";
// String content = "a123"; // 匹配不到--以字母a开头
String regStr = "^[0-9]+[a-z]*";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);

while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));
}
```

2. 指定结束字符

```java
String content = "123aaa";
String regStr = "^[0-9]+[a-z]+$"; // 至少一一个字母结尾
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);

while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));
}

String content = "123-aaa";
String regStr = "^[0-9]+-[a-z]+$"; // 中间有-，至少一一个字母结尾
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);

while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));
}
```

3. 边界位置：结束或空格位置的字符  \ \b

4. 非边界位置

```java
// 结束位置
String content = "zypzyp123zyp aaazyp zyp1";
String regStr = "zyp\\b"; // 2个zyp--边界位置
String regStr = "zyp\\B"; // 3个zyp--非边界位置
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));
}
// 开头位置
```

#### 分组组合

- 分组

![正则表达式_分组](.\Java入门markdown图片\正则表达式_分组.png)

- 案例演示

```java
// 非命名分组
String content = "zyp2000zyp1234zyp aaa1996zyp zyp1";
String regStr = "(\\d\\d)(\\d)(\\d)";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));
    System.out.println("第一分组：" + matcher.group(1));
    System.out.println("第二分组：" + matcher.group(2));
    System.out.println("第三分组：" + matcher.group(3));
}
```

```java
String content = "zyp2000zyp1234zyp aaa1996zyp zyp1";
String regStr = "(?<g1>\\d\\d)(?<g2>\\d\\d)";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));
    System.out.println("第一分组：" + matcher.group("g1")); // 通过组名获取--方法重载
    System.out.println("第二分组：" + matcher.group(2));
}
```

- 特别分组/非捕获分组

![正则表达式_特别分组](.\Java入门markdown图片\正则表达式_特别分组.png)

1. (?:pattern)：匹配后面为pattern的整体字符(包括pattern)
   - 示例：industr(?:y|ies)共有部分写到前面

```java
String content = "hello韩顺平教育 jack韩顺平老师 韩顺平同学hello";
//        String regStr = "韩顺平教育|韩顺平老师|韩顺平同学";
// 改写为非捕获分组--和上面等价
String regStr = "韩顺平(?:教育|老师|同学)";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));// 不能用group(1)访问->没有捕获分组
}
/* 输出
找到：韩顺平教育
找到：韩顺平老师
找到：韩顺平同学
*/
```

2. (?=pattern)：匹配后面连接pattern的整体字符(不包括pattern)

```java
String content = "hello韩顺平教育 jack韩顺平老师 韩顺平同学hello";
String regStr = "韩顺平(?=教育|老师|同学)";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));// 不能用group(1)访问->没有捕获分组
}
/* 输出
找到：韩顺平
找到：韩顺平
找到：韩顺平
*/
```

3. (?!pattern)：匹配后面不连接pattern的整体字符(不包括pattern)

```java
String content = "hello韩顺平教育 jack韩顺平老师 韩顺平同学hello";
String regStr = "韩顺平(?!老师|同学)";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));// 不能用group(1)访问->没有捕获分组
}
/* 输出
找到：韩顺平 // 教育 前面的 韩顺平
*/
```

#### 特殊字符

- 非贪心模式：？

1. 当此字符紧随任何其他限定符 (*、+、?、、,,m)之后时，匹配模式是”非贪心的”。
2. "非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。
3. 例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"

```java
String content = "ooooo";
String regStr = "o+?"; // 非贪婪模式
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));// 不能用group(1)访问->没有捕获分组
}
/* 输出
找到：o
找到：o
找到：o
找到：o
找到：o
*/
```

```java
String content = "ooooo";
String regStr = "o+";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到：" + matcher.group(0));// 不能用group(1)访问->没有捕获分组
}
/* 输出
找到：ooooo
*/
```

- 其他补充：查正则表达式元字符-详细说明

#### 反向引用符

- 反向引用符: 见 ”分组-捕获-反向引用“ 部分

#### 元字符应用实例

- 汉字

```java
String content = "学前班教育";
// 汉字的正则匹配
String regStr = "^[\u0391-\uffe5]+$";
Pattern compile = Pattern.compile(regStr);
Matcher matcher = compile.matcher(content);
if (matcher.find()) {
    System.out.println("满足格式");
} else {
    System.out.println("不满足格式");
}
```

- 邮政编码：要求是1-9开头的一个六位数。比如: 123890

```java
String content = "617005";
// 邮编的正则匹配
String regStr = "^[1-9]\\d{5}$";
Pattern compile = Pattern.compile(regStr);
Matcher matcher = compile.matcher(content);
if (matcher.find()) {
    System.out.println("满足格式");
} else {
    System.out.println("不满足格式");
}
```

- QQ号码：要求:是1-9开头的一个(5位数-10位数) 比如: 12389，1345687，187698765

```java
String content = "973598033";
// 手机号的正则匹配
String regStr = "^[1-9]\\d{4,9}$";
Pattern compile = Pattern.compile(regStr);
Matcher matcher = compile.matcher(content);
if (matcher.find()) {
    System.out.println("满足格式");
} else {
    System.out.println("不满足格式");
}
```

- 手机号码：要求必须以13,14.15,18 开头的11位数，比如 13588889999

```java
String content = "15196502395";
// 手机号的正则匹配
String regStr = "^1[3|4|5|8]\\d{9}$";
Pattern compile = Pattern.compile(regStr);
Matcher matcher = compile.matcher(content);
if (matcher.find()) {
    System.out.println("满足格式");
} else {
    System.out.println("不满足格式");
}
```

- URL：https://www.bilibili.com/video/BV1fh411y7R8?from=search&seid=1831060912083761326

```java
String content = "https://blog.csdn.net/weixin_43708622/article/details/106507654";
// URL的正则匹配
String regStr = "^((http|https)://)([\\w-]+\\.)+[\\w-]+(/[\\w-?=&/%#.]*)?$";
Pattern compile = Pattern.compile(regStr);
Matcher matcher = compile.matcher(content);
if (matcher.find()) {
    System.out.println("满足格式");
} else {
    System.out.println("不满足格式");
}
```

### 三个常用类

#### Pattern

- Pattern类

1. pattern对象是一个正则表达式对象。Pattern 类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个 Pattern 对象。
2. 该方法接受一个正则表达式作为它的第一个参数 比如: Pattern r = Pattern.compile(pattern);

- Pattern类matches方法

1. 判断两个字符串是否**整体匹配**
2. 案例演示

```java
String content = "hello abc hello, 韩顺平教育";
String regStr = "hello.*";
boolean matches = Pattern.matches(regStr, content);
System.out.println("整体匹配=" + matches);
```

```java
// 简化URL匹配流程
String content = "https://blog.csdn.net/weixin_43708622/article/details/106507654";
String regStr = "^((http|https)://)([\\w-]+\\.)+[\\w-]+(/[\\w-?=&/%.]*)?$";
boolean matches = Pattern.matches(regStr, content);
System.out.println("是否匹配=" + matches);
// 使用matches 可以省略^和$定位符

/* 底层完成创建和匹配
public static boolean matches(String regex, CharSequence input) {
	Pattern p = Pattern.compile(regex);
	Matcher m = p.matcher(input);
	return m.matches();
}
*/
```

- 其他方法

![Matcher类常用方法](.\Java入门markdown图片\Matcher类常用方法.png)

![Matcher类常用方法2](.\Java入门markdown图片\Matcher类常用方法2.png)

1. start() 和 end() 案例演示

```java
// 使用start() 和end() 代替  matcher.group(0)
String content = "hello edu jack tom hello smith hello";
String regStr = "hello";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("=========");
    System.out.println(matcher.start());
    System.out.println(matcher.end());
    System.out.println("找到：" + content.substring(matcher.start(), matcher.end()));
    System.out.println("找到：" + matcher.group(0)); 
}
```

2. replaceAll()

```java
String content = "hello edu jauestcck tom hello smiuestcth hello";
String regStr = "uestc";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
// 返回替换后的字符串--原字符串不会修改
String newStr = matcher.replaceAll("电子科技大学");
System.out.println(newStr);
System.out.println(content);
```

#### Matcher

- Matcher类

Matcher 对象是对输入字符串进行解释和匹配的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得个Matcher 对象。

#### PatternSyntaxException

- PatternSyntaxException类

PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

### 分组-捕获-反向引用

- 提出需求

1. 请找出所有四个数字连在一起的子串，并且这四个数字要满足:
   - a.第1位与第4位相同,
   - b.第2位与第3位相同，
   - 比如:1221, 5775

- 正则表达式的相关概念

1. 分组

我们可以用圆括号组成一个比较复杂的匹配模式，一个圆括号的部分对应一个子表达式/一个分组。

2. 捕获

把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用， 从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则表达式。

3. 反向引用

圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用,这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用 \ \ 分组号，外部反向引用 $分组号

- 反向引用案例

1. 要匹配两个连续的相同数字;
2. 要匹配五个连续的相同数字;
3. 要匹配个位与干位相同，十位与百位相同的数 5225，1551.

```java
// 1.
String regStr = "(\\d)\\1";
// 2. 
String regStr = "(\\d)\\1{4}";
// 相当于(\\d)\\1\\1\\1
// 3.
String content = "1551a";
String regStr = "(\\d)(\\d)\\2\\1";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到："+ matcher.group(0));
}
```

4. 商品编号：要求满足前面是一个五位数,然后一个-号,然后是一个九位数,连续的每三位要相同

```java
String content = "21321-111222333";
String regStr = "\\d{5}-(\\d)\\1{2}(\\d)\\2{2}(\\d)\\3{2}";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println("找到："+ matcher.group(0));
}
```

- 结巴程序案例

把类似 :"我....我要....学学学学....编程java!"，通过正则表达式 修改成"我要学编程java"

```java
String content = "我....我要....学学学学....编程java!";
// 1. 去掉所有的 .
Pattern pattern = Pattern.compile("\\.");
Matcher matcher = pattern.matcher(content);
content = matcher.replaceAll("");
System.out.println("去掉点.的结果：" + content);

//        // 2. 去除重复的字
//        pattern = Pattern.compile("(.)\\1+");
//        matcher = pattern.matcher(content);
//        // 使用反向引用替换
//        content = matcher.replaceAll("$1");
//        System.out.println(content);

// 一条语句完成
content = Pattern.compile("(.)\\1+").matcher(content).replaceAll("$1");
System.out.println(content);
// 第一次匹配到"我我"用"我"替换
// 第一次匹配到"学学学学"用"学"替换
```

- String类中使用正则表达式

1. 替换：String 类 public String replaceAll(String regex,String replacement) : 支持正则表达式

```java
// 把JDK1.3 or JDK1.4 替换为 JDK
String content = "2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其获得了Apple公司Mac Os X的工业标准的支持。" +
    "2001年9月24日，J2EE1.3发布。2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升，" +
    "与J2SE1.3相比，其多了近62%的类和接口。";
content = content.replaceAll("JDK(?:1\\.3|1\\.4)", "JDK");
System.out.println(content);
```

2. 判断功能：String 类 public boolean matches(String regex) -- 判断字符串是否满足某些规则

```java
content = "13888889999";
if (content.matches("13(8|9)\\d{8}")) {
    System.out.println("验证成功");
} else {
    System.out.println("验证失败");
}
```

3. 分割功能

```java
content = "hello#abc-jack12smith~北京";
String[] splitList = content.split("#|-|~|\\d+");
for (String s: splitList) {
    System.out.println(s);
}
```



## 课后作业

### 网络编程作业

- 题目1

1. 使用字符流的方式,编写一个客户端程序和服务器端程序，
2. 客户端发送"name",服务器端接收到后，返回“我是nova ", nova是你自己的名字
3. 客户端发送"hobby",服务器端接收到后，返回“编写java程序”
4. 不是这两个问题，回复"你说啥呢”

```java
//字符流的网络通信
//服务器端
package InterneComChapter;

import com.sun.security.ntlm.Server;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class HomeworkServer {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("服务端,在9999端口监听,等待连接...");
        Socket socket = serverSocket.accept();
        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String str = bufferedReader.readLine();
        String ans = "";
        if ("name".equals(str)) {
            ans = "我是麻花疼";
        } else if ("hobby".equals(str)) {
            ans = "打CsGo";
        } else {
            ans = "你说啥子？";
        }

        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write(ans);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        bufferedWriter.close();
        bufferedReader.close();
        socket.close();
        System.out.println("Server程序运行结束");
    }
}
```

```java
//客户端
package InterneComChapter;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Scanner;

public class HomeworkClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入你的问题：");
        String quet = scanner.next();
        bufferedWriter.write(quet);
        bufferedWriter.newLine();
        bufferedWriter.flush();
        //
        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String str = bufferedReader.readLine();
        System.out.println(str);
        //
        bufferedReader.close();
        bufferedWriter.close();
        socket.close();
        System.out.println("客户端运行结束...");
    }
}
```

- 题目2

1. 编写一个接收端A,和一个发送端B，使用UDP协议完成
2. 接收端在8888端口等待接收数据(receive)
3. 发送端向接收端发送数据“四大名著是哪些"
4. 接收端接收到发送端发送的问题后，返回"四大名著是<<红楼梦>>..."，否则返回what?
5. 接收端和发送端程序退出

```java
//UDP协议的通信
```

- 题目3

1. 编写客户端程序和服务器端程序
2. 客户端可以输入一个音乐文件名，比如高山流水,服务端收到音乐名后，可以给客户端返回这个音乐文件，如果服务器没有这个文件，返回一个默认的音乐即可.
3. 客户端收到文件后，保存到本地 e:\ \
4. 提示:该程序可以使用 StreamUtils.java
5. 本质：再服务器端下载文件

```java
//服务器端
package InterneComChapter;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class HomeworkServer03 {
    public static void main(String[] args) throws IOException {
        //1.监听9999端口
        ServerSocket serverSocket = new ServerSocket(9999);
        //2.等待客户端连接
        System.out.println("服务端 在9999端口监听");
        Socket socket = serverSocket.accept();
        //3.读取 客户端发送的文件名
        InputStream inputStream = socket.getInputStream();
        byte[] b = new byte[1024];
        int len = 0;
        StringBuilder downloadFileName = new StringBuilder();
        while ((len = inputStream.read(b)) != -1) {
            downloadFileName.append(new String(b, 0, len));
        }
        System.out.println("文件名为" + downloadFileName);

        String resFileName = "";
        if ("高山流水".equals(downloadFileName)){
            resFileName = "src\\高山流水.mp3";
        } else {
            resFileName = "src\\无名.mp3";
        }
        //4.创建一个输入流读取文件
        BufferedInputStream bis =
                new BufferedInputStream(new FileInputStream(resFileName));
        //5.使用工具类StreamUtils ,读取文件到一个字节数组
        byte[] bytes = streamToByteArray(bis);//使用工具类
        //6.关联socket输入流
        BufferedOutputStream bos =
                new BufferedOutputStream(socket.getOutputStream());
        bos.write(bytes);
        socket.shutdownOutput();
        //关闭所有流
        bis.close();
        inputStream.close();
        socket.close();
        serverSocket.close();
        System.out.println("服务端程序退出");

    }
}
```

```java
//客户端
package InterneComChapter;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Scanner;

public class HomeworkClient03 {
    public static void main(String[] args) throws IOException {
        //1.接收用户输入,指定下载文件名
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入下载的文件名字");
        String downloadFileName = scanner.next();
        //2.客户端连接服务端，准备发送
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        //3.获取和Socket关联的输出流
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(downloadFileName.getBytes());
        socket.shutdownOutput();
        //4.读取服务端返回的文件(字节数据)
        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        byte[] bytes = StreamUtils.streamToByteArray(bis);//工具类的方法
        //5.得到一个输出流,准备将 bytes写入到磁盘文件
        String filePath = "";//文件名字
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));
        bos.write(bytes);
        //6.关闭相关的资源
        bos.close();
        bis.close();
        outputStream.close();
        socket.close();
    }
}
```

### 多用户通信项目

- 基本说明

1. 有趣的项目
2. 涉及Java各个方面的技术
   - 项目框架设计
   - java面向对象编程网络编程
   - 多线程
   - IO流
   - Mysql/使用集合充当内存数据库
3. 巩固旧知识,学习新知识

- 项目开发流程

需求分析-->设计阶段--->编码实现-->测试阶段-->实施阶段

- 需求分析

1. 用户登录
2. 拉取在线用户列表
3. 无异常退出
4. 私聊
5. 群聊
6. 发文件
7. 服务器推送新闻

- 功能实现-用户登录

1. 功能说明：用HashMap模拟数据库

   多用户和服务器端通信，服务器端可以在一个监听端口产生多个socket和不同的客户端进行通信；单个客户端也可能有多个线程和服务器端在同一个监听端口进行通信；通信的内容从字符/字节转变为存储信息的message类的对象

   <img src=".\Java入门markdown图片\多用户通信1.png" alt="多用户通信1" style="zoom:50%;" />

2.  思路分析+框架示意图

3. 代码实现

- 功能实现-无异常退出

1. 功能说明
2. 思路分析+程序框架图
3. 代码实现

```java
//子线程结束了--父线程还没退出
//解决方法
//客户端->在main线程调用方法发送终止信息->调用System.exit(0)//正常退出
//服务器端->接受终止信息->关闭socket->退出线程
```

- 功能实现-私聊

1. 功能说明
2. 思路分析+程序框架图
3. 代码实现

```java
//客户端A->Message发给服务器
//服务器->读取A的Message转发给B
//有Bug？？？
```

- 功能实现-发文件

1. 功能说明
2. 思路分析+程序框架图
3. 代码实现

- 功能实现-服务器推送新闻

1. 功能说明
2. 思路分析+程序框架图
3. 代码实现

- 补充内容--离线消息和文件的接受

1. 实现思路

ConcurrentHashMap存放key:getterId，Value:ArrayList< Message >的键值对信息

用户发送文件或者消息时，对象用户不存在时，就把消息/文件存入Map中

### 反射作业

- 练习1-通过反射修改私有成员变量

```java
package ReflectionTest;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class ReflectionHomework {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class<?> testCls = Class.forName("ReflectionTest.PrivateTest");
        Object o = testCls.newInstance();
        Field name = testCls.getDeclaredField("name");
        Method getName = testCls.getDeclaredMethod("getName");
        name.setAccessible(true);
        System.out.println(name.get(o));
        name.set(o, "Panda");
        System.out.println(getName.invoke(o));
    }

}
class PrivateTest {
    private String name = "hello Kitty";
    public String getName() {
        return name;
    }
}

```

- 练习2-反射创建文件对象

```java
package ReflectionTest;
import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public class ReflectionHomework2 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class<?> file = Class.forName("java.io.File");
        Constructor<?>[] constructors = file.getConstructors();
        for (Constructor<?> constructor : constructors) {
            System.out.println(constructor);
        }
        Constructor<?> declaredConstructor = file.getDeclaredConstructor(String.class);
        String filePath = "C:\\Users\\97359\\Desktop\\test.txt";
        Object o = declaredConstructor.newInstance(filePath);
        System.out.println(o.getClass());
        Method createNewFile = file.getDeclaredMethod("createNewFile");
        createNewFile.invoke(o);
    }
}
```

### 数据库练习

#### 选择题

1. 列的别名可以省略as

```mysql
SELECT empno,ename name,sal salary FROM emp;
-- 别名中间不能有空格
SELECT ename,sal*12 Annual Salary FROM emp;-- 错误演示
SELECT ename,sal*12 "Annual Salary" FROM emp;-- 可以用双引号引起来
```

2. 判断非空只能用 is not null

#### 操作题

1. 查看表结构

```mysql
DESC dept;
DESC emp;
```

2. 查询表的内容

```mysql
SELECT ename,sal
FROM emp
WHERE (deptno = 10 OR deptno = 30) AND sal > 1500
```

```mysql
SELECT * FROM emp WHERE deptno = 30;
--
SELECT * FROM emp WHERE IFNULL(comm, 0) > sal;
--
SELECT * FROM emp WHERE (deptno = 10 AND job = 'MANAGER') OR 
(deptno = 20 AND job = 'CLERK') OR
(job != 'CLERK' AND job != 'MANAGER');
-- 找出收取佣金的员工的不同工作
SELECT DISTINCT job FROM emp WHERE comm is NOT NULL;
-- 找出各月倒数第3天受雇的所有员工
SELECT LAST_DAY('2022-2-2'); -- 查找最后一天
SELECT DAY(LAST_DAY('2022-2-2')) - 2;
SELECT DAY(LAST_DAY('2022-2-2')) - DAY('2022-2-2') <= 3;
-- 找出早于12年前受雇的员工
SELECT * FROM emp WHERE DATE_ADD(hiredate,INTERVAL 12 YEAR) < NOW();
-- 以首字母小写的方式显示所有员工的姓名
SELECT CONCAT(LCASE(SUBSTRING(ename, 1, 1)), SUBSTRING(ename, 2)) FROM emp;
```

``` mysql
-- 显示不带有"R"的员工的姓名
SELECT * FROM emp WHERE ename not LIKE '%R%';
-- 显示所有员工姓名的前三个字符
SELECT LEFT(ename,3) FROM emp;
-- 显示所有员工的姓名,用a替换所有"A"
SELECT REPLACE(ename,'A','a') FROM emp;
--
SELECT * FROM emp ORDER BY ename;
--显示所有员工的姓名、工作和薪金,按工作降序排序,若工作相同则按薪金排序
SELECT ename, job, sal FROM emp ORDER BY job DESC, sal;
-- 显示所有员工的姓名、加入公司的年份和月份,按受雇日期所在月排序，若月份相同则将最早年份的员工排在最前面
SELECT ename, CONCAT(YEAR(hiredate),'-',MONTH(hiredate))
FROM emp
ORDER BY MONTH(hiredate), YEAR(hiredate);
-- 显示在一个月为30天的情况所有员工的日薪金，忽略余数
SELECT ename, sal / 30, FLOOR(sal/30) FROM emp;
-- 对于每个员工，显示其加入公司的天数
SELECT ename, DATEDIFF(NOW(),hiredate) FROM emp;
```

```mysql
-- 列出至少有一个员工的所有部门
SELECT COUNT(*) AS c, deptno
FROM emp
GROUP BY deptno
HAVING c > 1;
-- sal大于smith的员工
SELECT * FROM emp
WHERE sal > 
(
SELECT sal FROM emp WHERE ename = 'SMITH'
);
-- 列出受雇日期晚于其直接上级的所有员工。
-- 先把 emp 表当做两张表 worker ，leader
SELECT * FROM emp worker, emp leader 
WHERE worker.hiredate < leader.hiredate AND
worker.mgr = leader.empno;
-- 列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门。
SELECT dname, emp.*
FROM dept LEFT JOIN emp ON dept.deptno = emp.deptno;
-- 列出在部门“SALES”(销售部)工作的员工的姓名

-- 列出在每个部门工作的员工数量、平均工资和平均服务期限(时间单位)
SELECT COUNT(*) AS "部门员工数量", deptno, AVG(sal) AS "部门平均工资",
FORMAT(AVG(DATEDIFF(NOW(),hiredate) / 365), 2) AS '平均服务期限(年)'
FROM emp
GROUP BY deptno;
-- 列出所有部门的详细信息和部门人数
-- 1. 查询各部门人数
SELECT COUNT(*) AS c, deptno
FROM emp
GROUP BY deptno;
-- 2. 查看部门详细信息
SELECT dept.*, tmp.c
FROM dept, (
SELECT COUNT(*) AS c, deptno
FROM emp
GROUP BY deptno
) tmp
WHERE dept.deptno = tmp.deptno;
```

```mysql
-- 创建相关表



-- 系表
CREATE TABLE department (
departmentid VARCHAR(32) PRIMARY KEY,
deptname VARCHAR(32) UNIQUE NOT NULL
);
-- 班级表
CREATE TABLE `class` (
class_id INT PRIMARY KEY,
`subject` VARCHAR(32) NOT NULL DEFAULT '',
deptname VARCHAR(32),
enrolltime INT NOT NULL DEFAULT 2000,
num INT NOT NULL DEFAULT 0,
FOREIGN KEY (deptname) REFERENCES department(deptname)
);
-- 学生表
CREATE TABLE student (
id INT PRIMARY KEY,
`name` VARCHAR(32) NOT NULL DEFAULT '',
age INT NOT NULL DEFAULT 0,
classid INT,
FOREIGN KEY (classid) REFERENCES `class`(deptname)
);

INSERT INTO department VALUES
('001', '数学'),
('002','计算机'),
('003','化学'),
('004','中文'),
('005','经济');

INSERT INTO class VALUES
(101,'软件','计算机',1995,20),
(102,'微电子','计算机',1996,30),
(111,'无机化学','化学',1995,29),
(112,'高分了化学','化学',1996,25),
(121,'统计数学','数学',1995,20),
(131,'现代语言','中文',1996,20),
(141,'国际贸易','经济',1997,30),
(142,'国际金融','经济',1996,14);

INSERT INTO student VALUES
(8101,'张三',18,101),
(8102,'钱四',16,121),
(8103,'王玲',17,131),
(8105,'李飞',19,102),
(8109,'赵四',18,141),
(8110,'李可',20,142),
(8201,'张飞',18,111),
(8302,'周瑜',16,112),
(8203,'王亮',17,111),
(8305,'董庆',19,102),
(8409,'赵龙',18,101),
(8510,'李丽',20,142);

SELECT * FROM department;
SELECT * FROM class;
SELECT * FROM student;

-- 相关操作
-- 找出所有姓李的学生
SELECT * FROM student 
WHERE `name` LIKE '李%';
-- 学生张三退学，请更新相关的表
-- 开启事务
START TRANSACTION;
-- 张三所在班级的人数-1
UPDATE class SET num = num + 1
WHERE class_id = (
SELECT classid FROM student WHERE `name` = '张三'
);
DELETE FROM student WHERE `name` = '张三';
COMMIT;
```

### 满汉楼--大作业

- 管理系统的需求分析

1. 各模块的功能--各司其职
2. 数据库涉及的字段

- 开发工具类Utility

- 创建满汉楼的数据库

```mysql
-- 创建满汉楼的数据库
CREATE DATABASE mhl
-- 用户表
CREATE TABLE employee (
id INT PRIMARY KEY AUTO_INCREMENT, #自增
empId VARCHAR(50) UNIQUE NOT NULL DEFAULT '', #员工号
pwd CHAR(32) NOT NULL DEFAULT '', #密md5
NAME VARCHAR(50) NOT NULL DEFAULT '', #姓
job VARCHAR(50) NOT NULL DEFAULT '' #位
)CHARSET=utf8;
-- 添加测试员工
INSERT INTO employee VALUES(NULL, '6668612', MD5('123456'), '张三丰', '经理');
INSERT INTO employee VALUES(NULL, '6668622', MD5('123456'), '小龙女', '服务员');
INSERT INTO employee VALUES(NULL, '6668633', MD5('123456'), '张无忌', '收银员');
INSERT INTO employee VALUES(NULL, '6668666', MD5('123456'), '杰克马', '经理');
```

```mysql
// druid.properties -- 修改
url=jdbc:mysql://localhost:4306/mhl?rewriteBatchedStatements=true
```

```mysql
-- 创建diningTable表
CREATE TABLE diningTable (
id INT PRIMARY KEY AUTO_INCREMENT, #自增，表示餐桌编号
state VARCHAR(20) NOT NULL DEFAULT '', #餐桌的状态
orderName VARCHAR(50) NOT NULL DEFAULT '', #预订人的名字
orderTel VARCHAR(20) NOT NULL DEFAULT ''
)CHARSET=utf8;

INSERT INTO diningTable VALUES(NULL, '空', '', '');
INSERT INTO diningTable VALUES(NULL, '空', '', '');
INSERT INTO diningTable VALUES(NULL, '空', '', '');

SELECT id, state FROM diningTable
SELECT * FROM diningTable WHERE id = 1
UPDATE diningTable SET state='已经预定', orderName='周原平', orderTel=911 WHERE id=1
UPDATE diningTable SET state='空', orderName='', orderTel='' WHERE id=1 # 清空
```

- 创建menu表

```mysql
-- 创建menu表(id，name，type，price)
CREATE TABLE menu (
id INT PRIMARY KEY AUTO_INCREMENT, #自增，表示餐桌编号
`name` VARCHAR(50) NOT NULL DEFAULT '',
`type` VARCHAR(50) NOT NULL DEFAULT '',
price DOUBLE NOT NULL DEFAULT 0 # 价格
)CHARSET=utf8;
```

- 创建bill表

```mysql
-- 创建账单bill表（id, billid, menuid, nums, billDate, money, state, diningTableId）
CREATE TABLE bill (
id INT PRIMARY KEY AUTO_INCREMENT, #自增
billId VARCHAR(50) NOT NULL DEFAULT '', # 按照规则生成Uid
menuId INT NOT NULL DEFAULT 0,
nums INT NOT NULL DEFAULT 0,# 份数
money DOUBLE NOT NULL DEFAULT 0,
diningTableId INT NOT NULL DEFAULT 0,
billDate DATETIME NOT NULL,
state VARCHAR(50) NOT NULL DEFAULT '' # 状态 未结账,已经结账,挂单,现金,支付宝,坏账
)CHARSET=utf8;

SELECT * FROM bill
```

- 多表查询：查询账单和对应菜品的名字

1. domain：创建MultTableBean类
2. DAO：创建MultTableBeanDAO
3. Service：对应MultTableBeanService

- DAO换原的对象的属性名字和数据库的列名必须一致：底层调用的setXXX方法

1. 属性名称报错一致
2. 数据库的待称 AS name2

```mysql
SELECT bill.*, NAME AS name2
FROM bill, menu
WHERE bi11.menuId = menu.id  
```

### 正则表达式练习题

- 验证电子邮件格式是否命法

1. 只能有一个@
2. @前面是用户名,可以是a-z A-Z 0-9 字符
3. @后面是域名,并且域名只能是英文字母，比如 sohu.com 或者tsinghua.org.cn
4. 写出对应的正则表达式，验证输入的字符串是否为满足规则

```java
String content = "z.yp@usetc.edu.cn";
String regStr = "^[\\w-]+@([a-zA-Z]+\\.)+[a-zA-Z]+$";
// 注意 . 在()内表示任意字符， 在[]内表示 . 这个符号
if (content.matches(regStr)) { // matches()是整体匹配可以不加定位符
    System.out.println("匹配成功");
} else {
    System.out.println("匹配失败");
}
```

- 要求验证是不是整数或者小数：考虑正数和负数

```java
String content = "-0.11";
String regStr = "^-?([1-9]\\d*|0)(\\.\\d+)?$";
// String regStr = "^-?\\d*(\\.\\d+)?$"; // "-0034.11"也会通过
if (content.matches(regStr)) {
    System.out.println("匹配成功");
} else {
    System.out.println("匹配失败");
}
```

- 解析URL：获取协议、域名、端口、文件名

```java
String content = "http://www.sohu.com:8080/abc/xxx/index.htm";
String regStr = "([a-zA-Z]+)://([a-zA-Z.]+):(\\d+)[\\w-/]*/([\\w.]+)$";
Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
if (matcher.matches()) {
    System.out.println("整体匹配成功:" + matcher.group(0));
    System.out.println("协议：" + matcher.group(1));
    System.out.println("域名：" + matcher.group(2));
    System.out.println("端口：" + matcher.group(3));
    System.out.println("文件：" + matcher.group(4));
}
```

- 其他：查找Java正则表达式大全(根据具体业务调整)



# 牛客网_JAVA基础题目

- Java代码的初始化顺序

1. **父类(静态域按代码顺序加载)–>子类(静态域按代码顺序加载) –>父类(非静态变量,非静态代码块,构造函数)–>子类(非静态变量,非静态代码块,构造函数)**
2. **静态域：静态变量和静态块**

虚拟机规范严格规定了有且只有五种情况必须立即对类进行“初始化”： 

  \1.   使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。 

  \2.   使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。 

  \3.   当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。 

  \4.   当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类； 

  \5.   使用Jdk1.7动态语言支持的时候的一些情况。 

被动引用不会出发子类初始化 

   1.子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化 

   2.通过数组定义来引用类，不会触发此类的初始化 

   3.常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 

- JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大
- synchronized和volatile？
- 方法重载和方法重写的区别？

1. 方法的重写overriding和重载overloading是Java多态性的不同表现。 
2.  重写overriding是父类与子类之间多态性的一种表现，重载overloading是一个类中多态性的一种表现。 
3. 方法的重写的定义：在继承关系的子类中，定义一个与父类相同的方法 
4. 方法重载的定义：同一个类或与他的派生类中，方法名相同，而参数列表不同的方法。其中参数列表不同指的是**参数的类型，数量，类型的顺序**这三种至少有一种不同。

- List静态初始化和add

```java
public static void main(String[] args) {
    List<Integer> list = new ArrayList<Integer>() {
      {
        add(5);
        add(3);
        add(1);
      }
    }; // 静态初始化
    System.out.println(list.toString());
    list.add(6);
    System.out.println(list.toString());
    list.add(1, 4); // item, idx idx存在内容，idx及之后的内容往后移动
    System.out.println(list.toString());
    list.remove(1);
    System.out.println(list.toString());
}
```

- java类加载器
- 抽象类和接口的区别
- 包装类

1. **基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；

```java
int a = 220;
Integer b = 220;
System.out.println(a==b);//true
```

2. 两个Integer类型进行“==”比较，如果其值在-128至127 ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。
3. **两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。
4. **基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。

- Synchronized关键字

```java
public class Test {
    private synchronized void a() {
    }
    private void b() {
        synchronized (this) {
        }
    }
    private synchronized static void c() {
    }
    private void d() {
        synchronized (Test.class) {
        }
    }
}
```

1. 方法a为普通同步方法，同步方法使用的锁是固有对象this。
2. 方法b里面的是同步块，同步块使用的锁可以是任意对象，但是方法b里面的同步块使用的锁是对象this，所以方法a和方法b锁住的是同一个对象。
3. 方法c为静态同步方法，使用的锁是该类的字节码文件，也就是Test.class。
4. 方法d里面的也是同步块，只不过使用的锁是Test.class，所以方法c和方法d锁住的是同一个对象。

- 抽象类和接口区别

1. 构造函数：

   - 抽象类可以有构造函数，但，即使如此，也不能被实例化（无论其内部是否有抽象方法，都不能实例化）!

   - 接口没有构造函数，不能实例化!

2. 成员变量：
   - (1)抽象类可以有普通成员变量，接口不可以!
   - (2)接口中没有普通成员变量，但是可以有也只能有public static final的静态常量！（必须赋予初值）
   - 需要强调的是，接口中的这种静态常量是默认的，也就是只要是成员变量，无论是否显式的修饰，默认都是这样的！

3. 成员方法：

   - (1)抽象类中可以有非抽象方法，也可以没有抽象方法！

     -  接口中不能有实现的方法，所有方法都不能由自己实现！（jdk1.8新特性允许自己实现，下面会提到）

   - (2)抽象类中的抽象方法，理论上可以是任何访问修饰符修饰，所谓理论，就是代表java语法并不会反对。

     -  思考，如果使用private修饰符去修饰，则代表该方法私有，那无法被继承，又怎么去实现呢？所以private修饰毫无意义，

        但是，java语法是允许的，不会报错！

   - (3)而接口中的方法，默认隐式的使用public abstract修饰，也只能是使用这个修饰！（（jdk1.8新特性会有所不同）

   - (4)抽象类中可以包含static方法，但是接口不可以（jdk1.8新特性会有所不同）

4. 继承或实现的区别

   - (1)从本身出发，抽象类可以implements接口，并且完全可以不实现接口的方法，因为抽象本身就是允许抽象方法的！

   -  抽象类，也可以继承抽象类，并且也可以不实现所继承父类的抽象方法，而交由下层的具体实现类实现。而接口可以继承一个或多个接口，但是不能继承类。
   - (2)从其下层实现类出发，一个类只可以继承一个抽象类（java语言单继承特性），但是可以实现任意多个接口。

**jdk1.8**:

1. 允许在接口里**定义默认方法和类方法（类方法就是所谓的static静态方法）**
2. 默认方法可以通过**实现接口的类实例化的对象**来调用,而类方法就相对于工具方法
3. 需要注意的是，此处的静态方法只能被public修饰（或者省略不写），不能是private或者protected

- 继承抽象类：当一个实体类集成一个抽象类，必须实现抽象类中的抽象方法，抽象类本身没有错误，但是cat类编译通不过
- ClassLoader(类加载器)：

Java语言系统自带有三个类加载器:

1. Bootstrap classLoader最顶层的加载类，丰要加载核心类库，%JRE HOME%ib下的rt,iar、resources,jar、charsets,.jal和class
   等，另外需要注意的是可以通过启动ivm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如 java
   xbootclasspath/a:path 被指定的文件追加到默认的bootstrap路径中，我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。
2. Extention ClassLoader 扩展的类加载器，加载目录%JRE HOME%iblext日录下的jar包和class文件。还可以加载 -D
   java.ext.dirs 选项指定的目录。
3. Appclass Loader也称为SystemAppClass 加载当前应用的classpath的所有类

![牛客网Java基础题_1_1](.\Java入门markdown图片\牛客网Java基础题_1_1.png)

![牛客网Java基础题_1_2](.\Java入门markdown图片\牛客网Java基础题_1_2.png)

- 内部类和外部类的修饰符

1. 内部类可以是静态static的，也可用public，default，protected和private修饰

2. 外部类的修饰符只能是public，abstract，final 

- hashMap和hashtable方面的知识点

1. 关于HashMap的一些说法：    
   - a) HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 
   - b) HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。    
   - c) HashMap实现不同步，线程不安全。 HashTable线程安全    
   - d) HashMap中的key-value都是存储在Entry中的。    
   - e) HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性 
   - f) 解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。   
     - 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；  
     - 开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。  
     - 拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。      
2. Hashtable和HashMap的区别：    
   - a)  继承不同。     public class Hashtable extends Dictionary implements Map    public class HashMap extends  AbstractMap implements Map    
   - b) Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 
   - c) Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。    
   - d) 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。    
   - e) 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。    
   - f) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。     
   - 注：  HashSet子类依靠hashCode()和equal()方法来区分重复元素。   HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过

- 接口方法的实现

1. 方法的重写需要满足：三同一大一小（方法名、返回值类型、形参相同；访问权限>=重写前；抛出异常<=重写前）
2. 接口中每一个方法也是隐式抽象的,接口中的方***被隐式的指定为 **public abstract**
3. 接口中可以含有变量，但是接口中的变量会被隐式的指定为       **public static final**

- 单例模式
- 继承

1. 父类有有参构造器时且没有无参构造器时，子类需要显式调用父类的无参构造器。

- socket连接

<img src=".\Java入门markdown图片\Java题目_socket连接.png" alt="Java题目_socket连接" style="zoom:50%;" />

- JVM常见操作

   1、jps：查看本机java进程信息。 

    2、jstack：打印线程的**栈**信息，制作线程dump文件。 

    3、jmap：打印内存映射，制作**堆**dump文件 

    4、jstat：性能监控工具 

    5、jhat：内存分析工具 

    6、jconsole：简易的可视化控制台 

    7、jvisualvm：功能强大的控制台

- Java的类加载机制

![牛客网Java基础题_Java类加载机制](.\Java入门markdown图片\牛客网Java基础题_Java类加载机制.png)

- volatile关键字

# Java面试题

## Java基础

- **fail-fast、fail-safe机制**

1. fail-fast**（快速失败）**机制是**Java集合**(Collection)中的一种**错误机制**。 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出**Concurrent Modification Exception**（并发修改异常）。
2. fail-safe

- HashMap是怎么解决哈希冲突的?

1. 解决hash冲突的方法？

# 待完成事项

## 1.追一下集合课后作业HashSet添加和删除的源码--为啥删除不掉

## 2.数据库作业

![作业1](.\Java入门markdown图片\作业1.png)

# 注意和常用快捷键

- 快捷键

1. Ctrl + Alt + T 环绕选项
2. Ctrl + Alt + L 快速格式化
3. Alt + entry 快速引用