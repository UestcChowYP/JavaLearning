## 注意事项

- 注意所有元素相同，能不能同时取等于或同时不取等于的情况

1. [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

## Z.基础知识

### 算法复杂度

1. 时间复杂度
2. 空间复杂度
3. 复杂度的渐进表示

- O上界，小于等于
- Ω下界，大于等于
- θ相等

### Java基本数据结构

#### 字符串(String)

- String

```java
String str = " abc";
String concat = str.concat(" zyp SYJ  ");
System.out.println(concat.toUpperCase()); // 大写
System.out.println(concat.toLowerCase()); // 小写
System.out.println(concat.charAt(5));
System.out.println(str);
System.out.println(concat.trim()); // 除去开头结尾的空额
String[] arrStr = concat.split(" ");
System.out.println(Arrays.toString(arrStr));
System.out.println(Arrays.toString(concat.trim().split(" ")));
```

- StringBuffer

```java
StringBuffer buffer = new StringBuffer("abc");
buffer.append("zyp");
buffer.insert(2, "ABC");
System.out.println(buffer.toString());
buffer.delete(3, 4);
System.out.println(buffer.capacity() + " " + buffer.length());
StringBuffer strReverse = buffer.reverse();
System.out.println(strReverse);
```

#### 数组(Arrays)

- 基本说明

数组（Arrays）是一种基本的数据结构，可以存储固定大小的相同类型的元素。

```java
int[] array = new int[5];
```

#### 列表(Lists)

- 基本说明

1. 接口
2. Java 提供了多种列表实现，如 ArrayList 和 LinkedList。

```java
List<String> arrayList = new ArrayList<>();
List<Integer> linkedList = new LinkedList<>();

// 常用方法
// 1. 数组和集合互相转换
toArray()
asList()
```

#### 集合(Sets)

- 基本说明

1. 接口
2. 集合（Sets）用于存储不重复的元素，常见的实现有 HashSet 和 TreeSet。

```java
Set<String> hashSet = new HashSet<>();
Set<Integer> treeSet = new TreeSet<>();
```

#### 映射(Maps)

- 基本说明

1. 接口
2. 映射（Maps）用于存储键值对，常见的实现有 HashMap 和 TreeMap。

```java
Map<String, Integer> hashMap = new HashMap<>();
Map<String, Integer> treeMap = new TreeMap<>();
```

3. hashmap的增删改查

```java
map.put(key, value);
map.get(key);
getOrDefault(key, def);
map.remove(key);
```



#### 栈(Stack类)

- 基本说明

1. 栈（Stack）是一种线性数据结构，它按照后进先出（Last In, First Out，LIFO）的原则管理元素。在栈中，新元素被添加到栈的顶部，而只能从栈的顶部移除元素。这就意味着最后添加的元素是第一个被移除的。

```java
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.push(2);
stack.pop();
System.out.println(stack.empty());
System.out.println(stack.peek());
```

#### 队列(Queue接口)

- 基本说明

1. 队列（Queue）遵循先进先出（FIFO）原则，常见的实现有 LinkedList 和 PriorityQueue。
1. ArrayDeque是 Deque的实现类，可以作为栈来使用，效率高于 Stack；也可以作为队列来使用，效率高于 LinkedList。(JDK文档)

```java
Queue<String> queue = new LinkedList<>();
```

- ArrayDeque的常用操作

1. 队列操作

```java
ArrayDeque<Integer> queue = new ArrayDeque<>();
        queue.offer(1);
        queue.add(2);
        queue.offer(3);
        queue.poll();
        System.out.println(queue);
        System.out.println(queue.peek());
        System.out.println(queue.size());
        System.out.println(queue.remove());
        System.out.println(queue);
```



```java
add(E e) 在队列尾部添加一个元素
offer(E e) 在队列尾部添加一个元素，并返回是否成功
remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())
poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())
element() 获取第一个元素，如果没有将抛出异常
peek() 获取第一个元素，如果返回null
```

2. 栈操作

```java
push(E e) 栈顶添加一个元素
pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常
```

- LinkedList

```java
Queue<Integer> queue = new LinkedList<>(); // 运行类型Queue，只能使用queue的方法
        queue.offer(1);
        queue.add(2);
        queue.offer(3);
        queue.poll();
        System.out.println(queue);
        System.out.println(queue.peek());
        System.out.println(queue.size());
        System.out.println(queue.remove());
        System.out.println(queue);
```

- LinkerHashMap(双端队列)

#### 堆(Heap)

- 基本说明

1. 堆（Heap）优先队列的基础，可以实现最大堆和最小堆。

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>(); // 默认小根堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
queMax = new PriorityQueue<>((a, b) -> (b-a)); // Lambda表达式实现comparator接口类
```

```java
PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1 - o2; // 小顶堆
    }
});
priorityQueue.add(3);
priorityQueue.add(4);
priorityQueue.add(5);
priorityQueue.add(2);
priorityQueue.offer(1);
priorityQueue.poll();
System.out.println(priorityQueue);
```

- 常用方法

1. **boolean add（object）**：将指定的元素插入此优先级队列。
2. **boolean offer（object）**：将指定的元素插入此优先级队列。
3. **boolean remove（object）**：从此队列中删除指定元素的单个实例（如果存在）。
4. **Object poll（）**：检索并删除此队列的头部，如果此队列为空，则返回null。
5. **Object element（）**：检索但不删除此队列的头部，如果此队列为空，则返回null。
6. **Object peek（）**：检索但不删除此队列的头部，如果此队列为空，则返回null。
7. **void clear（）**：从此优先级队列中删除所有元素。
8. **Comparator comparator（）**：返回用于对此队列中的元素进行排序的比较器，如果此队列根据其元素的自然顺序排序，则返回null。
9. **boolean contains（Object o）**：如果此队列包含指定的元素，则返回true。
10. **Iterator iterator（）**：返回此队列中元素的迭代器。
11. **int size（）**：返回此队列中的元素数。
12. **Object [] toArray（）**：返回包含此队列中所有元素的数组。

#### 哈希表

- Hashtable
- HashMap
- Treemap：基于红黑树
- HashMap和Hashtable

1.  继承和实现方式不同
   - HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
   - Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。
2. 线程安全不同HashMap线程不安全，Hashtable线程安全
3. null不同
   - HashMap的key、value都可以为null。
   - Hashtable的key、value都不可以为null。
4. 遍历形式
   -  HashMap只支持Iterator(迭代器)遍历。
   - Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历
   - 两者迭代器遍历顺序还不同
5. 初始容量和扩容方式不同

## A.排序算法

### 常见的排序算法及其复杂度

![排序算法1](.\算法与数据结构刷题笔记_图片\排序算法1.png)

### 1.冒泡排序-时间复杂的O(n2)

- 基本说明

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 2.选择排序-时间复杂的O(n2)

- 基本说明

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

### 3.插入排序-时间复杂的O(n2)

- 基本说明

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

### 4.归并排序Merge Sort-O(nlogn)***

- 基本说明

1. master公式求解时间复杂度--下次遇到再看一遍视频吧

- 实现代码

```java
//归并排序--指针++化简版本
class Solution {
    public int[] sortArray(int[] nums) {
        merge(nums, 0, nums.length - 1);
        return nums;
    }
    public void merge(int[] nums, int left, int right) {
        if (left >= right) {
            return;
        }
        int mid = (right - left) / 2 + left;
        merge(nums, left, mid);
        merge(nums, mid + 1, right);
        int[] arrNew = new int[right - left + 1];
        int p1 = left, p2 = mid + 1, p0 = 0;
        while (p1 <= mid && p2 <= right) {
            if (nums[p1] < nums[p2]) {
                arrNew[p0++] = nums[p1++];
            } else {
                arrNew[p0++] = nums[p2++];
            }
        }
        while (p1 <= mid) {
            arrNew[p0++] = nums[p1++];
        }
        while (p2 <= right) {
            arrNew[p0++] = nums[p2++];
        }
        for (int i = 0; i < arrNew.length; i++, left++) {
            nums[left] = arrNew[i];
        }
        return;
    }
}
```

```python
def merge_sort(nums, left, right):
    if left >= right:
        return
    mid = left + (right - left) // 2
    merge_sort(nums, left, mid)
    merge_sort(nums, mid + 1, right)
    p1, p2 = left, mid + 1
    arr_rus = []
    while p1 <= mid and p2 <= right:
        if nums[p1] > nums[p2]:
            arr_rus.append(nums[p2])
            p2 += 1
        else:
            arr_rus.append(nums[p1])
            p1 += 1
    while p1 <= mid:
        arr_rus.append(nums[p1])
        p1 += 1
    while p2 <= right:
        arr_rus.append(nums[p2])
        p2 += 1
    nums[left: right + 1] = arr_rus
    return nums

arr_one = [22, 8, 1, 100, 15, 20, 99, 5, 7, 27, 5, 1, 0]
print(merge_sort(arr_one, 0, len(arr_one) - 1))
```

### 5.快排->荷兰国旗问题->快排->快排3.0->O(nlogn)***

- 荷兰国旗问题

1. 荷兰国旗的前置问题->把一个数组，大于num的放右边，小于num的放左边
2. 把一个数组，大于num的放右边，小于num的放左边，等于num的放中间
   - 要求：时间复杂度O(n)，空间复杂度O(1)-不能创建新数组
   - 三指针
     - 小于指针：小于时，小于指针右移动
     - 大于指针：大于时，小于指针左移动，与遍历指针的数交换位置
     - 遍历指针：等于时，下一个位置

- 快排

1. 快排1.0-O(n_2)
   - 从最后一个数开始，进行荷兰国旗前置问题->插入数组->数组被分为两个部分->两个部分分别重复
2. 快排2.0-O(n_2)
   - 选数组最后一个数为num进行荷兰国旗问题，左右进递归->排序好的数组
3. 快排3.0-O(nlogn)
   - 随机选择一个数放在数组的最后进行快排，每种情况变成等概率事件，时间复杂度变为O(nlogn)->空间复杂度O(logn)

```java
//快排3.0
class Solution {
    public int[] sortArray(int[] nums) {
        sort(nums, 0, nums.length - 1);
        return nums;
    }
    public void sort(int[] nums, int l ,int r) {
        if (l >= r) {return;
        } else {
            int key = (int) Math.random() * (r - l) + l;
            swap(nums, key, r);
            int[] lessAndMore = partition(nums, l, r);
            sort(nums, l, lessAndMore[0] - 1);
            sort(nums, lessAndMore[1] + 1, r);
        }
    }
    public int[] partition(int[] nums, int l ,int r) {
        int less = l-1;
        int more = r;
        while (l < more) {
            if (nums[l] < nums[r]) {
                swap(nums, ++less, l++);
            } else if (nums[l] > nums[r]) {
                swap(nums, l, --more);
            } else {
                l++;
            }
        }
        swap(nums, r, more);
        return new int[] {less + 1, more};
    }

    public void swap(int[] nums, int idx1, int idx2) {
        int temp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = temp;
    }
}
```

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def quick_sort(nums):
            if nums == [] or len(nums) < 2:
                return nums
            sort(nums, 0, len(nums) - 1)
            return nums


        def sort(nums, l, r):
            if l < r:
                rand_num = random.randint(l, r)
                nums[rand_num], nums[r] = nums[r], nums[rand_num]  # 交换位置
                less, more = partition(nums, l, r)
                sort(nums, l, less - 1)
                sort(nums, more + 1, r)


        def partition(nums, l, r):
            less = l - 1
            more = r
            while l < more:
                if nums[l] > nums[r]:
                    more -= 1
                    nums[l], nums[more] = nums[more], nums[l]

                elif nums[l] < nums[r]:
                    less += 1
                    nums[less], nums[l] = nums[l], nums[less]
                    l += 1

                else:
                    l += 1
            nums[r], nums[more] = nums[more], nums[r]
            return less + 1, more
        quick_sort(nums)
        return nums
```

### 6.堆排(heap-堆)***

- 相关概念

1. 完全二叉树：完全二叉树的高度：O(logn)
2. 满二叉树
3. 堆
   - 大根堆
     父节点的位置的数都比子节点的数大
   - 小根堆

- heap中两个重要操作-O(logn)

1. heapinsert：添加新的数，并让结构保持大/小根堆
2. heapify

- 大根堆排序

1. 把数组的数从0开始依次heapinsert插入大根堆

<img src=".\算法与数据结构刷题笔记_图片\heapinsert.png" alt="heapinsert" style="zoom:50%;" />

2.  把最大值放到最后，heapsize--，再依次heapify

```java
//特别注意heapify和heapinsert的含义
class Solution {
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            heapInsert(nums, i);
        }
        int heapNum = len-1;
        while (heapNum > 0) {
            swap(nums, 0, heapNum);
            heapify(nums, 0, --heapNum);//最大值不用再调整！！！！
        }
        return nums;
    }
    public void heapInsert(int[] nums, int idx) {
        while ((idx-1)/2 >= 0 && nums[idx] > nums[(idx-1)/2]) {
            swap(nums, idx, (idx-1)/2);
            idx = (idx-1)/2;
        }
    }
    public void heapify(int[] nums, int idx, int heapSize) {
        int left = idx*2 + 1;
        while (left <= heapSize) {
            //右孩子存在且大于的时候才能选右孩子
            int maxIdx = left+1 <= heapSize && nums[left+1] > nums[left] ? left + 1 : left;
            if (nums[idx] >= nums[maxIdx]) {
                return;
            } else {
                swap(nums, idx, maxIdx);
                idx = maxIdx;
                left = idx*2 + 1;
            }
        }
    }
    public void swap(int[] nums, int idx1, int idx2) {
        int temp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = temp;
    }
}
```

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def heap_insert(nums, idx):
            while nums[idx] > nums[(idx-1)//2] and (idx-1)//2 >= 0:
                nums[idx], nums[(idx-1)//2] = nums[(idx-1)//2], nums[idx]
                idx = (idx-1)//2
            return nums


        # 从上向下变成堆->原来是堆的结构继续保持是堆
        def heapify(nums, idx, heapsize):
            left = idx * 2 + 1
            while left <= heapsize:  # 判断是否有子节点->只有左孩子left = heapsize
                largest = left + 1 if left + 1 <= heapsize and nums[left + 1] > nums[left] else left  # 找子节点中下标大的点
                largest = largest if nums[largest] > nums[idx] else idx  # 找到父节点和子节点中最大的值
                if largest == idx:
                    break
                else:
                    nums[idx], nums[largest] = nums[largest], nums[idx]
                    idx = largest
                    left = idx * 2 + 1


        def heap_sort(nums):
            if nums == [] or len(nums) < 2:
                return
            else:
                for i in range(len(nums)):
                    heap_insert(nums, i)
            heap_size = len(nums) - 1
            nums[0], nums[heap_size] = nums[heap_size], nums[0]
            while heap_size > 1:
                heapify(nums, 0, heap_size-1)
                heap_size -= 1
                nums[0], nums[heap_size] = nums[heap_size], nums[0]
        heap_sort(nums)
        return nums;
```

- 数组与堆的转换关系

1. 用数组的连续一段表示一个完全二叉树

   <img src=".\算法与数据结构刷题笔记_图片\数组与二叉树的关系.png" alt="数组与二叉树的关系" style="zoom:50%;" />

2. 二叉树某节点的左子节点idx = 2 * i + 1, 右子节点idx = 2 * i + 2, 父节点(i-1)/2
3. 让数组连续的一段转化为堆：用户一个一个的给数字，并让其堆化，让每一个小的二叉树都堆化->整个数据就堆化了

- - heapinsert：从下往上移动。让数插入原大根堆的最后位置，从后往前(从下往上)移动到自己的位置。

```java
//heapinsert--从下往上调整
//某个数现在处在index位置,往上继续移动
public static void heapInsert(int[] arr, int index) {
    while (arr[index] > arr[(index - 1) / 2]) {
        swap(arr, index, (index - 1)/2);
        index = (index - 1)/2 ;
    }
}
```

- - heapify：从上往下移动。从idx位置开始，与自己的子节点进行比较，比自己大就交换。插入一个新的数让原大根堆的结构不再是大根堆，把结构调整为大根堆->新插入的数跟父节点比较--直到父节点小于等于自己。

```java
//heapify从下往上调整
public static void heapify(int[] arr, int index，int heapSize){
	int left = index * 2 + 1;//左孩子的下标
    while (left < heapsize) { //下方还有孩子的时候
        //两个孩子中，谁的值大，把下标给largest
        int largest = left + 1 < heapSize && arr[left + 1] >arr[left] ? left +1 : left;
        //父和孩子之间，谁的值大，把下标给largest
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            break;
        } else {
            swap( arr，largest， index);
            index = largest;
            left = index * 2 + 1;
        }
    }
}	
```

4. 堆的常用操作

- - 找到最大值并拿出最大值以后还继续保持堆结构

    拿出最大值(0位置的值)；heapsize-1；把最后位置的值放到第一位置，从该位置开始，与自己的子节点比较，比自己大的值换上来。

- - 把中间任意位置的数换为一个新的数
  - 比原数大，进行heapinsert
  - 比原数小，进行heapify

### 7.计数排序(不基于比较的排序)-与比较大小无关的排序-O(n)

- 适用范围：()已知数据的分布范围。比如：年龄分布在0-150之间

统计每一个数出现的次数->词频表->还原为原数组--时间复杂度O(N)

### 8.基数排序(不基于比较的排序)-数字必须有进制-空间换时间

- 基本思路

1. 准备10个桶(桶可以是任意数据结构--根据数据的状态和排序的要求选择)->按照个位数字的大小把数字放入对应桶中->按桶的编号从小到大依次拿出来-相同桶内的数先进先出

2. 有多少个十进制位->入桶出桶多少次(个位排序入桶出桶-十位排序入桶出桶-百位排序入桶出桶...)

   利用count数组完成出桶入桶->count数组对应位置表示某一位数中<=idx的数有多少个

   从右往左放入help数组中，相当于完成先入桶的先出桶过程

3. 通常对正整数排序

<img src=".\算法与数据结构刷题笔记_图片\基数排序1.png" alt="基数排序1" style="zoom:50%;" />

- 实现代码

1. 通过词频统计表->获得词频前缀表(某位数<=idx的数有多少个)->获得倒出桶后该数的位置。

2. 整体代码

```java
//only for no-negative value
public static void radixSort(int[] arr) {
    if (arr == null || arr.length < 2) {
    	return;
    }
    radixSort(arr, 0, arr.length - 1, maxbits(arr)) ;
}
public static int maxbits( int[ ] arr) {
	int max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
    	max = Math.max(max, arr[i]);
    }
    int res = 0;
    while (max != 0) {
        res++;
        max /= 10;
    }
	return res;
}


public static void radixSort(int[] arr，int L, int R，int digit){
	final int radix = 10;//10进制
	int i = 0, j = 0;
    //有多少个数准备多少个辅助空间
    int[]bucket = new int[R - L + 1];
	for (int d = 1; d <= digit; d++) { //有多少位就进出几次
    // 10个空间
    // count[0]当前位(d位)是e的数字有多少个
    // count[1]当前位(d位)是(0和1)的数字有多少个
    // count[2当前位(d位)是(0、1和2)的数字有多少个
    // count[ij当前位( d位)是(0~i)的数字有多少个
        int[] count = new int[radix];// count[e..9]
    	for(i = L; i <= R; i++) {//统计词频表
			j = getDigit(arr[i], d);
            count[j]++;
		}
        for (i = 1; i < radix; i++) {//处理为前缀和
            count[i] = count[i] + count[i - 1];
        }
        for (i = R; i >= L; i--) {//倒出桶的顺序--根据前缀和数组找到对应的位置
            j = getDigit(arr[i], d);
            bucket[count[j] - 1] = arr[i];
            count[j]--;
        }
        for (i = L, j = 0; i <= R; i++，j++){//还原给原数组
        	arr[i] = bucket[j];
        }
    }
}


public static int getDigit(int x, int d) {
	return ((x / ((int) Math.pow( 10，d - 1))) % 10);//第d位的数的值
}

```

### 9.希尔排序->插入排序的变种

### 10.比较器排序->重载比较运算符

- 基本说明

1. python可以利用sort()/sorted()自定义比较器排序
2. Java的重载比较器
   - 返回负数的时候，第一个参数排在前面
   - 返回正数的时候，第二个参数排在前面
   - 返回0的时候，i谁在前面无所谓

```java
//重载比较运算符--匿名内部类
import java.util.Arrays;
import java.util.Comparator;

/**
 * @version 1.0
 * @auther Meez
 */
public class compareTest {
    public static void main(String[] args) {
        Student[] arr = new Student[3];
        Student a = new Student("A", 1, 20);
        Student b = new Student("B", 12, 19);
        Student c = new Student("C", 7, 23);
        arr[0] = a;
        arr[1] = b;
        arr[2] = c;
        Arrays.sort(arr, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return o1.getAge() - o2.getAge();//按照年龄的大小进行比较-升序
            }
        });
        System.out.println(Arrays.toString(arr));

    }
}
class Student {
    private String name;
    private int id;
    private int age;

    public Student(String name, int id, int age) {
        this.name = name;
        this.id = id;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", age=" + age +
                '}';
    }
}

```

#### 比较器调整大/小根堆的实现

```java
//PriorityQueue默认实现小根堆
import java.util.Comparator;
import java.util.PriorityQueue;
/**
 * @version 1.0
 * @auther Meez
 */
public class PriorityQueueTest {
    public static void main(String[] args) {
        PriorityQueue<Integer> heap = new PriorityQueue<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        heap.add(1);
        heap.add(7);
        heap.add(4);
        heap.add(4);
        heap.add(10);
        while (!heap.isEmpty()) {
            System.out.println(heap.poll());
        }
    }
}
```

3. 跟有序相关的数据结构都可以用重载比较运算符实现

### 排序补充说明

- 不基于比较的排序通常需要考虑数据的状况

- 稳定性：值相同的元素在排序过后的顺序不变->对于非基本类型的数据排序有重要意义

- 总结
  	时间复杂度-空间复杂度-稳定性
  		时间复杂度-空间复杂度-稳定性通常不能兼顾->根据需求选择算法
  	选择排序：O(N_2)-O(1)-无
  	冒泡排序：O(N_2)-O(1)-有
  	插入排序：O(N_2)-O(1)-有
  	归并排序：O(NlogN)-O(N)-有
  	快排排序：O(NlogN)-O(logN)-无
  	堆排序：O(NlogN)-O(1)-无
  	通常使用快排-对空间复杂度有要求时选择堆排-需要稳定性时选择归并
  	了解：归并排序的内存缓存法-空间复杂度O(1)->不稳定->没有意义

  不具备稳定性的排序:选择排序、快速排序、堆排序
  具备稳定性的排序:冒泡排序、插入排序、归并排序、一切桶排序思想下的排序
  
- 充分利用O(N_2)和O(NlogN)的优势和特点

  综合排序->样本小于60用插入排序-样本大于60用快排->综合优势
  基础数据类型：用快排->稳定性不重要
  非基础数据类型：用归并->稳定性重要

- 排序算法常见的坑

1. 归并排序的额外空间复杂度可以变成0(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序内部缓存法”
2. “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成0(N^2)
3. 快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“O1stable sort”
4. 所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复杂度0(1)，又稳定的排序。
5. 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。

```java
/*关于第五点的思考
遍历一次，用荷兰国旗方法把奇数放左边偶数放右边、-->会破坏稳定性--相对次序改变
对奇数和偶数分别进行排序
*/
```



### 排序相关题目

#### leetcode_912. 排序数组

#### 归并排序的扩展问题

##### 小和问题

- 基本思路

1. 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
2. 例子:[1,3,4,2,5]1左边比1小的数，没有;3左边比3小的数，1;4左边比4小的数，1、3;2左边比2小的数，1;5左边比5小的数，1、3、4、
3. 解决思路：先排序再merge，下标直接反应有多少小和，左边的部分先存储在辅助列表中

##### 逆序对问题-小和问题的逆问题

[LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

- 基本思路

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

#### 堆排序扩展题目

##### 让一个几乎有序的数组排好序（几乎有序：移动距离不超过k就可以排好序）

- 基本思路

1. 小根堆结构
   - 先取k个数排成小根堆->k之后的数不可能出现在0位置
   - 将最小值弹出->把k+1放入->再小根堆化
   - 重复->最后k个数一次弹出并堆化
   - 时间复杂度O(nlogK)
2. python有产生小根堆的内置标准库--Java？
   - https://docs.python.org/zh-cn/3/library/heapq.html
3. Java的小根堆

```java
//PriorityQueue默认小根堆
PriorityQueue<Integer> heap = new PriorityQueue<Integer>();
//增
heap.add(8);
heap.add(9);
//弹出
heap.poll();
//扩容机制->翻倍扩容
```

## B.表

### 1.哈希表

- 特点

1. 一种集合结构
2. 只有key没有value->hashset结构
3. 既有key又有value->hashmap结构
4. 有无value是上述二者唯一的区别，底层结构是同样的
5. 哈希表的增删改查时间复杂度可以看做是O(1),但是常数时间比较大
6. 哈希表的存放
   - 基本数据类型->内存占用：数据的大小
   - 非基本数据类型->内存占用：内存地址的大小

### 2.有序表

- 特点

1. 一种集合结构
2. 只有key没有value->treeset结构
3. 既有key又有value->treemap结构
4. 有无value是上述二者唯一的区别，底层结构是同样的
5. 有序表和哈希表的区别：有序表按key把数据有序的组织，哈希表无序
6. 哈希表的增删改查时间复杂度可以看做是O(logN),但是常数时间比较大

- 使用

```java
//在Java语言中TreeMap就是有序表
//TreeMap的增删改查
TreeMap<Integer, String> treeMap1 = new TreeMap<>();
treeMap1.put(7，"我是7");//增、改
treeMap1.put(5，“我是5");
treeMap1.put(4，“我是4");
treeMap1.put(3，"我是3");
treeMap1.put(9，"我是9");
treeMap1.put(2，"我是2");
system.out.print1n(treeMap1.containsKey(5));//查
system.out.print1n(treeMap1.get(5));//查
system.out.println(treeMap1.firstKey() + "，我最小");
system.out.print1n(treeMap1.lastKey() + "，我最大");
System.out.println(treeMap1.floorKey(8) + "，在表中所有<=8的数中，我离8最近");
System.out.println(treeMap1.ceilingKey(8) + "，在表中所有>=8的数中，我离8最近");
system.out.println(treeMap1.floorKey(7) + "，在表中所有<=7的数中，我离7最近");
system.out.println(treeMap1.ceilingKey(7) + "，在表中所有>=7的数中，我离7最近");
treeMap1.remove(5);//删
```

### 3.单链表

- 说明

单链表需要算法的题目很少，大部分直接写code

1. 尽量使用时间复杂度低的方法->尽可能的省空间---->所有链表的题目：分笔试和面试的情况都联系
2. 重要技巧
   - 额外数据结构记录
     Python：hashmap->dic；hashset->set
   - 快慢指针
     快指针一次两步，慢指针一次一步->确定链表的中心位置
     注意偶数时中间的条件->多写题练习

3. 判断是否有环
   - hashset里是否存在原来的节点
   - 快慢指针->快慢指针总会相遇->相遇时快指针回到head位置，一次一步->快慢指针在环的入口相遇
   - 数学角度理解(环内a节点/环外b节点)：到达环入口必须走a+nb步；
     F:2s=a+nb+c
     S:s=a+mb+c
     ->s=xb回到结点还差a步
   - 判断是否相交
     有相交部分最后一个节点一定相等->记录两个链表的长度->判断最后一个节点是否相同->判断相交节点：长链表先走差值，相遇时为交点
     进阶方法：两个指针同时遍历A，B链表

4. 混合情况->两个有环链表，返回第一个相交节点
   	1.都没有环，判断是否相交
   	2.一个有环和一个无环，相交->不存在->一定不相交
   	3.两个链表都有环
   		a.各自成环->在loop2处继续往前走，loop2位置继续转一圈不能遇到loop1为该情况->返回None
   		b.公共环，入环节点相同->loop1 == loop2->两个链表相交的思想
   		c.公共环，入环节点不相同->在loop2处继续往前走，loop2位置继续转一圈能遇到loop1为该情况->loop1和loop2都是两个链表相交的节点->返回一个即可
   	题目写法：获取两个链表的loop->无环情况->有环情况




## 表相关题目

### 链表题目

##### [leetcode_206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

- 实现代码

```java
//迭代法
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

```java
//递归-->反转从某一个节点开始的链表
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

##### [leetcode_234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

- 实现代码

```java
//链表反转思想--时间复杂度O(N)--空间复杂度O(1)
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {return true;}
        ListNode halfNode = getHalfNode(head);
        ListNode reHead = reverse(halfNode.next);
        ListNode h = head;
        ListNode t = reHead;
        while (reHead != null) {
            if (reHead.val != h.val) {
                return false;
            }
            reHead = reHead.next;
            h = h.next;
        }
        reverse(t);
        return true;

    }
    public ListNode getHalfNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
    public ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

##### [leetcode_142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

- 实现代码

```java
//方法1
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) { return null;}
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) { break;}
        }
        if (fast == null || fast.next == null) {
            return null;
        }
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
```

```java
//方法2
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) { return null;}
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (slow == fast) {
                fast = head;
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
        }
        return null;
}
}
```

##### [leetcode_160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

- 解题思路

<img src=".\算法与数据结构刷题笔记_图片\相交链表1.png" alt="相交链表1" style="zoom: 80%;" />

<img src=".\算法与数据结构刷题笔记_图片\相交链表2.png" alt="相交链表2" style="zoom:50%;" />

- 实现代码

```java
//超短代码
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1 = headA;
        ListNode p2 = headB;
        while (p1 != p2) {
            if (p1 == null) {
                p1 = headB;
            } else {
                p1 = p1.next;
            }
            if (p2 == null) {
                p2 = headA;
            } else {
                p2 = p2.next;
            }
        }
        return p1;
    }
}
```

##### [leetcode_86. 分隔链表](https://leetcode.cn/problems/partition-list/)

##### [leetcode_138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)



## C.二叉树

### 二叉树基础知识

- 二叉树的结构：

```python
class Node:
    v value
    Node left
    Node right
```

- 用法

用递归和非递归两种方法实现二叉树的先序/中序/后序遍历

- 基本概念

1. 节点的度：节点拥有的子树的数目。
2. 根节点
3. 外部节点/叶子节点：没有孩子的节点
4. 内部节点：至少有一个孩子的节点

- 父子节点的idx关系

根节点的idx为1；父节点的idx，左子节点为idx * 2，右子节点为idx * 2 + 1

#### 搜索二叉树

- 基本概念

1. 左树的节点都比它小，右树的节点都比它大

2. 判断：中序遍历升序->否则不是

3. 递归套路解法

   - 判断条件
     - 左右都是搜索二叉树
     - 左边<根节点<右边

   - 递归返回值：
     - 左右是否是搜索二叉树-左边的值-右边值

- 相关题目

[leetcode_98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

#### 完全二叉树

- 基本概念

从上到下是满二叉树-最后一层可能不满但是也是从左到右无空的

- 判断思路--层序遍历

1. 有一个节点有右无左
2. 在一不违规的前提下，遇到一个节点左右不全->后面的节点都是叶节点->否则为False

总结：层序遍历过程中所有节点没有遍历完成遇到null节点，则不为完全二叉树

- 相关题目

[leetcode_958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

#### 满二叉树

- 判断

1. 最大深度L和节点个数N
2. 满足N = 2.^L - 1

#### 平衡二叉树

- 判断

1. 任一一个节点的左右子树的高度差不超过1

- 递归思路

1. 列出所有可能性->并判断是否成立
2. 需要获取的信息：左右树是否平衡-树的高度‘

### 二叉树问题的基本递归思想

1. 树型DP
2. 通过向左树右树获取信息的方法形成递归问题

### 二叉树的遍历

#### 先序/前序-中序-后序遍历(深度优先遍历)

- 递归实现

1. 递归序：递归遍历每一个节点的子节点-
   - 每一个节点都会走3次，没有子节点/子节点遍历完了->返回父节点
   - 通过递归序在不同的实际操作可以实现先/中/后序

![二叉树递归序](.\算法与数据结构刷题笔记_图片\二叉树递归序.png)

2. 先序（深度优先）:以某个节点开始下面整个树->只操作第一次到达节点的递归序：头->左->右
3. 中序：->只操作第二次到达节点的递归序：左->头->右
4. 后序：->只操作第三次到达节点的递归序：左->右->头

- 非递归情况：任何递归方法都可以改写成非递归方法->**容易考**

1. 先序:压栈顺序->头右左->弹出栈顺序->头左右
   - a.从栈中弹出一个节点cur
   - b.处理/操作/打印cur
   - c.cur的右->左压入栈(先右再左--如果有的话)
   - 循环
2. 后序：压栈顺序->头左右->收集栈中弹出后顺序->左右头
   - a.从栈中弹出一个节点cur
   - b.cur放入收集栈
   - c.cur的左->右压入栈
   - 循环
   - 最后->收集栈中弹出

3. 中序(先左再头--后右树)：压栈顺序->左右头->弹出栈顺序->左头右
   - a.对于每棵子树，整棵树左边进栈
   - b.在依次弹出的过程中->对弹出节点的右数周而复始
   - 有左就左->弹出栈->右->循环

#### 宽度优先遍历(层序遍历)

- 基本思路

二叉树宽度优先遍历/层序遍历->求二叉树的最大宽度->宽度遍历用队列->头进->弹出->左右依次进->弹出->循环

1. 把根节点放入队列
2. 弹出->左右子节点加入队列
3. 循环

- 相关题目

#### Morris遍历二叉树

基础提升班补充

### 二叉树的相关题目

#### 二叉树问题的基本思想：

二叉树问题的基本递归思想：树型DP----通过向左树右树获取信息的方法形成递归问题

#### [leetcode_144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```java
//1.递归遍历
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> preList = new ArrayList<>();
        pre(root, preList);
        return preList;
    }
    public void pre(TreeNode head, List<Integer> preList) {
        if (head == null) {
            return;
        }
        preList.add(head.val);
        pre(head.left, preList);
        pre(head.right,preList);
    }
}
```

```java
//2.非递归--手动压栈
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> preList = new ArrayList<>();
        if (root == null) {
            return preList;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        TreeNode cur;
        while (!stack.isEmpty()) {
            cur = stack.pop();
            preList.add(cur.val);
            if (cur.right != null) {
                stack.push(cur.right);
            }
            if (cur.left != null) {
                stack.push(cur.left);
            }
        }
        return preList;
    }
}
```

#### [leetcode_94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```java
//1.递归遍历
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> inorderList = new ArrayList<>();
        inorder(root, inorderList);
        return inorderList;
    }
    public void inorder(TreeNode head, List<Integer> inorderList) {
        if (head == null) {
            return;
        }
        inorder(head.left, inorderList);
        inorderList.add(head.val);
        inorder(head.right, inorderList);
    }
}
```

```java
//2.非递归--手动压栈
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> inorderList = new ArrayList<>();
        if (root == null) {
            return inorderList;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            } else {
                cur = stack.pop();
                inorderList.add(cur.val);
                cur = cur.right;
            }
        }
        return inorderList;
    }
}
```

#### [leetcode_96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

```Java
// 暴力递归
class Solution {
    public int numTrees(int n) {
        return process(n);
    }
    public int process(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 0 || n == 1) {
            return 1;
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += process(i) * process(n-i-1);
        }
        return ans;
    }
}
```

```java
// 动态规划
class Solution {
    public int numTrees(int n) {
        int[] h = new int[n + 1];
        h[0] = 1;
        h[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                h[i] += h[j] * h[i-j-1];
            }
        }
        return h[n];
    }
}
```



#### [leetcode_145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

```java
//1.递归遍历
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> postList = new ArrayList<>();
        post(root, postList);
        return postList;
    }
    public void post(TreeNode head, List<Integer> postList) {
        if (head == null) {
            return;
        }
        post(head.left, postList);
        post(head.right, postList);
        postList.add(head.val);
    }
}
```

```java
//2.非递归--手动压栈
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> postList = new ArrayList<>();
        if (root == null) {
            return postList;
        }
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(root);
        TreeNode cur;
        while (!stack1.isEmpty()) {
            cur = stack1.pop();
            stack2.push(cur);
            if (cur.left != null) {
                stack1.push(cur.left);
            }
            if (cur.right != null) {
                stack1.push(cur.right);
            }
        }
        while (!stack2.isEmpty()) {
            cur = stack2.pop();
            postList.add(cur.val);
        }
        return postList;
    }

}
```

#### leetcode_102. 二叉树的层序遍历

层序优先遍历(宽度优先遍历)--使用队列

```java
//二叉树的宽度优先遍历--用ArrayList实现Queue的先进先出
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<>();
        }
        List<TreeNode> list = new ArrayList<>();
        List<List<Integer>> orderList = new ArrayList<>();
        list.add(root);
        while (list.size() > 0) {
            List<TreeNode> temp1 = new ArrayList<>();
            List<Integer> temp2 = new ArrayList<>();
            for (TreeNode node: list) {
                if (node.left != null) {
                    temp1.add(node.left);
                }
                if (node.right != null) {
                    temp1.add(node.right);
                }
                temp2.add(node.val);
                list = temp1;
            }
            orderList.add(temp2);
        }
        return orderList;
    }
}
```

```java
//队列
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> orderList = new ArrayList<>();
        if (root == null) {
            return orderList;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> temp = new ArrayList<>();
            for (int i=0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                temp.add(node.val);
            }
            orderList.add(temp);
        }
        return orderList;
    }
}
```

```java
//递归方法--可参考
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        level(root, 0);
        return result;
    }

    private void level(TreeNode root, int depth) {
        if (root == null)
            return;
        depth++;
        if (result.size() < depth)
            result.add(new ArrayList<Integer>());
        result.get(depth - 1).add(root.val);
        level(root.left, depth);
        level(root.right, depth);
    }
}
```

#### [leetcode_662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

```java
//HashMap保存idx
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        Map<TreeNode, Integer> map = new HashMap<>();
        queue.add(root);
        map.put(root, 1);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            int cur = 0;
            for (int i=0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                    map.put(node.left, map.get(node)*2);
                }
                if (node.right != null) {
                    queue.add(node.right);
                    map.put(node.right, map.get(node)*2 + 1);
                }
                if (i == 0) {
                    cur = map.get(node);
                }
                if (i == size - 1) {
                    cur = map.get(node) - cur + 1;
                }
            }
            res = Math.max(res, cur);
        }
        return res;
    }
}
```

```java
//常数指标的优化
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        LinkedList<TreeNode> queue = new LinkedList<>();//Queue换为LinkedList
        Map<TreeNode, Integer> map = new HashMap<>();
        queue.add(root);
        map.put(root, 1);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            int idxL = map.get(queue.getFirst());
            int idxR = map.get(queue.getLast());
            res = Math.max(res, idxR - idxL + 1);
            for (int i=0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                    map.put(node.left, map.get(node)*2);
                }
                if (node.right != null) {
                    queue.add(node.right);
                    map.put(node.right, map.get(node)*2 + 1);
                }
            }
        }
        return res;
    }
}
```

```java
//深度优先遍历方法
class Solution {
    Map<Integer, Integer> levelMin = new HashMap<Integer, Integer>();

    public int widthOfBinaryTree(TreeNode root) {
        return dfs(root, 1, 1);
    }

    public int dfs(TreeNode node, int depth, int index) {
        if (node == null) {
            return 0;
        }
        levelMin.putIfAbsent(depth, index); // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值
        return Math.max(index - levelMin.get(depth) + 1, 
                        Math.max(dfs(node.left, depth + 1, index * 2), 
                                 dfs(node.right, depth + 1, index * 2 + 1)));
    }
}
```

#### [leetcode_654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

- 思路：构建最大二叉树--返回树的头节点

- 最优解：单调栈

```java
// 递归--向左右获取信息
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return process(nums, 0, nums.length - 1);
    }
    public TreeNode process(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int best = left;
        for (int i = left; i <= right; i++) {
            if (nums[i] > nums[best]) {
                best = i;
            }
        }
        TreeNode node = new TreeNode(nums[best]);
        node.left = process(nums, left, best-1);
        node.right = process(nums, best+1, right);
        return node;
    }
}
```

```java
// 单调栈--最优解
```



#### [leetcode_98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```java
//中序遍历是否是升序
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        List<Integer> list = new ArrayList<>();
        dfs(root, list);
        int cur = list.get(0);
        for (int i = 1; i < list.size(); i++) {
            if (list.get(i) <= cur) {
                return false;
            }
            cur = list.get(i);
        }
        return true;
    }
    public void dfs(TreeNode head, List<Integer> list) {
        if (head == null) {
            return;
        }
        dfs(head.left, list);
        list.add(head.val);
        dfs(head.right, list);
    }
}
```

```java
//递归-查询每一个子树是否满足要求
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }//考虑刚好等于Integer的最小值和最大值的边界情况
    public boolean isValidBST(TreeNode head, long min, long max) {
        if (head == null) {
            return true;
        }
        if (head.val <= min || head.val >= max) {
            return false;
        }
        return isValidBST(head.left, min, head.val) && isValidBST(head.right, head.val, max);
    }
}
```

#### [leetcode_958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)

```java
// 层序遍历
// 如果遍历到了一个非空节点之前遍历过空节点，那么为false，否则遍历完毕返回true
class Solution {
    public boolean isCompleteTree(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        boolean ans = true;
        deque.addLast(root);
        while(!deque.isEmpty()) {
            TreeNode node = deque.removeFirst();
            if (node == null) {
                ans = false;
            } else {
                if (!ans) {
                    return ans;
                }
                deque.addLast(node.left);
                deque.addLast(node.right);
            }
        }
        return true;
    }
}
```

#### [leetcode_110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

```java
// 双信息递归--高度和是否为平衡树
class Solution {
    public boolean isBalanced(TreeNode root) {
        return process(root)[0] == 1;
    }
    public int[] process(TreeNode node) {
        int h = 0;
        int isBalance = 0;
        if (node == null) {
            return new int[]{1, h};
        } else {
            int[] leftInf = process(node.left);
            int[] rightInf = process(node.right);
            h = Math.max(leftInf[1], rightInf[1]) + 1;
            if (Math.abs(leftInf[1] - rightInf[1]) <= 1 && leftInf[0] == 1 && rightInf[0] == 1) {
                isBalance = 1;
            }
            return new int[]{isBalance, h};
        }
    }
}
```

```java
// 单信息递归--树的高度
class Solution {
    public boolean isBalanced(TreeNode root) {
        return (process(root) != -1);
    }
    public int process(TreeNode node) {
        int h = 0;
        if (node == null) {
            return 0;
        }
        int leftH = process(node.left);
        int rightH = process(node.right);
        if (leftH == -1 || rightH == -1 || Math.abs(leftH - rightH) > 1) {
            return -1;
        }
        return Math.max(leftH, rightH) + 1;
    }
}
```



#### leetcode_236. 二叉树的最近公共祖先

#### 剑指 Offer II 053. 二叉搜索树中的中序后继

- 解题思路

	1. 后继节点->中序遍历中一个节点的后面一个位置

 	2. 用O(k)复杂度的方法找
 	 - 分情况查找
 	 - 1.x有右数的情况：后继是右树的第一个打印的节点
 	 - 2.x没有右数的情况：查找x是第一个父节点的左孩子（二叉树结构中可以直接查父节点的情况）
 	 - 3.都没有为None

#### leetcode_297二叉树的序列化与反序列化-困难

- 解题思路

转化成一种字符串/数据->并能够还原出来

1. 序列化:可以使用任何一种遍历方式进行序列化，同时记录空节点位置#-None。
2. 反序列化

#### 微软折纸问题

- 解题思路

根节点凹->每一个子树的左节点都是凹-右节点都是凸

## D.图

### 图的表示形式/图的存储方法

#### 邻接表法

点-直接邻居(边)

<img src=".\算法与数据结构刷题笔记_图片\图_邻接表法.png" alt="图_邻接表法" style="zoom:50%;" />

#### 邻接矩阵

用矩阵表示不同点之间的距离

<img src=".\算法与数据结构刷题笔记_图片\图_邻接矩阵.png" alt="图_邻接矩阵" style="zoom:50%;" />

#### 邻接图

#### 边列表结构

#### 类

- 图

1. 点集：hashmap-几号点->Node
   - value->自己的信息
   - in->入度-进入的点-int
   - out->出度-出去的点-int
   - nexts->直接邻居-list
   - edge->边-list
2. 边集：hashset-存储所有边
   - from->来向的点-Node
   - to->去向的点-Node
   - weight->权重-int
   - 例:[5, 0, 1]->5这个边连接0和1

注意：可以忽略不使用的数据信息

- 实现代码

```java
public static Graph createGraph(Integer[][] matrix) {
	Graph graph = new Graph();
	for (int i = 0; i < matrix.length; i++) {
        Integer from = matrix[i][0];
        Integer to = matrix[i][1];
        Integer weight = matrix[i][2];
        if (!graph.nodes.containsKey(from)) {
        	graph.nodes.put(from, new Node(from));
        }
        if (!graph.nodes.containsKey(to)) {
        	graph.nodes.put(to, new Node(to));
        }
        Node fromNode = graph.nodes.get(from);
        Node toNode = graph.nodes.get(to);
        Edge newEdge = new Edge(weight, fromNode, toNode);
        fromNode.nexts.add(toNode);
        fromNode.out++;
        toNode.in++;
        fromNode.edges.add(newEdge);
        graph.edges.add(newEdge);
	}
	return graph;
}
```

- 图有很多种表现形式->不同的表现形式的具体算法实现略有不同->图相关的题目一定要有自己熟悉的一套模板

1. 推荐方法->用一种自己熟悉的图的表现形式实现所有的算法
2. 在写具体题目的时候只需要将题目给的图的形式转化为自己熟悉的图的形式来实现即可

### 图的遍历

- 基本概念

1. 图：描述对象之间存在关系的一种方法
2. 顶点(节点)
3. 边(圆弧)：有向-无向

#### 宽度优先遍历

- 实现方法

1. 利用队列实现
2. 从源节点开始依次按照宽度进队列，然后弹出
3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
4. 直到队列变空

- 实现代码

1. 用队列->set记录防止出现重复的点(无向图/有环图导致无限循环)-set也可以换为list直接寻址可节省常数级的时间
2. 将第一个节点放入队列-set记录放入的节点
3. 队列不为空->从队列中弹出一个节点
4. 遍历他的所有nexts->判断set中是否存在->加入队列

- 相关题目

[leetcode_1609. 奇偶树](https://leetcode.cn/problems/even-odd-tree/)

[leetcode_LCR 151. 彩灯装饰记录 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

#### 广度(深度)优先遍历

- 实现方法

1. 利用实现
2. 从源节点开始把节点按照深度放入栈，然后弹出
3. 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈
4. 直到栈变空

- 实现代码

用栈->set记录防止重复

- 相关题目

[leetcode_417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

#### 拓扑排序算法

- 拓扑排序算法：有向无环-有入度为0的节点

1. hashmap记录所有点原始的入度-遍历所有节点->入度为0的点放入queue中
2. queue不为空->弹出->加入result中->删除所有与该节点相关的入度->把新的入读为0的点弹入queue中

#### 最小生成树

- 最小生成树：只用最短的边来保证整个图的连通性--非常难反复看-P9

##### prim算法

- 基本流程

<img src=".\算法与数据结构刷题笔记_图片\prim算法_基本流程.png" alt="prim算法_基本流程" style="zoom:50%;" />

- 算法实现

1. 选一个点开始->set中不存在则放入set中->把所有边加入优先级队列(heap)
2. 优先级队列不为空->弹出最小边->找到下一个点
3. 点不在set中->加入set-记录边->把下一个点的边加入到优先级队列中
4. 注意：可能有重复的边->但是from和to已经在set中->跳过

##### Kruskal算法

- 前置结构
  1.每个节点放入一个list中->节点Node对应的set放入hashmap中
  2.判断from和to是不是在同一个set中
  3.合并两个set
- 把最短边依次加入->判断是否有环
- 可以使用并查集结构-后面讲
- 注意：合并过程中可能出现已经合并过的两个小集合进行合并的过程

##### Dijkstra算法(不存在权值为负数的边)

- 给定一个点->返回到达其他所有点的距离-无法到达的点为∞(系统最大数值)
- 算法流程

1. list记录一个起始点到其他所有点的距离
2. 选取该节点的所有边->依次查看能否优化路径的距离
3. 不能优化后锁死->下一个节点

- 算法的实现

1. hashmap记录一个点的边的距离-set记录点是否使用
2. 获取一个没有使用的最小路径节点-实现一个方法
3. 最小路径节点存在->获取到该节点的距离->遍历所有边->to节点是否存在-存在看是否能更新-不存在直接更新->更新选择过的点

- 优化:本质是一个遍历过程->可以使用堆来优化->但是系统提供的堆数据值不能动态修改->自己手动实现
  - 编程思路
  - 0.实现输入一个节点-节点数量->返回到达其他所有节点的距离
- 优化思路
  - 维护小根堆来代替遍历
  - 修改堆的能力一定要具备*

##### A*算法

### 图相关题目

#### leetcode207. 课程表->拓扑排序

#### [leetcode_310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)->拓扑排序

```java
// 深度优先遍历
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> ans = new ArrayList<Integer>();
        if (n == 1) {
            ans.add(0);
            return ans;
        }
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<Integer>();
        }
        for (int[] edge : edges) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }

        int[] parent = new int[n];
        Arrays.fill(parent, -1);
        /* 找到与节点 0 最远的节点 x */
        int x = findLongestNode(0, parent, adj);
        /* 找到与节点 x 最远的节点 y */
        int y = findLongestNode(x, parent, adj);
        /* 求出节点 x 到节点 y 的路径 */
        List<Integer> path = new ArrayList<Integer>();
        parent[x] = -1;
        while (y != -1) {
            path.add(y);
            y = parent[y];
        }
        int m = path.size();
        if (m % 2 == 0) {
            ans.add(path.get(m / 2 - 1));
        }
        ans.add(path.get(m / 2)); // 答案要么是一个要么是两个
        return ans;
    }

    public int findLongestNode(int u, int[] parent, List<Integer>[] adj) {
        // 返回最远距离的节点
        int n = adj.length;
        int[] dist = new int[n];
        Arrays.fill(dist, -1);
        dist[u] = 0;
        dfs(u, dist, parent, adj);
        int maxdist = 0;
        int node = -1;
        for (int i = 0; i < n; i++) {
            if (dist[i] > maxdist) {
                maxdist = dist[i];
                node = i;
            }
        }
        return node;
    }

    public void dfs(int u, int[] dist, int[] parent, List<Integer>[] adj) {
        // u 当前节点 dist 到各节点的距离  v 目标节点
        // 计算u 节点到 所有节点的最小距离
        for (int v : adj[u]) {
            if (dist[v] < 0) {
                dist[v] = dist[u] + 1;
                parent[v] = u;
                dfs(v, dist, parent, adj); 
            }
        }
    }
}
```

```java
// 拓扑排序算法
class Solution {
    List<Integer> ans = new ArrayList<Integer>();
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        if (n == 1) {
            ans.add(0);
            return ans;
        }
        List<Integer>[] disList = new List[n];
        int[] degrees = new int[n];
        Queue<Integer> que = new ArrayDeque<>();
        for (int i=0; i < n; i++) {
            disList[i] = new ArrayList<Integer>();
        }
        for (int[] edge: edges) {
            disList[edge[0]].add(edge[1]);
            disList[edge[1]].add(edge[0]);
            degrees[edge[0]]++;
            degrees[edge[1]]++;
        }
        for (int i=0; i < n; i++) {
            if (degrees[i] == 1) {
                que.offer(i);
            }
        }
        int sz = n;
        while (sz > 2) {
            int queSz = que.size();
            sz -= queSz;
            for (int i = 0; i < queSz; i++) {
                int cur = que.poll();
                for (int target: disList[cur]) {
                    degrees[target]--;
                    if (degrees[target] == 1) {
                        que.offer(target);
                    }
                }
            }
        }
        while (!que.isEmpty()) {
            ans.add(que.poll());
        }
        return ans;
    }
}
```



#### [leetcode_417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

```java
// 逆向思维+dfs
class Solution {
    int[][] dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};
    int[][] heights;
    int m, n;
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        this.heights = heights;
        this.m = heights.length;
        this.n = heights[0].length;
        boolean[][] p = new boolean[m][n];
        boolean[][] a = new boolean[m][n];
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            dfs(0, i, p);
        }
        for (int j = 1; j < m; j++) {
            dfs(j, 0, p);
        }
        for (int i = 0; i < n; i++) {
            dfs(m-1, i, a);
        }
        for (int j = 0; j < m-1; j++) {
            dfs(j, n-1, a);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (p[i][j] && a[i][j]) {
                    List<Integer> list = new ArrayList<>();
                    list.add(i);
                    list.add(j);
                    ans.add(list);
                }
            }
        }
        return ans;

    }
    public void dfs(int i, int j, boolean[][] ocean) {
        if (ocean[i][j]) return;
        else ocean[i][j] = true;
        for (int[] dir: dirs) {
            int iNow = i + dir[0];
            int jNow = j + dir[1];
            if (iNow>= 0 && iNow < m && jNow>=0 && jNow < n && heights[iNow][jNow]>=heights[i][j]) {
                dfs(iNow, jNow, ocean);
            }
        }
    }
}
```

#### leetcode_743. 网络延迟时间->dijkstra算法

#### leetcode_934. 最短的桥->宽度优先遍历

#### [leetcode_1609. 奇偶树](https://leetcode.cn/problems/even-odd-tree/)

```java
// 宽度优先遍历
class Solution {
    public boolean isEvenOddTree(TreeNode root) {
        Deque<TreeNode> d = new ArrayDeque<>();
        boolean key = true;
        d.addLast(root);
        while (!d.isEmpty()) {
            int size = d.size();
            int prev = key ? 0 : Integer.MAX_VALUE;
            while (size > 0) {
                TreeNode node = d.pollFirst();
                int cur = node.val;
                if (key && (cur % 2 == 0 || cur <= prev)) {
                    return false;
                }
                if (!key && (cur % 2 != 0 || cur >= prev)) {
                    return false;
                }
                prev = cur;
                if (node.left != null) {
                    d.addLast(node.left);
                }
                if (node.right != null) {
                    d.addLast(node.right);
                }
                size--;
            }
            key = !key;
        }
        return true;
    }
}
```

```java
// 上述代码优化
class Solution {
    public boolean isEvenOddTree(TreeNode root) {
        Deque<TreeNode> d = new ArrayDeque<>();
        boolean key = true;
        d.addLast(root);
        while (!d.isEmpty()) {
            int size = d.size();
            int prev = key ? 0 : Integer.MAX_VALUE;
            while (size-- > 0) {
                TreeNode node = d.pollFirst();
                int cur = node.val;
                if (key && (cur % 2 == 0 || cur <= prev)) 
                    return false;
                if (!key && (cur % 2 != 0 || cur >= prev)) 
                    return false;
                prev = cur;
                if (node.left != null) 
                    d.addLast(node.left);
                if (node.right != null) 
                    d.addLast(node.right);
                
            }
            key = !key;
        }
        return true;
    }
}
```

#### [leetcode_LCR 151. 彩灯装饰记录 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```java
class Solution {
    public List<List<Integer>> decorateRecord(TreeNode root) {
        Deque<TreeNode> d = new ArrayDeque<>();
        List<List<Integer>> ans = new ArrayList<>();
        if (root != null) d.addLast(root);
        while (!d.isEmpty()) {
            int size = d.size();
            int dir = ans.size() % 2;
            LinkedList<Integer> list = new LinkedList<>();
            while (size-- > 0) {
                TreeNode node = d.pollFirst();
                if (dir == 0) list.addLast(node.val);
                else list.addFirst(node.val);
                if (node.left != null) d.addLast(node.left);
                if (node.right != null) d.addLast(node.right);
            }
            ans.add(list);
        }
        return ans;
    }
}
```



## E.前缀树

### 基本结构

- 基本介绍

前缀树(trie tree)：信息在路径上-有该路径就复用-没有该路径就新建出来--记录以该路径**开始和结尾的次数**

- 基本结构

1. pass int 节点到达过的次数
2. end int 以该节点结束多少次
3. nexts list[26] 表示是否有26个字母对应的路->如果节点类型特别多-可以使用hashmap

![前缀树](.\算法与数据结构刷题笔记_图片\前缀树.png)

- 功能

1. 可以直接查询以''字符''开头的字符串数量->hashmap较难实现该功能
2. 查询一个字符串->沿着字符走一遍-最后一个字符的end值就是出现的次数

### 实现代码

- Node

```java
public static class TrieNode {
    public int pass;
    public int end;
    public TrieNode[] nexts; // HashMap<Char， Node> nexts;
    public TrieNode() {
        pass = 0;
        end = 0;
// nexts[0] == null 没有走向'a'的路
// nexts[0] != null 有走向'a'的路
// ...
// nexts[25] != null 有走向“z’的路
        nexts = new TrieNode[26];
    }
}
```

- 加入字符串-insert

```java
public void insert(String word) {
    if (word == null) {
    	return;
    }
    char[] chs = word.toCharArray();
    TrieNode node = root;
    node.pass++;
	int index = 0;
    for (int i = 0;i< chs.length; i++) { // 从左往右遍历字符
        index = chs[i] - 'a';// 由字符，对应成走向哪条路
        if (node.nexts[index] == null) {
            node.nexts[index] = new TrieNode();
        }
        node = node.nexts[index];
        node.pass++;
    }
	node.end++;
}
```

- 词数

```java
public int search(String word) {
    if (word == null) {
    	return 0;
    }
    char[] chs = word.toCharArray();
    TrieNode node = root;
    int index = 0;
    for (int i = 0; i < chs.length; i++) {
    	index = chs[i] - 'a';
        if (node.nexts[index] == null) {
        	return 0;
        }
    	node = node.nexts[index];
    }
    return node.end;
}
```

- 前缀词数

```java
public int prefixNumber(String pre) {
    if (pre == null) {
    	return 0;
    }
    char[] chs = pre.toCharArray();
    TrieNode node = root;
    int index = 0;
    for (int i = 0; i < chs.length; i++) {
    	index = chs[i] - 'a';
        if (node.nexts[index] == null) {
			return 0;
        }
        node = node.nexts[index];
    }
	return node.pass;
}
```

- 删除

```java
public void delete(String word) {
	if search(word) != 0) { // 确定树中确实加入过word，才删除
        char[] chs = word.toCharArray();
        TrieNode node = root;
        node.pass--;
        int index = 0;
        for (int i = 0; i < chs.length; i++) {
            index = chs[i] -'a';
            if (--node.nexts[index].pass == 0) {
                // java C++ 要遍历到底去析构
                node.nexts[index] = null;
                // ...
                return;
            }
        	node = node.nexts[index];
        }
		node.end--;
    }
}
```

注意：当最后节点的p为空时-需要删除后面所有节点->注意不用语言的内存释放方法(析构方法)

### 前缀树相关题目

#### [leetcode_208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```java
// 左神版本--带删除--题目没有删除
class Trie {
    public static class TrieNode {
        public int pass;
        public int end;
        public TrieNode[] nexts;
        public TrieNode() {
            pass = 0;
            end = 0;
            nexts = new TrieNode[26];
        }
    }
    public TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        if (word == null) {
            return;
        }
        char[] chars = word.toCharArray();
        TrieNode now = root;
        now.pass++;
        int index = 0;
        for (int i=0; i < chars.length;i++) {
            index = chars[i] - 'a';
            if (now.nexts[index] == null) {
                now.nexts[index] = new TrieNode();
            }
            now = now.nexts[index];
            now.pass++;
        }
        now.end++;
    }
    
    public boolean search(String word) {
        TrieNode now = root;
        char[] pre = word.toCharArray();
        int index = 0;
        for (int i = 0; i < pre.length; i++) {
            index = pre[i] - 'a';
            if (now.nexts[index] == null) {
                return false;
            }
            now = now.nexts[index];
        }
        return now.end > 0;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode now = root;
        char[] pre = prefix.toCharArray();
        int index = 0;
        for (int i = 0; i < pre.length; i++) {
            index = pre[i] - 'a';
            if (now.nexts[index] == null) {
                return false;
            }
            now = now.nexts[index];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```



## F.贪心算法

- 基础知识

1. 在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫作贪心算法。也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。
2. 贪心策略的全局最优解证明比较复杂->做题时有技巧的蒙-举反例快速验证
3. 练习时可以使用暴力枚举和脑补的贪心方法用对数器验证-->能通过对数器就当作是正确的

### 字典序

- 基本概念

1. 字符串长度相等时：字符转为数字比较
2. 长度不相等时：将短的字符长度用0补齐
3. 贪心策略反例-各单词字典序从小到大组合-字典序最小-错误-反例：'b'和'ba'->组合后'bab'小于'bba'
   - 改进->a.b<=b.a成立a放前面否则放后面
   - 有效比较->比较方法具有传递性

### 哈夫曼编码问题

### 贪心算法相关题目

#### 牛客_会议室问题

- 贪心策略->会议时间结束早优先安排

#### [leetcode_11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```java
// 双指针 + 贪心
public class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, max = 0;
        int cur = 0;
        while (left < right) {
            cur = (height[left]>height[right] ? height[right] : height[left]) * (right-left);
            if (cur > max) max = cur;
            if (height[left]>height[right]) right--;
            else left++;
        }
        return max;
    }
}
```

```java
// 常数优化 -- 高度比之前小的直接不算了
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length-1;
        int ans = 0;
        while(left < right){
            int h = Math.min(height[left], height[right]);
            int area = h*(right-left);
            ans = Math.max(area,ans);
            while(height[left] <= h && left<right){
                left++;
            }
            area = h*(right-left);
            ans = Math.max(area,ans);
            while(height[right] <= h && left<right){
                right--;
            }
            
        }
        return ans;
    }
}
```

#### [leetcode_51. N 皇后](https://leetcode.cn/problems/n-queens/)

- 解题思路

1. 时间复杂度-O(n_n)-n的n次方
2. 加速方法-利用位运算代替行列对角线的检查

- 实现代码

```java
class Solution {
    List<List<String>> ans = new ArrayList<>();
    int n;
    public List<List<String>> solveNQueens(int n) {
        this.n = n;
        char[][] curArr = new char[n][n];
        for (char[] c: curArr) {
            Arrays.fill(c,'.');
        }
        dfs(0, curArr);
        return ans;
    }
    public void dfs(int curR, char[][] curArr) {
        if (curR == n) {
            ans.add(Array2list(curArr));
            return;
        }
        for (int i = 0; i < n; i++) {
            if (isValid(curR, i, curArr)) {
                curArr[curR][i] = 'Q'; // 可行才添加
                dfs(curR + 1, curArr);
                curArr[curR][i] = '.';
            }
        }
    }

    public List Array2list(char[][] curArr) {
        List<String> list = new ArrayList<>();
        for (char[] cs: curArr) {
            // 两种转换方法
            list.add(new String(cs)); // 1.
            // list.add(String.valueOf(cs)); // 2.
        }
        return list;
    }
    public boolean isValid(int curR, int curC, char[][] curArr){
        // 检验列
        for (int i = 0; i < curR; i++) {
            if (curArr[i][curC] == 'Q') return false;
        }
        // 检验45°
        for (int i = curR-1, j = curC+1; i >= 0 && j < n; i--, j++) {
            if (curArr[i][j] == 'Q') return false;
        }
        // 检验135°
        for (int i = curR-1, j = curC-1; i >= 0 && j >=0; i--, j--) {
            if (curArr[i][j] == 'Q') return false;
        }
        return true;
    }
}
```

#### [leetcode_52. N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

```java
// 回溯尝试思想
class Solution {
    int ans = 0;
    int n;
    public int totalNQueens(int n) {
        this.n = n;
        char[][] curArr = new char[n][n];
        for (char[] c: curArr) {
            Arrays.fill(c,'.');
        }
        dfs(0, curArr);
        return ans;
    }
    public void dfs(int curR, char[][] curArr) {
        if (curR == n) {
            ans++;
            return;
        }
        for (int i = 0; i < n; i++) {
            if (isValid(curR, i, curArr)) {
                curArr[curR][i] = 'Q'; // 可行才添加
                dfs(curR + 1, curArr);
                curArr[curR][i] = '.';
            }
        }
    }
    public List Array2list(char[][] curArr) {
        List<String> list = new ArrayList<>();
        for (char[] cs: curArr) {
            list.add(new String(cs));
        }
        return list;
    }
    public boolean isValid(int curR, int curC, char[][] curArr){
        // 检验列
        for (int i = 0; i < curR; i++) {
            if (curArr[i][curC] == 'Q') return false;
        }
        // 检验45°
        for (int i = curR-1, j = curC+1; i >= 0 && j < n; i--, j++) {
            if (curArr[i][j] == 'Q') return false;
        }
        // 检验135°
        for (int i = curR-1, j = curC-1; i >= 0 && j >=0; i--, j--) {
            if (curArr[i][j] == 'Q') return false;
        }
        return true;
    }
}
```

```java
// 位运算优化
class Solution {
    public int totalNQueens(int n) {
        return solve(n, 0, 0, 0, 0);
    }

    public int solve(int n, int row, int columns, int diagonals1, int diagonals2) {
        if (row == n) {
            return 1;
        } else {
            int count = 0;
            int availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2));
            while (availablePositions != 0) {
                int position = availablePositions & (-availablePositions); // 获得二进制表示中的最低位的1的位置 -- 依次遍历 -- 选择最低的位置
                availablePositions = availablePositions & (availablePositions - 1); //将二进制表示中的最低位的1置成0
                count += solve(n, row + 1, columns | position, (diagonals1 | position) << 1, (diagonals2 | position) >> 1);
            }
            return count;
        }
    }
}

```



#### [leetcode_295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

- 解题思路：1个大根堆和1个小根堆

1. cur<=大根堆顶 
2. 是->cur进大根堆
   否->cur进小根堆
3. 两个堆的size相差＞=2时，将堆顶的数弹给对方
4. 大根堆里存小于mid的数，小根堆存大于mid的数
5. 永远保持小根堆的大小-大根堆的大小等于0或1

- 排序思路实现

```java
public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
    PriorityOueue<Node> minCostQ = new PriorityQueue<>(new MinCostComparator());
    PriorityQueue<Node> maxProfitQ = new PriortyQueue<>(new MaxProfitComparator());
	// 所有项目扔到被锁池中，花费组织的小根堆
	for (int i = 0; i < Profits.length; i++) {
		minCostQ.add(new Node(Profits[i]，Capital[i]));
    }
	for (int i = 0; i < k; i++) { // 进行K轮
		// 能力所及的项目，全解锁
		while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {
			maxProfitQ.add(minCostQ.poll());
        }
        if (maxProfitQ.isEmpty()) {
        return W;
		}
		W += maxProfitQ.poll().p;
    }
	return W;
}
```

- 实现代码

```java
// 严格利用堆的特性的优化代码
class MedianFinder {
    PriorityQueue<Integer> queMin, queMax;

    public MedianFinder() {
        queMin = new PriorityQueue<>((a, b) -> (a-b)); // 小根堆
        queMax = new PriorityQueue<>((a, b) -> (b-a)); // 大根堆
    }
    
    public void addNum(int num) {
        if (queMin.size() != queMax.size()) {
            queMin.add(num);
            queMax.add(queMin.poll());
        } else {
            queMax.add(num);
            queMin.add(queMax.poll());
        }
    }
    
    public double findMedian() {
        if(queMin.size() != queMax.size()) {
            return queMin.peek();
        }
        return (queMin.peek() + queMax.peek()) / 2.0;
    }
}
```

#### [leetcode_698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

```java
// 搜索 + 剪枝(贪心)
class Solution {
    int[] nums;
    int n,t,k;
    public boolean canPartitionKSubsets(int[] nums, int k) {
        this.nums = nums;
        this.k = k;
        int total = 0;
        for (int x: nums) total += x;
        if (total % k != 0) return false;
        Arrays.sort(nums);
        this.n = nums.length;
        this.t = total / k;
        return dfs(n-1, 0, 0, new boolean[n]);
    }

    public boolean dfs(int idx, int cur, int cnt, boolean[] vis) {
        if (cnt == k) return true;
        if (cur == t) return dfs(n-1, 0, cnt + 1, vis);
        for (int i = idx; i >= 0; i--) { // 顺序性剪枝
            if (vis[i] || cur + nums[i] > t) continue; // 可行性剪枝--尝试过的数就跳过
            vis[i] = true;
            if (dfs(i-1, cur + nums[i], cnt, vis)) return true; // 能放入就添加
            vis[i] = false; // 不能放入
            if (cur == 0) return false; // 最大值无法放入--必然无解
        }
        return false;
    }
}
```



#### 常用技巧：堆和排序



## G.暴力递归/动态规划

- 基本概念：暴力递归就是尝试

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解
5. 尝试的时候不用考虑整体->局部是对的整体一定是对的

- 扩展内容

1. 暴力递归改动态规划
2. 根据依赖位置设置遍历的顺序

#### 暴力递归相关题目

##### [leetcode_面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)

- 解题思路

1. 0.三个柱子-from-to-other
2. 1.1~i-1移动到other
3. i移动到to
4. 1~i-1移动到to
5. 操作函数(i, from, to, other)

- 实现代码

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        func(A.size(), A, C, B);
    }

    public void func(int n, List<Integer> from, List<Integer> end, List<Integer> other) {
        if (n == 1) {
            end.add(from.removeLast()); // from.remove(from.size() - 1);
        } else {
        func(n-1, from, other, end);
        end.add(from.removeLast());
        func(n-1, other, end, from);
        }
    }
}
```

##### [leetcode_17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```java
class Solution {
    List<String> ans = new ArrayList<>();
    String[] num2Str = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return new ArrayList<>();
        }
        func(0, digits, new StringBuffer());
        return ans;

    }

    public void func(int cur, String digits, StringBuffer str) {
        if (cur == digits.length()) {
            ans.add(str.toString());
        } else {
            char digit = digits.charAt(cur);
            String letters = num2Str[digit - '0'];
            int lsLen = letters.length();
            for (int i = 0; i < lsLen; i++) {
                str.append(letters.charAt(i));
                func(cur + 1, digits, str);
                str.deleteCharAt(cur);
            }
        }
    }
}
```

##### [leetcode_22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

```java
// 回溯
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        backtrack(n, 0, 0, new StringBuffer());
        return ans;
    }
    public void backtrack(int n, int open, int close, StringBuffer curStr) {
        if (curStr.length() == n*2) {
            ans.add(curStr.toString());
            return;
        }
        if (open < n) {
            curStr.append('(');
            backtrack(n, open + 1, close, curStr);
            curStr.deleteCharAt(curStr.length() - 1);
        }
        if (close < open) {
            curStr.append(')');
            backtrack(n, open, close + 1, curStr);
            curStr.deleteCharAt(curStr.length() - 1);
        }
    }
}
```



##### [leetcode_78. 子集](https://leetcode.cn/problems/subsets/)

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    int n;
    public List<List<Integer>> subsets(int[] nums) {
        n = nums.length;
        func(0, nums, new ArrayList<>());
        return ans;
    }
    public void func(int cur, int[] nums, List<Integer> list) {
        if (cur == n) {
            ans.add(new ArrayList<Integer>(list));
            return;
        } else {
            list.add(nums[cur]);
            func(cur + 1, nums, list);
            list.removeLast();
            func(cur + 1, nums, list);
        }
    }
}
```

##### [leetcode_46. 全排列](https://leetcode.cn/problems/permutations/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    int n;
    public List<List<Integer>> permute(int[] nums) {
        n = nums.length;
        List<Integer> list = new ArrayList<>();
        boolean[] numUsed = new boolean[n];
        dfs(0, numUsed, nums, list);
        return res;
    }
    public void dfs(int idx, boolean[] numUsed, int[] nums, List<Integer> list) {
        if (idx == n) {
            res.add(new ArrayList(list));
            return;
        } else {
            for (int i=0; i < n; i++) {
                if (!numUsed[i]) {
                    list.add(nums[i]);
                    numUsed[i] = true;
                    dfs(idx + 1, numUsed, nums, list);
                    numUsed[i] = false;
                    list.removeLast();
                }
            }
        }
    }
}
```

```java
// 换位置思想
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    int n;
    public List<List<Integer>> permute(int[] nums) {
        n = nums.length;
        process(nums,0);
        return ans;
    }
    public void process(int[] nums,int i){
        if(i == nums.length){
            List<Integer> list = new ArrayList<>();
            for(int n:nums){
                list.add(n);
            }
            ans.add(list);
        }
        for(int j = i;j < nums.length;j++){
            swap(nums,i,j);
            process(nums,i + 1);
            swap(nums,i,j);
        }
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



##### [leetcode_310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

```java
// 树形DP模板题
```



##### [leetcode_486. 预测赢家](https://leetcode.cn/problems/predict-the-winner/)

```java
// 求总分转换为求分数差->消除总分参数
class Solution {
    public boolean predictTheWinner(int[] nums) {
        return total(nums, 0, nums.length - 1) >= 0;
    }
    public int total(int[] nums, int start, int end) { //去掉turn参数。不管当前是A玩家选还是B玩家选，我们都返回一个分数，代表当前玩家得分，减去另一玩家的得分。
        if (start == end) {
            return nums[start];
        }
        int scoreStart = nums[start] - total(nums, start + 1, end); //这里第二项从加号改为减号。
        int scoreEnd = nums[end] - total(nums, start, end - 1); //这里第二项从加号改为减号。
        return Math.max(scoreStart, scoreEnd); //直接返回最大值就好了，不需要知道当前玩家是谁。
    }
}
```

```java
// 动态规划
class Solution {
    public boolean predictTheWinner(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return true;
        }
        int[][] dp = new int[len][len];
        for (int i= 0; i < len; i++) {
            dp[i][i] = nums[i];
        }
        for (int c = len-1; c>=0; c--){
            for (int r = c + 1; r < len; r++) {
                dp[c][r] = Math.max(nums[c] - dp[c+1][r], nums[r] - dp[c][r-1]);
            }
        }
        return dp[0][len-1] >= 0;
    }
}
```



##### 栈逆序

- 解题思路

1. 实现函数-弹出栈的最后一个元素-递归
   - 弹出一个元素
   - base case-栈为空返回
   - 不为空-递归-last
   - 放回结果
   - 返回last
2. 实现逆序函数
   - base case-栈为空返回
   - last = 最后一个元素
   - 递归
   - 放回last

##### [leetcode_474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

```java
// 暴力递归
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[] ones = new int[len];
        int[] zeros = new int[len];
        for (int i = 0; i < len; i++) {
            char[] arr = strs[i].toCharArray();
            for (char c: arr) {
                if (c == '0') {
                    zeros[i]++;
                } else {
                    ones[i]++;
                }
            }
        }
        return dfs(0,0,0,0,zeros,ones,m,n);
    }
    public int dfs(int idx, int max,int curM, int curN, int[] zeros, int[] ones, int m, int n) {
        if (idx == zeros.length && curN <= n && curM <= m) {
            return max;
        }
        if (curM > m || curN > n) {
            return max-1;
        }
        int c = dfs(idx+1, max+1, curM + zeros[idx], curN + ones[idx], zeros, ones, m, n);
        int notc = dfs(idx+1, max, curM, curN, zeros, ones, m, n);
        return Math.max(c, notc);
    }
}
```

```java
// 动态规划 - 三维dp
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[] ones = new int[len];
        int[] zeros = new int[len];
        for (int i = 0; i < len; i++) {
            char[] arr = strs[i].toCharArray();
            for (char c: arr) {
                if (c == '0') {
                    zeros[i]++;
                } else {
                    ones[i]++;
                }
            }
        }
        int[][][] dp = new int[len+1][m+1][n+1];
        for (int i = 1; i <= len; i++) {
            int zero = zeros[i-1];
            int one = ones[i-1];
            for (int r=0; r <= m; r++) {
                for (int c=0; c <= n; c++) {
                    int notc = dp[i-1][r][c];
                    // 选择
                    int ch = r >= zero && c >= one? dp[i-1][r-zero][c-one] + 1: 0;
                    dp[i][r][c] = Math.max(notc, ch);
                }
            }
        }
        return dp[len][m][n];
    }
}
```

```java
// 动态规划--二维dp
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[] ones = new int[len];
        int[] zeros = new int[len];
        for (int i = 0; i < len; i++) {
            char[] arr = strs[i].toCharArray();
            for (char c: arr) {
                if (c == '0') {
                    zeros[i]++;
                } else {
                    ones[i]++;
                }
            }
        }
        int[][] dp = new int[m+1][n+1];
        for (int i = 1; i <= len; i++) {
            int zero = zeros[i-1];
            int one = ones[i-1];
            for (int r=m; r >= zero; r--) {
                for (int c=n; c >= one; c--) {
                    // 选择
                    dp[r][c] = Math.max(dp[r][c], dp[r-zero][c-one] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



# 二、基础提升班

## 哈希函数

- 特点

1. 输入无限->输出优先的转换函数。例如：MD5，SHA1。
2. 内部不存在随机
3. 不同的输入->可能产生相同的输出-哈希碰撞 
4. 很均匀的离散特性

<img src=".\算法与数据结构刷题笔记_图片\哈希函数1.png" alt="哈希函数1" style="zoom:50%;" />

- 哈希函数实现：哈希表实现哈希函数
  1. 第一步：单次扩容->O(logN)；扩容后转存->O(N)；N个字符整体复杂度->O(NlogN)，单字符平均->O(logN)，限制每个链的长度可以转化为一个很小的常数->O(1)。
  2. 第二部->离线技术加速
  3. 哈希表在使用的时候时间复杂度可以看作->O(1)--理论为O(logN)

## 布隆过滤器

- 作用

<img src=".\算法与数据结构刷题笔记_图片\布隆过滤器1.png" alt="布隆过滤器1" style="zoom: 50%;" />

- 位图

1. 用基本数据类型拼接->java的int类型占4字节_byte->一个字节8bit
2. 查询是否在名单里->通过K个哈希函数->对应的位置都为1则在名单内
3. 关键点：K和m取多少--m越大->错误率越低--K过大过小都会导致错误率变大

<img src=".\算法与数据结构刷题笔记_图片\位图1.png" alt="位图1" style="zoom:50%;" />

- 考虑是否使用布隆过滤器

1. 考虑是否有黑名单或类似结构

2. 没有删除行为

3. 是否允许一定错误率->错误率的指标

   - 根据数据量n和错误率p确定布隆过滤器的指标
   - 与单样本的数据大小无关->只要k个哈希函数内接受样本数据即可
   - m是bit长度->m/8为字节数

   <img src=".\算法与数据结构刷题笔记_图片\布隆过滤器2.png" alt="布隆过滤器2" style="zoom:50%;" />

## 一致性哈希原理

数据->逻辑服务器->数据服务器

1. 逻辑服务器：每个服务器进入频率->全等效
2. 数据服务器：每个服务器的高/中/低频率是否均衡分配--选择多样性比较多的key来分配
3. 用一致性哈希原理解决分配均衡的问题->不在使用哈希函数分配分片
4. 虚拟节点技术

<img src=".\算法与数据结构刷题笔记_图片\一致性哈希原理1.png" alt="一致性哈希原理1" style="zoom:50%;" />

<img src=".\算法与数据结构刷题笔记_图片\一致性哈希原理2.png" alt="一致性哈希原理2" style="zoom:50%;" />

## 并查集/有序表

- 并查集

1. 给定一些元素->实现两个操作->时间复杂度O(1)
   	判断两个元素是否在一个集合->bool
   	将两个集合的元素合并为一个元素
2. 实现思路

<img src=".\算法与数据结构刷题笔记_图片\并查集1.png" alt="并查集1" style="zoom:50%;" />

3. 实现方法
   - 并查集不接受临时出现的样本->必须有初始化
   - 第一个hashmap-初始化-elementmap：value->element_v--对元素进行封装
   - 第二个hashmap-fathermap查看顶节点：element_v->element_v--封装元素->上一个元素
   - 第三个hashmap-sizemap查看大小：element_v->element_v--封装元素->顶部的代表元素--中见的过程不重要
   - fatherhead->优化过程-让元素直接指向父节点

## KMP算法

- 基本介绍

1. 字符串str1和str2，str1是否包含str2，如果包含返回str2在str1中开始的位置。
2. 时间复杂度O(N)--暴力方法时间复杂度O(N*M)

- 基本思路

next_array(辅助数组)->根据**str2**->获得某字符**前面的字符串**的**最长****的**前后缀****匹配信息(比如k这个字符，为3)(前后缀信息都是整体的时候不讨论)

- - 前缀信息：在字符串中取前x个字符--x小于整个字符串的长度

- - 后缀信息：在字符串中取后x个字符
- - k取所有前后缀信息相等且最大的值(前缀和后缀的最大长度)--str2中每一个位置的k值组合->next_arr数组

<img src=".\算法与数据结构刷题笔记_图片\KMP算法1.png" alt="KMP算法1" style="zoom:50%;" />


- KMP实现思路

1. 双指针->i1和i2确定str1和str2中比对的位置
   - i1==i2时->都加一
   - i2 == 0->i1++  --  i2一直往前转换都没有可以匹配的内容，i1切换下一个
   - i2 = next[i2]
2. next_array加速获取
   - 动态规划->计算x位置的next值需要知道x-1位置的next值--该位置前面字符的最大前后缀信息--0位置为-1(前面没有字符)--1位置为0(前面只有一个字符)
   - 若x位置的字符等于next[x-1]+1的字符则next[x]=next[x-1]+1
   - 否则跳至next[x-1]位置判断它的next的值

```java
public static int[] getNextArray(char[] ms) {
    if (ms.length == 1) {
    	return new int[] {-1};
    }
    int[] next = new int[ms.length];
    next[0] = -1;//前面没有字符串--人为规定-1
    next[1] = 0;//前后缀不能取到整体--所以为0
	int i = 2;// next数组的位置
	int cn = 0;
    while (i < next.length) {
        if (ms[i - 1] == ms[cn]){
        	next[i++] = ++cn;
        }
    	//当前跳到cn位置的字符，和i-1位置的字符配不上
        else if (cn > 0) {
    		cn = next[cn];
        } else {
    		next[i++] = 0;
    	}
    }
	return next;
}
```

3. main

```java
//i1,i2同时越界->匹配完成->返回i1-i2
//i2越界->没有匹配完成->返回-1
public static int getIndexOf(String s, String m) {
    if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
        return -1;
    }
	char[] str1 = s.toCharArray();
    char[] str2 = m.toCharArray();
    int i1 = 0;
	int i2 = 0;
	int[] next = getNextArray(str2);//O(M)//O(N)
    while (i1 < str1.length && i2 < str2.length) {
        if (str1[i1] == str2[i2]) {//相等就继续往下走
            i1++;
            i2++;
        } else if (next[i2] == -1) {//str2中比对的位置已经无法往前跳了//等效于i2 == 0
            i1++;//来到str2的0位置还是没法匹配--str1下一个
        } else {//还可以利用nextArr进行跳转
        	i2 = next[i2];
    	}
    }
    //i1越界 或者 i2越界
    return i2 == str2.length ? i1 - i2 : -1;
}
```

4. 算法图解

在x,y位置不相等--从next_arr前缀相同的位置开始比--i2回跳至z位置

<img src=".\算法与数据结构刷题笔记_图片\KMP2.png" alt="KMP2" style="zoom:50%;" />

- 扩展问题

1. 旋转字符串

[leetcode_796. 旋转字符串](https://leetcode.cn/problems/rotate-string/)

indexOf也是时间复杂度为O(N)的算法，但是它的常数时间比KMP算法还优秀

2. 一棵树是否是另一颗树的子树

[leetcode_572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

子树的要求：从一个节点出发，所以子节点都必须要

- - 解题思路

1. 二叉树递归思想
2. 设计一个递归策略->判断一个树是否是另一个的树的子树->
   - 特殊情况其中一个树为空
   - 判断一个树是否和另一个的树的相等
   - 判断一个树是否是另一个的树的的左/右子树

3. 改进方法
   - 把二叉树的先序遍历(null位置补上"null"字符串)过程存放在ArrayList中。(先序序列一个子串代表唯一的结构)。
   - 一个二叉树的值和结构是另一个树的子结构，对应的先序数组也一定是另一个树的子串。

## Manacher算法

- 字符串问题->最长回文子串的长度
- 暴力解法->字符之间添加特殊字符保证找到所有奇数回文和偶数回文

1. 特殊字符可以是任意字符->不会影响最终的结果
2. 时间复杂度->O(n^2)-最差情况->全部为1

![Manacher算法](.\算法与数据结构刷题笔记_图片\Manacher算法.png)

### Manacher算法-与KMP算法有相似之处

- 相似之处：引入一个额外数组记录信息：回文半径数组

- 时间复杂度->O(n)
- 相关概念

（添加特殊字符后：特殊字符的类型不影响最后结果）

1. 回文半径：回文直径的一半进一(包括中心位置的半径)
2. 回文直径：某字符为中心-左右两边查找回文->最大长度就是回文直径
2. 回文半径数组：记录回文半径
3. 最右回文右边界：之前所有位置扩展的最右边界的位置，起始值为R = -1
4. 中心位置C

- 实现思路

1. 遍历位置i在R(R是：最右回文右边界)之外：直接外扩->判断是否有回文
2. 遍历位置i在R之内

![Manacher算法](.\算法与数据结构刷题笔记_图片\Manacher算法2.png)

- 代码实现

1. 将输入str转化为特殊符号str

2. Manacher

   - 四个判断分支整合为一句话

   ```java
   pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1; // pArr[2 * C - i] 是 i'为中心的回文半径
   // 1. i 在 R 外 -- 不用验证的区域 1
   // 2. i 在 R内 -- 不用验证的区域 
   while (i + pArr[i] < str.length && i - pArr[i] > -1) {
       //2)1.2.不需要往扩展，但是也尝试一次->简化代码
       if (str[i + pArr[i]] == str[i - pArr[i]])
       	pArr[i]++;
   	else {
           break;
       }
   }
   ```
   
   - **返回值的回文半径-1就是原字符的回文长度**

## map_reduce原理

## *窗口中的最小值最大值：单调双端队列/单调栈

- 基本思路

![滑动窗口](.\算法与数据结构刷题笔记_图片\滑动窗口.png)

## 单调栈

- 单调栈解决的问题：

1. 比当前元素更大的后一个元素
2. 比当前元素更大的前一个元素
3. 比当前元素更小的前一个元素
4. 比当前元素更大的后一个元素

- 口诀：递减栈找左边第一个比当前元素大的元素，递增栈找边第一个比当前元素小的元素。（减大增小）

- 时间复杂度：暴力迭代-时间复杂度-O(n^2) -> 优化到时间复杂度-O(n)
- 实现思路

![单调栈](.\算法与数据结构刷题笔记_图片\单调栈.PNG)

## 二叉树提升内容

### 树形dp

- 基本思路：从左和右树获取信息->如何求解题目需要的答案

- 情况分类方式：根据头节点是否参与分类

- 树形dp的基本套路

1. 第一步：以某一节点开始，分析答案的多种可能性-以x的左右树或数整体的角度
2. 第二步：分析所需要的信息
3. 第三步：从左右树获取信息
4. 第四步：设计递归函数->basecase-左右树获取信息-信息整合并返回信息

### Morris遍历二叉树

- Morris遍历二叉树(线索二叉树)-时间复杂度O(n)，额外空间复杂度O(1)：利用底部节点的空指针的空间
- 可以运用于任何需要遍历二叉树的题目中
- 递归的遍历方法子树的节点会到达3次-Morris遍历最多到达两次

- 实现细节

1. 假设来到当前节点cur，开始时cur来到头节点位置
2. 如果cur没有左孩子，cur向右移动(cur = cur.right)
3. 如果cur有左孩子，找到左子树上最右的节点mostRight:
   a.如果mostRight的右指针指向空，让其指向cur,然后cur向左移动(cur = cur.left)
   b.如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur = cur.right)
4. cur为空时遍历停止

- 实现思路

<img src=".\算法与数据结构刷题笔记_图片\Morris遍历1.png" alt="Morris遍历1" style="zoom: 50%;" />

- 先序-中序-后序遍历

1. 先序遍历：Morris遍历中出现一次的节点->直接打印，出现两次的节点->第一次打印
2. 中序遍历：Morris遍历中出现一次的节点->直接打印，出现两次的节点->第二次打印
3. 后序遍历：打印放在能第二次到达的节点-第二次来到某节点时逆序打印左树的右边界-最后单独打印整棵树的右边界

#### [leetcode_144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```java
// Morris前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        TreeNode cur = root;
        TreeNode mostRight = null;
        while (cur != null) {
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != cur && mostRight.right != null) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    ans.add(cur.val);
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                }
            } else {
                ans.add(cur.val);
            }
            cur = cur.right;
        }
        return ans;
    }
}
```

#### [leetcode_94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```java
// Morris中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        TreeNode cur = root;
        TreeNode mostRight = null;
        while (cur != null) {
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null & mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                }
            }
            ans.add(cur.val);
            cur = cur.right;
        }
        return ans;
    }
}
```

#### [leetcode_145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

```java
// Morris后序遍历
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        TreeNode cur = root;
        TreeNode mostRight = null;
        while (cur != null) {
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) { // mostRight.right
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                    printEdge(cur.left, ans);
                }
            }
            cur = cur.right;
        }
        printEdge(root, ans);
        return ans;
    }
    public void printEdge(TreeNode root, List<Integer> ans) {
        TreeNode tail = reverse(root);
        TreeNode cur = tail;
        while (cur != null) {
            ans.add(cur.val);
            cur = cur.right;
        }
        reverse(tail);
    }
    public TreeNode reverse(TreeNode root) {
        if (root == null) {return null;}
        TreeNode pre = null;
        TreeNode next = null;
        while (root != null) {
            next = root.right;
            root.right = pre;
            pre = root;
            root = next;
        }
        return pre;
    }

}
```

#### [leetcode_98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```java
// Morris遍历方法
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        TreeNode cur = root;
        TreeNode mostRight = null;
        long preVal = Long.MIN_VALUE;
        while (cur != null) {
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                }
            }
            if (cur.val <= preVal) {
                return false;
            }
            preVal = cur.val;
            cur = cur.right;
        }
        return true;
    }
}
```



## 大数据题目

- 大数据题目的7中常见解决思路

1. 哈希函数可以把数据按照种类均匀分流
2. 布隆过滤器用于集合的建立与查询，并可以节省大量空间
3. 一致性哈希解决数据服务器的负载管理问题
4. 利用并查集结构做岛问题的并行计算
5. 位图解决某一范围上数字的出现情况，并可以节省大量空间
6. 利用分段统计思想、并进一步节省大量空间
7. 利用堆、外排序来做多个处理单元的结果合并

- 根据题目的要求(服务器-内存等条件)结合7个技巧解答

### 5.相关题目

1. 32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数?
   - 哈希函数分流->多台服务器
   - 位图：一个bit表示某一位是否出现->用2^32个bit表示所有数是否存在->500多M可以表示所有数
2. (只找一个)进阶问题->内存限制为10MB，但是只用找到一个没出现过的数即可->只有3kb呢->任意内存同理
   - 1.只有3kb的内存，开3000/4(接近512)个无符号整型->将0-2^32的所有数分为512分，每一个int类型记录对应范围的数字出现的次数
   - 2.某个范围会缺少数字
   - 3.再对这个范围进行细分-重复1的步骤
   - 4.周而复始，精准确定该数字
3. (只找一个)极端情况->只给优先几个变量去查找没有的数字->二分法->对不满的一边二分

### 6.相关题目

1. 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。
2. 可以使用最多10MB的内存，怎么找到这40亿个整数的中位数?
   - 与前面思想类似->将(数字范围)0-2^32等分->找到中间位置的小文件

### 7.相关题目

1. 有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
   - 哈希函数->小文件里具体统计出现次数
   - 布隆过滤器->有失误率
2. 补充->某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法
   - 海量文件->hash函数->分小文件->小文件内部统计词频数量(hashmap)->每个小文件维护一个大根堆->把所有小文件的堆顶拿出来-单独维护一个大根堆(总堆)-继续弹出小文件的堆顶最大的值-直到总堆内有100个数-统计所有文件
   - 堆上堆-二维堆

### 其他相关题目

1. 10G的无序数字文件->使用5G/5M/5K内存让他变为有序文件
   - 方法1.小根堆-将给到的内存用来构建小根堆(考虑小根堆数据维护所占的字节数，约4个字节维护一个小根堆，key-val)
      - 分范围排序
   - 方法2.遍历数据->把最小的n个数存在大根堆中
     - 按照大根堆的词频生成数据->完成排序

## 动态规划(Dynamic Programming)

- 动态规划-记忆化搜索-表结构-表结构*精->暴力递归改动态规划
- 尝试方法->从左到右-范围内尝试->最基础的尝试方法

1. 单个可变参数的维度-最重要的一步-单个可变参数的维度最好就是一个整数-面试题通常都是整数
   - int类型-0维参数
   - list类型-多维
2. **可变参数**的个数：**越少越好**

- 严格表结构的动态规划

1. 确定可变参数的范围-确定表的维度
2. 起始-终止位置
3. basecase
4. 一般位置与其他位置的依赖关系
5. 确定计算顺序

- **面试场合遇到的问题一定可以改成无后效性的动态规划

### 完全背包问题

#### [leetcode_518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

- 实现思路：所有钱的每一种可能的数量都尝试一边
- 优化思路

1. **斜率优化**->减少枚举次数(找规律)-枚举行为被邻接位置代替
2. **降维优化**->计算某一行的值只跟下一行有关系

- 实现代码

```java
// 暴力递归 --> 超时
class Solution {
    public int change(int amount, int[] coins) {
        return dfs(amount, 0, coins);
        
    }
    public int dfs(int cur, int idx,int[] coins) {
        if (cur == 0) {
            return 1;
        }
        if (cur < 0 || idx >= coins.length) { 
            return 0;
        }
        int c = dfs(cur-coins[idx], idx, coins);
        int nc = dfs(cur, idx + 1, coins);
        return c+nc;

    }
}
```

```java
// 二维动态规划
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[][] dp = new int[len+1][amount+1];
        for (int i=0;i<len;i++) {
            dp[i][0]=1;
        }
        for (int i = len-1; i >= 0; i--) {
            for (int cur = 1; cur <= amount; cur++) {
                if (cur-coins[i] >= 0) {
                    dp[i][cur] = dp[i][cur-coins[i]] + dp[i+1][cur];
                } else { // 完全背包需要从相减小于0开始考虑
                    dp[i][cur] += dp[i+1][cur];
                }
            }
        }
        return dp[0][amount];
    }
}
```

```java
// 一维动态规划
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[] dp = new int[amount+1];
        dp[0]=1;
        for (int coin: coins) {
            for (int cur = coin; cur <= amount; cur++) {
                    dp[cur] += dp[cur-coin];
            }
        }
        return dp[amount];
    }
}
```

#### [leetcode_322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```java
// 暴力递归->超时
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (coins.length == 0){ return -1; }
        return dfs(0, 0, 0, coins, amount);
    }
    public int dfs(int cur, int coinNum, int curCoin,int[] coins, int amount) {
        if (cur == amount) {
            return coinNum;
        }
        if (cur > amount || curCoin == coins.length) {
            return -1;
        }
        int a = dfs(cur + coins[curCoin], coinNum+1, curCoin, coins, amount);
        int b = dfs(cur, coinNum, curCoin+1, coins, amount);
        if (a > 0 && b > 0) {return Math.min(a, b);}
        else {return Math.max(a, b);}
    }
}
// 暴力递归 -> dfs的参数优化
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (coins.length == 0){ return -1; }
        int ans = dfs(0, amount, coins);
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
    public int dfs(int idx, int rest, int[] coins) {
        if (rest == 0) {
            return 0;
        }
        if (rest < 0 || idx == coins.length) {
            return Integer.MAX_VALUE;
        }
        int a = dfs(idx, rest - coins[idx], coins);
        a = a == Integer.MAX_VALUE ? Integer.MAX_VALUE : a + 1;
        int b = dfs(idx + 1, rest, coins);
        return Math.min(a, b);
    }
}
```

```java
// 动态规划
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (coins.length == 0){ return -1; }
        int[] dp = new int[amount+1];
        Arrays.fill(dp, amount+1);
        dp[0]=0;
        for (int coin: coins) {
            for (int rest = coin; rest <= amount; rest++) {
                    dp[rest] = Math.min(dp[rest - coin]+1, dp[rest]);
            }
        }
        return dp[amount] == amount+1 ? -1: dp[amount];
    }
}
```

### 01背包问题

#### [leetcode_416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

```java
// 暴力递归->超时
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len <= 1) {return false;}
        int sum = 0;
        for (int num:nums) {
            sum += num;
        }
        if ((sum & 1) == 1) {return false;}
        return dfs(sum >> 1, 0, nums);
    }
    public boolean dfs(int cur, int idx, int[] nums) {
        if (cur == 0) {
            return true;
        }
        if (cur < 0 || idx >= nums.length) {
            return false;
        }
        boolean c = dfs(cur-nums[idx], idx + 1, nums);
        boolean nc = dfs(cur, idx + 1, nums);
        return c || nc;
    }
}
```

```java
// 二维dp
// 动态规划
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len <= 1) {return false;}
        int sum = 0;
        for (int num:nums) {
            sum += num;
        }
        if ((sum & 1) == 1) {return false;}
        int tar = (sum >> 1);
        boolean[][] dp = new boolean[len+1][tar + 1];
        for (int i = 0; i < len; i++) {
            dp[i][0] = true;
        }
        for (int i = len-1; i >= 0; i--) {
            for (int cur = 1; cur <= tar; cur++) {
                if (cur < nums[i]) {
                    dp[i][cur] |= dp[i+1][cur]; // 根据递归得出的判断--cur < nums[i] 选择情况为false 只用判断不选择的情况
                } else {
                    dp[i][cur] = dp[i+1][cur-nums[i]] || dp[i+1][cur];
                }
            }
        }
        return dp[0][tar];
    }
}
```

```java
// 一维dp
// 动态规划
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len <= 1) {return false;}
        int sum = 0;
        for (int num:nums) {
            sum += num;
        }
        if ((sum & 1) == 1) {return false;}
        int tar = (sum >> 1);
        boolean[] dp = new boolean[tar + 1];
        dp[0] = true;
        for (int num: nums) {
            for (int cur = tar; cur >= num; cur--) {
                dp[cur] |= dp[cur-num];
            }
        }
        return dp[tar];
    }
}
```

### 其他题目

#### 机器人问题

- 题目描述

1. N：代表总共有多少个位置。
2. S：机器人的出发位置。
3. E：机器人的目的地。
4. K：机器人必须走K步。
5. 问题：请你求出机器人从S起始位置走K步到达终止位置E，一共有多少种走法？注意，每次机器人必须走一步，不能留在原地，每次只能走一格，可以向右或者向左。

- 解题思路

1. 暴力递归
   - 1.basecase->来到E位置-判断是否完成一次路线
   - 2.在1位置和N位置分别只能向右移动和向左移动
   - 时间复杂度-高度为K的二叉树-O(2^k)
2. 记忆化搜索
    - 时间复杂度-O(k*n)
    - 在递归过程中记录表的值-减少重复计算
3. 改动态规划->空间换时间-将已运算的结果存起来	![动态规划_机器人问题](.\算法与数据结构刷题笔记_图片\动态规划_机器人问题.png)

- S->E必须走K步有多少种方法

1. 暴力递归

```java
public class CodeB1 Robotwalk{
    public static int walkWays(int N, int E, int S, int K) {
		return f(N, E, K, S);
    }
// 一共是1~N这么多位置 固定参数
//最终的目标是E 固定参数
//还剩rest步需要走
// 当前在cur位置
// 返回方法数
	public static int f(int N, int E, int rest, int cur) {
    if (rest == ) {
        return cur == E ? 1 : 0;
    }
	if (cur == 1) {
		return f(N, E, rest - 1, 2);
    }
    if (cur == N) {
        return f(N，E,rest - 1，N - 1);
    }
	return f(N, E, rest - 1, cur - 1) + f(N, E, rest - 1, cur + 1);
}
```

2. 记忆化搜索

```java
// 多一个缓存
```

3. 动态规划

#### leetocode_62. 不同路径

#### leetcode_486. 预测赢家

- 实现思路

1. 暴力递归
   - 设计两个函数-在数组arr的[L,R]范围上先手拿牌返回最大分数-在数组arr的[L,R]范围上后手拿牌返回最小分数
   - basecase-数组中只有一张牌，L==R
2. 动态规划

![动态规划_预测赢家](.\算法与数据结构刷题笔记_图片\动态规划_预测赢家.png)

#### 中国象棋中-马从(0,0)位置走到(a,b)位置必须走K步->怎么走

- 实现思路

1. f-输入现在位置(a0,b0)和目标位置(a,b)-行走的步数
2. 1.basecase-步数用完了k-rest == 0

- 实现代码：暴力递归-棋盘大小8*9-反算思想->怎么从(a,b)回(0,0)

```java
public static int process(int x, int y, int step) {
    if(x<0  || x > 8 || y < 0 || y > 9){
        return 0;
    }
    if (step == 0) { // 不能再动了
    	return (x == 0 && y == 0) ? 1: 0;
    }
    return process(x-1, y+2, step-1) + process(x-1, y-2, step-1) + process(x+1, y+2, step-1) + process(x+1, y-2, step-1) +
        process(x-2, y+1, step-1) + process(x-2, y-1, step-1) + process(x+2, y+1, step-1) + process(x+2, y-1, step-1);
}
```

#### leetcode_688. 骑士在棋盘上的概率

- 简化版本->给定一个(M，N)的小岛-bot随机上下左右移动-超过边界就死亡->求存活的概率是多少->存活下来的方法数/4^k就是存活的概率

## 提升班相关题目

### 哈希表/哈希函数相关题目

#### [leetcode_380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

- 解题思路

1. 要一直保持index的分布是连续的->才能实现完全随机的获取元素
2. 当删除某一元素时，用最后一个元素来填补该元素的index

### MapReduce

#### [leetcode_200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

- 解题思路

1. infect->时间复杂度O(n*m)

	调用一次感染过程就把周围的所有1变为2->调用几次感染过程就有几个岛
	递归的basecase->行列越界/位置的值不为1->只关心连成一片的1->其他return->将[i,j]位置改为2
	递归上下左右

2. 进阶->设计一个并行算法解决该问题
   	输入是超大型2维矩阵->对矩阵进行分片处理->并行计算->引入并查集
   	将大型矩阵拆分->各自查找岛屿->边界拼接-并查集

#### [leetcode_778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/)

### KMP算法题目

#### [leeetcode_28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

```java
//KMP算法
class Solution {
    public int strStr(String haystack, String needle) {
        if (haystack == null || needle == null || haystack.length() < 1 || haystack.length() < needle.length()) {
            return -1;
        }
        char[] c1 = haystack.toCharArray();
        char[] c2 = needle.toCharArray();
        int l1 = c1.length;
        int l2 = c2.length;
        int[] next = getNextArr(c2);
        int i1 = 0;
        int i2 = 0;
        while (i1 < l1 && i2 < l2) {
            if (c1[i1] == c2[i2]) {
                i1++;
                i2++;
            } else if (i2 == 0) {
                i1++;
            } else {
                i2 = next[i2];
            }
        }
        return i2 == l2 ? i1 - i2 : -1; 
    }
    public int[] getNextArr(char[] charStr) {
        int l = charStr.length;
        if (l == 1) {
            return new int[] {1};
        }
        int[] next = new int[charStr.length];
        next[0] = -1;
        next[1] = 0;
        int idx = 2;
        int curNext = 0;
        while (idx < l) {
            if (charStr[idx-1] == charStr[curNext]) {
                next[idx++] = ++curNext;
            } else if (curNext > 0) {
                curNext = next[curNext];
            } else {
                next[idx++] = 0;
            }
        }
        return next;
    }
}
```

#### [leetcode_796. 旋转字符串](https://leetcode.cn/problems/rotate-string/)

- 解题思路

目标：判断str2是否是str1的旋转字符串

思路：在str2后面拼接一个str2，直接查看str1是否是newstr2的子串

<img src=".\算法与数据结构刷题笔记_图片\旋转字符串1.png" alt="旋转字符串1" style="zoom:50%;" />



```java
class Solution {
    public boolean rotateString(String s, String goal) {
        return s.length() == goal.length() && (s + s).contains(goal);
    }
}
```

#### [leetcode_572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

- 实现代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (subRoot == null) {
            return true;
        }
        if (root == null) {
            return false;
        }
        if (isSameValueStructure(root, subRoot)) {
            return true;
        }
        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }
    public boolean isSameValueStructure(TreeNode head1, TreeNode head2) {
        if (head1 == null && head2 != null) {
            return false;
        }
        if (head1 != null &&  head2 == null) {
            return false;
        }
        if (head1 == null && head2 == null) {
            return true;
        }
        if (head1.val != head2.val) {
            return false;
        }
        return isSameValueStructure(head1.left, head2.left) 
            && isSameValueStructure(head1.right, head2.right);
    }
}
```

```java
//两个递归融合
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        return dfs(root, subRoot, subRoot);
    }
    public boolean dfs(TreeNode cur, TreeNode subTree, TreeNode subRoot) {
        if (cur == null && subTree == null) return true;
        if (cur == null || subTree == null) return false;
        if (cur.val == subTree.val) {
            return dfs(cur.left, subTree.left, subTree)
                    && dfs(cur.right, subTree.right, subTree)
                    || dfs(cur.left, subRoot, subRoot)
                    || dfs(cur.right, subRoot, subRoot);
        } else {
            return dfs(cur.left, subRoot, subRoot) || dfs(cur.right, subRoot, subRoot);
        }

    }
}
```

```java
//KMP思路改进
class Solution {
    public boolean isSubtree(TreeNode big, TreeNode small) {
        if (small == null) {
            return true;
        }
        if (big == null) {
            return false;
        }
        ArrayList<String> b = preSerial(big);
        ArrayList<String> s = preSerial(small);
        String[ ] str = new String[b.size()];
        for (int i = 0; i < str.length; i++) {
            str[i] = b.get(i);
        }
        String[] match = new String[s.size( )];
        for (int i = 0; i < match. length; i++) {
            match[i] = s.get(i);
        }
        return getIndexOf(str, match) != -1;
}
    public int getIndexOf(String[] str1, String[] str2) {
        if (str1 == null || str2 == null || str1.length < 1 || str1.length < str2.length) {
            return -1;
        }
        int x = 0;
        int y = 0;
        int[] next = getNextArray(str2);
        while (x < str1.length && y < str2.length) {
            if (isEqual(str1[x], str2[y])){
                x++;
                y++;
            } else if (next[y] == -1) {
                x++;
            } else {
                y = next[y];
            }
        }
        return y == str2.length ? x - y : -1;
    }
    public int[] getNextArray(String[] ms) {
        if (ms.length == 1) {
            return new int[] { -1 };
        }
        int[] next = new int[ms.length];
        next[0] = -1;
        next[1] =0;
        int i = 2;
        int cn = 0;
        while (i < next.length) {
            if (isEqual(ms[i - 1], ms[cn])) {
                next[i++] = ++cn;
            }else if (cn > 0) {
                cn = next[cn];
            }else {
                next[i++] = 0;
            }
        }
        return next;
    }
    public boolean isEqual(String a, String b) {
        if (a== null && b == null) {
            return true;
        }else {
        if (a== null || b == null) {
            return false;
        }else {
            return a.equals(b);
        }
        }
    }
    public ArrayList<String> preSerial(TreeNode head) {
        ArrayList<String> list = new ArrayList<>();
        if (head == null) {
            list.add("null");
        } else {
            list.add(head.val + "");
            list.addAll(preSerial(head.left));
            list.addAll(preSerial(head.right));
        }
        return list;
    }
}
```

### Manacher算法：

#### [leetcode_5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

```java
// 暴力解法--中心扩展--时间复杂度O(n^2)
class Solution {
    public String longestPalindrome(String s) {
        final char[] chars = s.toCharArray();
        final int length = chars.length;
        if (length == 0) {
            return "";
        }
        if (length == 1) {
            return s;
        }
        int start = 0, end = 0;
        for (int i = 0; i < length; i++) {
            int left = i, right = i;
            while (left >= 0 && right < length && chars[left] == chars[right]) {
                left--;
                right++;
            }
            if (right - left - 1 > end - start) {
                start = left + 1;
                end = right;
            }
            left = i;
            right = i + 1;
            while (left >= 0 && right < length && chars[left] == chars[right]) {
                left--;
                right++;
            }
            if (right - left - 1 > end - start) {
                start = left + 1;
                end = right;
            }
        }
        return s.substring(start, end);
    }
}
```

```java
// manacher算法 -- 左神教学写法
class Solution {
    public String longestPalindrome(String s) {
        StringBuffer sb = new StringBuffer("#");
        for (int i = 0; i < s.length(); i++) {
            sb.append(s.charAt(i));
            sb.append("#");
        }
        int[] pArr = new int[sb.length()];
        int c = 0, r = -1;
        int start = -1, end = -1;
        for (int i=0; i < sb.length(); i++) {
            pArr[i] = r > i ? Math.min(pArr[2*c-i], r-i) : 1;
            while (i+pArr[i] < sb.length() && i-pArr[i] >= 0) {
                if (sb.charAt(i+pArr[i]) == sb.charAt(i-pArr[i]))
                    pArr[i]++;
                else
                    break;
            }
            if (i+pArr[i] > r) {
                r = i+pArr[i];
                c = i;
            }
            if (pArr[i]*2-1 > end - start) {
                start = i - pArr[i] + 1;
                end = i + pArr[i] - 1; 
            }
        }
        StringBuffer ans = new StringBuffer();
        for (int i = start; i <= end; i++) {
            if (sb.charAt(i) != '#') {
                ans.append(sb.charAt(i));
            }
        }
        return ans.toString();
    }
}
```

```java
// 数组实现manacherArray 速度更快
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len == 1) return s;
        char[] chars = new char[len*2+1];
        chars[0] = '#';
        for (int i = 1, idx = 0; i < chars.length;) {
            chars[i++] = s.charAt(idx++);
            chars[i++] = '#';
        }
        int[] pArr = new int[len*2+1];
        int c = 0, r = -1;
        int start = -1, end = -1;
        for (int i=0; i < chars.length; i++) {
            pArr[i] = r > i ? Math.min(pArr[2*c-i], r-i) : 1;
            while (i+pArr[i] < chars.length && i-pArr[i] >= 0) {
                if (chars[i+pArr[i]] == chars[i-pArr[i]])
                    pArr[i]++;
                else
                    break;
            }
            if (i+pArr[i] > r) {
                r = i+pArr[i];
                c = i;
            }
            if (pArr[i]*2-1 > end - start) {
                start = i - pArr[i] + 1;
                end = i + pArr[i] - 1; 
            }
        }
        StringBuffer ans = new StringBuffer();
        for (int i = start; i <= end; i++) {
            if (chars[i] != '#') {
                ans.append(chars[i]);
            }
        }
        return ans.toString();
    }
}
```

#### [leetcode_131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

```java
// 动态规划 + 回溯
class Solution {
    List<List<String>> ans = new ArrayList<>();
    public List<List<String>> partition(String s) {
        int len = s.length();
        char[] cs = s.toCharArray();
        boolean[][] dp = new boolean[len][len];
        for (int i=len-1; i >= 0; i--) {
            for (int j=i; j < len; j++) {
                if (i == j) {
                    dp[i][j] = true;
                } else if (j-i == 1){
                    dp[i][j] = cs[i] == cs[j];
                } else {
                    dp[i][j] = cs[i] == cs[j] && dp[i+1][j-1];
                }
            }
        }
        dfs(s, cs, 0, new ArrayList<String>(), dp);
        return ans;
    }
    public void dfs (String s, char[] cs, int cur , List<String> curList, boolean[][] dp) {
        if (cur == cs.length) {
            ans.add(new ArrayList<>(curList));
        }
        for (int i = cur; i < cs.length; i++) {
            if (dp[cur][i]) {
                curList.add(s.substring(cur, i+1));
                dfs(s, cs, i+1, curList, dp);
                curList.removeLast();
            }
        }
    }
}
```



### 滑动窗口题目：

#### [leetcode_3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```java
// 遍历每个字母为首的最长字符串
class Solution {
    public int lengthOfLongestSubstring(String s) {
        char[] chars = s.toCharArray();
        int[] map = new int[256];
        Arrays.fill(map, -1);
        int ans = 0;
        int p = -1; // 当前字符上一次出现的位置
        for (int i=0; i<chars.length; i++) {
            p = Math.max(p, map[chars[i]]);
            ans = Math.max(ans, i-p);
            map[chars[i]] = i;
        }
        return ans;
    }
}
```

#### leetcode_76. 最小覆盖子串

#### leetcode_239. 滑动窗口最大值-hard

```java
// 单调队列
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length < k) {
            return null;
        }
        int len = nums.length;
        LinkedList<Integer> list = new LinkedList<>();
        int[] res = new int[len - k + 1];
        int idx = 0;
        for (int i=0; i<len; i++) {
            while (!list.isEmpty() && nums[list.peekLast()] <= nums[i]) {
                list.pollLast();
            }
            list.addLast(i);
            if (list.peekFirst() == i-k) {
                list.pollFirst();
            }
            if (i - k >= - 1) {
                res[idx++] = nums[list.peekFirst()];
            }
        }
        return res;
    }
}
```



#### leetcode_424. 替换后的最长重复字符

#### leetcode_438. 找到字符串中所有字母异位词

#### leetcode_480. 滑动窗口中位数

#### leetcode_567. 字符串的排列

#### leetcode_992.K个不同整数的子数组

#### leetcode_995.K连续位的最小翻转次数

### 单调栈题目

#### [leetcode_496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

```java
// 单调栈 + hashmap
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> map = new HashMap<>();
        Deque<Integer> stack = new ArrayDeque<>();
        int[] res = new int[nums1.length];
        for (int i=0;i < nums2.length; i++) {
            int num = nums2[i];
            while (!stack.isEmpty() && num > stack.peek()){
                int out = stack.pop();
                map.put(out, num);
            }
            stack.push(num);
        }
        while (!stack.isEmpty()) {
            map.put(stack.pop(), -1);
        }
        for (int i = 0; i < nums1.length; i++) {
            res[i] = map.get(nums1[i]);
        }
        return res;
    }
}
```

#### [leetcode_907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

```java
// 单调递增栈
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int len = arr.length;
        int[] left = new int[len];
        int[] right = new int[len];
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < len; i++) { // 两个while循环完成单调栈
            while (!stack.isEmpty() && arr[i] < arr[stack.peek()]) {
                int cur = stack.pop();
                right[cur] = i - cur;
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int idx = stack.pop();
            right[idx] = len - idx;
        }
        for (int i = len-1; i >= 0; i--) {
            while (!stack.isEmpty() && arr[i] <= arr[stack.peek()]) { // 相同元素只能算一边
                int cur = stack.pop();
                left[cur] = cur - i;
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int idx = stack.pop();
            left[idx] = idx+1;
        }
        long ans = 0;
        final int MOD = 1000000007;
        for (int i = 0; i < len; i++) {
            ans = (ans + (long) left[i] * right[i] * arr[i]) % MOD; 
        }
        return (int) ans;
    }
}
```

#### [leetcode_795. 区间子数组个数](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/)

```java
// 用递减栈找到左右两边第一个比自己大的位置
class Solution {
    public int numSubarrayBoundedMax(int[] nums, int left, int right) {
        Deque<Integer> stack = new ArrayDeque<>();
        int len = nums.length;
        int[] l = new int[len];
        int[] r = new int[len];
        for (int i=0; i<len; i++) {
            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i]) {
                stack.pop();
            }
            l[i] = i - (stack.isEmpty() ? -1 : stack.peek());
            stack.push(i);
        }
        stack.clear();
        for (int i=len-1; i>=0; i--) {
            while (!stack.isEmpty() && nums[stack.peek()] < nums[i]) {
                stack.pop();
            }
            r[i] = (stack.isEmpty() ? len : stack.peek()) - i;
            stack.push(i);
        }
        stack.clear();
        int ans = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] >= left && nums[i] <= right) {
                ans += l[i] * r[i];
            }
        }
        return ans;
    }
}
```

```java
// 双指针，记录以当前位置结尾的所有情况
class Solution {
    public int numSubarrayBoundedMax(int[] nums, int left, int right) {
        int start = -1, end = -1;
        int res = 0;
        for (int i=0; i < nums.length; i++) {
            if (nums[i] > right) start = i;
            if (nums[i] >= left) end = i;
            res += (end - start);
        } 
        return res;
    }
}
```

### 树形dp

#### [leetcode_543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

- 解题思路：

1. 返回值：树的高度和最大距离
2. base_case:节点为空返回(0, 0)

![二叉树直径](.\算法与数据结构刷题笔记_图片\二叉树直径.png)

- 实现代码

```java
// 树形dp--向左右树拿信息
class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        int[] res = dfs(root);
        return Math.max(res[0], res[1])-1;
    }
    public int[] dfs (TreeNode root) {
        if (root == null) {
            return new int[]{0, 0};
        }
        int[] left = dfs(root.left);
        int[] right = dfs(root.right);
        int dis = Math.max(left[1]+right[1]+1, Math.max(left[0], right[0]));
        int high = Math.max(left[1], right[1]) + 1;
        return new int[]{dis, high};
    }
}
```

```java
class Solution {
    int m = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) return 0;
        dfs(root);
        return m;
    }
    public int dfs (TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = dfs(root.left);
        int right = dfs(root.right);
        m = Math.max(left + right, m);
        return Math.max(left, right) + 1;
        }
}
```

#### [leetcode_834. 树中距离之和](https://leetcode.cn/problems/sum-of-distances-in-tree/)

```java
// 换根dp
class Solution {
    List<Integer>[] dis;  // 相互连接的点
    int[] ans, sons; // sons 记录0为头的所有节点的子树大小
    public int[] sumOfDistancesInTree(int n, int[][] edges) {
        dis = new ArrayList[n];
        ans = new int[n];
        sons = new int[n];
        Arrays.setAll(dis, e -> new ArrayList<>());
        for (int[] egde: edges) {
            dis[egde[0]].add(egde[1]);
            dis[egde[1]].add(egde[0]);
        }
        dfs(0, -1, 0);
        reRoot(0, -1);
        return ans;
    }
    public void dfs(int cur, int fat, int depth) {
        ans[0] += depth; // 所有点到0的距离
        sons[cur] = 1;
        for (int son: dis[cur]) {
            if (son != fat) {
                dfs(son, cur, depth + 1);
                sons[cur] += sons[son];
            }
        }
    }
    public void reRoot(int cur, int fat) { // 递归遍历所有节点
        for (int son: dis[cur]) {
            if (son != fat) {
                ans[son] = ans[cur] + ans.length - 2 * sons[son];
                reRoot(son, cur);
            }
        }
    }
}
```

#### [leetcode_662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

```java
// 朴素递归方法--计算过程有重复
class Solution {
    Map<Integer, Integer> levelMin = new HashMap<Integer, Integer>();

    public int widthOfBinaryTree(TreeNode root) {
        return dfs(root, 1, 1);
    }

    public int dfs(TreeNode node, int depth, int index) {
        if (node == null) {
            return 0;
        }
        levelMin.putIfAbsent(depth, index); // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值
        return Math.max(index - levelMin.get(depth) + 1, 
        Math.max(dfs(node.left, depth + 1, index * 2), 
        dfs(node.right, depth + 1, index * 2 + 1)));
    }
}
```

```java
// 记录每层最大值
class Solution {
    Map<Integer, Integer> levelMin = new HashMap<Integer, Integer>();
    int res = 0;

    public int widthOfBinaryTree(TreeNode root) {
        dfs(root, 1, 1);
        return res;
    }

    public void dfs(TreeNode node, int depth, int index) {
        if (node == null) {
            return;
        }
        levelMin.putIfAbsent(depth, index); // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值
        res = Math.max(index - levelMin.get(depth) + 1, res);
        dfs(node.left, depth + 1, index * 2);
        dfs(node.right, depth + 1, index * 2 + 1);
    }
}
```



#### 牛客_派对的最大快乐值

- 实现代码 :可以尝试一下-需要自己建树

```java
public static int maxHappy(Employee boss) {
	Info headInfo = process(boss);
	return Math.max(headInfo.laiMaxHappy， headInfo.buMaxHappy);
}
```

```java
public static Info process(Employee x) {
    if(x.nexts.isEmpty()){ // x是基层员工的时候
    	return new Info(x.happy, 0);
    }
    int lai = x.happy;// x来的情况下，整棵树最大收益
    int bu = 0;// x不来的情况下，整棵树最大收益
    for (Employee next : x.nexts) {
        Info nextInfo = process(next);
        lai += nextInfo.buMaxHappy;
        bu += Math.max(nextInfo.laiMaxHappy, nextInfo.buMaxHappy);
    }
    return new Info(lai,bu);
}
```

![最大快乐值](.\算法与数据结构刷题笔记_图片\最大快乐值.png)

### 动态规划

#### 序列DP

##### 序列DP模板问题：[leetcode_1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

- 解题思路：见后续高级班部分
- 实现代码：序列DP/范围上尝试

注意：字符串序列DP通常考虑第0-i个字符的情况，比如第0-1个字符指第一个字符，对应的索引为0

```java
// 动态规划
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] c1 = text1.toCharArray();
        char[] c2 = text2.toCharArray();
        int len1 = c1.length;
        int len2 = c2.length;
        int[][] dp = new int[len1+1][len2+1];       
        for (int i=1; i <= len1; i++) {
            for (int j=1; j <= len2; j++) {
                if (c1[i-1] == c2[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```

##### [leetcode_139. 单词拆分](https://leetcode.cn/problems/word-break/)

```java
// 范围内尝试
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        for (String str: wordDict) {
            set.add(str);
        }
        int len = s.length();
        boolean[] dp = new boolean[len + 1];
        dp[0] = true;
        for (int i=1; i <= len; i++) {
            for (int j = 1; j <= i && !dp[i];j++) {
                String sub = s.substring(j-1, i); // 注意：字符的起始位置
                if (set.contains(sub)) {
                    dp[i] = dp[j-1];
                }
            }
        }
        return dp[len];
    }
}
```

##### [leetcode_300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

- 左神思路

1. 动态规划--时间复杂度O(n^2)
   - dp[i]含义--以第i个结尾最长递增子序列的长度
   - 到达i位置找0->i-1位置比自己小且最长的->加上自己
2. 优化方法--不再遍历查找比自己小的位置--引入贪心思想--找最小的位置
   - 引入额外信息--end[i]数组--所有长度为i + 1的递增子序列中最小结尾的值

<img src=".\算法与数据结构刷题笔记_图片\最长递增子序列.png" alt="最长递增子序列" style="zoom:50%;" />

- 题解思路

```java
// 搜索dp - 时间复杂度O(n^2)
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len == 1) {return 1;}
        int[] dp = new int[len+1]; // 以第i个字符结尾的情况
        int max = 0;
        for (int i=1; i <= len;i++) {
            dp[i] = 1;
            for (int j=1; j < i;j++) {
                if (nums[i-1] > nums[j-1]) {
                    dp[i] = Math.max(dp[i], dp[j]+1);
                }
            }
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```

```java
// 二分+贪心+dp获取信息 - 时间复杂度O(n*logn)
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len == 1) {
            return 1;
        }
        int[] dp = new int[len+1];
        dp[1] = nums[0];
        int res = 1;
        for (int i = 1; i < len; i++) {
            if (dp[res] < nums[i]) {
                dp[++res] = nums[i];
            } else {
                int l=1,r=res, pos = 0; // 二分法找不到比第一个比nums[i]的数就更新第一个位置的值
                while (l <= r) {
                    int mid = (l+r) >> 1;
                    if (dp[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                dp[pos+1] = nums[i];
            }
        }
        return res;
    }
}
```

##### [leetcode_354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, (a,b) -> a[0]!=b[0]? a[0]-b[0]: b[1]-a[1]);
        int len = envelopes.length;
        if (len == 1) {return 1;}
        int[] dp = new int[len];
        int ans = 0;
        for (int i=0; i < len; i++) {
            dp[i] = 1;
            for (int j = i-1 ; j >= 0; j--) {
                if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]){
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

```java
// 二维LIS问题
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, new Comparator<int[]>(){
            public int compare(int[] a1, int[] a2) {
                return a1[0]!=a2[0]? a1[0]-a2[0]: a2[1]-a1[1];
            }
        });
        int len = envelopes.length;
        if (len == 1) {return 1;}
        int[] dp = new int[len+1];
        dp[1] = envelopes[0][1];
        int ans = 1;
        for (int i=1; i < len;i++) {
            int cur = envelopes[i][1];
            if (cur > dp[ans]) {
                dp[++ans] = cur;
            } else {
                int l = 1, r = ans, pos = 0;
                while (l <= r) {
                    int mid = (l+r) >> 1;
                    if (dp[mid] >= cur) {
                        r = mid - 1;
                    } else {
                        pos = mid;
                        l = mid + 1;
                    }
                }
                dp[pos+1] = cur;
            }
        }
        return ans;
    }
}
```

```java
// 优化掉pos参数
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, (a,b) -> a[0]!=b[0]? a[0]-b[0]: b[1]-a[1]);
        int len = envelopes.length;
        if (len == 1) {return 1;}
        int[] dp = new int[len+1];
        dp[1] = envelopes[0][1];
        int ans = 1;
        for (int i=1; i < len;i++) {
            int cur = envelopes[i][1];
            if (cur > dp[ans]) {
                dp[++ans] = cur;
            } else {
                int l = 1, r = ans;
                while (l <= r) {
                    int mid = (l+r) >> 1;
                    if (dp[mid] >= cur) {
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                }
                dp[l] = cur;
            }
        }
        return ans;
    }
}
```

## 有序表

- 有序表：时间复杂度O(logN)
- 实现方法

1. 平衡搜索二叉树系列-默认搜索二叉树上没有重复节点->可以在节点附加数据-记录出现次数
   - 红黑树
   - AVL树
   - SBT(size balance tree)-比赛常用-比较好改写
2. 链表系列
   - 跳表(skip list)

### 搜索二叉树

- 1.增删改查

1. 查找->右边的永远比节点小-左边永远比节点大-记录最近的符合要求的数据
2. 删除->没有左右孩子直接删除->只有一个孩子-直接让该孩子接替节点->左右孩子都存在
3. 节点左右孩子都有-找到节点右孩子最左节点(没有左孩子)-该节点的父节点(左子树)接管他的右孩子->在被替换节点处用该节点替换

<img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_增删改查1.png" alt="搜索二叉树_增删改查1" style="zoom:67%;" />

4. 增加：依次比较并添加-添加辅助信息解决重复问题和额外内容

- 2.平衡二叉树：维护

1. 任一节点对应的两棵子树的最大高度差为1-时间复杂度O(logN)

2. 实际情况下数据很难保持为平衡二叉树（eg:数据如果顺序增长->退化为链表-时间复杂度O(N)）-广义平衡->左右子树规模相差在一定范围内

3. 搜索二叉树+左旋和右旋->带自平衡操作的搜索二叉树+如何使用左右旋操作->AVL

   - 红黑树-SB树-AVL都是最外层操作->解决左右旋如何完成‘

     <img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_维护1.png" alt="搜索二叉树_维护1" style="zoom:50%;" />

   - 左旋->头节点倒向左边

     ![搜索二叉树_维护2](.\算法与数据结构刷题笔记_图片\搜索二叉树_维护2.png)

   - 右旋->头节点倒向右边

![搜索二叉树_维护3](.\算法与数据结构刷题笔记_图片\搜索二叉树_维护3.png)

- 怎么判断而二叉树是否平衡-什么时候该使用左右旋-AVL树的标签：高度-SB树的标签：size-红黑树的标签：颜色
- AVL

1. 增->在添加一个节点后->往上检查每一个节点的平衡性

<img src=".\算法与数据结构刷题笔记_图片\AVL1.png" alt="AVL1" style="zoom:67%;" />

2. 删除->有三种情况
   - 没有左右子树/只有一边子树：从删除位置开始向上检查
   - 特殊-左右子树都存在的情况 -- 删除4位置-从6位置开始检查

<img src=".\算法与数据结构刷题笔记_图片\AVL2.png" alt="AVL2" style="zoom:67%;" />

- 如何检查平衡性：来到某一节点

1. 某节点左子树的高度过大->右旋
2. 某节点右子树的高度过大->左旋
3. 某节点左子节点(节点为l1)的右子树(节点为x1)过长(LR型)
   - 把x1调整为树的root
   - x1先左旋再右旋

<img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_平衡检查1.png" alt="搜索二叉树_平衡检查1" style="zoom:50%;" />

4. 某节点右节点的左子树过长(RL型)
5. 实现代码

<img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_平衡检查2_代码.png" alt="搜索二叉树_平衡检查2_代码" style="zoom:67%;" />

- SB树

1. 平衡性-某节点的子树的大小不小于其兄弟节点的子树的大小

<img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_SB1.png" alt="搜索二叉树_SB1" style="zoom:67%;" />

2. 与AVL类似-增删改查某一节点后->该节点往上所有节点检查一次

   - 1.LL型-T节点的左子节点的左子树>T节点的右子树

     - 调整函数m(Node)
     - 调整流程
       1.T节点右旋-T'
       2.检测所有子节点有变化的节点-m(T')-m(L)

     <img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_SB2.png" alt="搜索二叉树_SB2" style="zoom: 50%;" />

   - 2.RR型-同理

   - 3.LR型-T节点左孩子的右孩子(B)>T的兄弟节点->让B代替T成为头部-先左旋再右旋->检查子树改变的节点

     <img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_SB3.png" alt="搜索二叉树_SB3" style="zoom:50%;" />

   - 4.RL型-同理

3. 实现代码

<img src=".\算法与数据结构刷题笔记_图片\搜索二叉树_SB4_代码.png" alt="搜索二叉树_SB4_代码" style="zoom:50%;" />

- 红黑树：红黑树规则

1. 节点为红或黑
2. 头节点和叶节点(红黑树中-底层的空节点，二叉树的叶节点是指没有左右孩子的节点)
3. 任何红节点不相邻
4. **当前节点cur到每一个叶节点(底层的空节点)的路径中黑色节点数量一样
   - 可以保证最长的路和最短的路相差距离不会超过两倍

### 跳表

- 跳表：二分法的思想-时间复杂度O(logN)
- 初始化

1. 默认节点有最小的key
   - 只有默认节点可以增加层数(默认节点永远跟随所有节点roll出来的最大值)-其他节点初始化结束层数就不再改变
2. 初始化一个节点时-投骰子-为1就添加一个新的指针-为0就结束

<img src=".\算法与数据结构刷题笔记_图片\调表1.png" alt="调表1" style="zoom:50%;" />

3. 一个简单的例子

<img src=".\算法与数据结构刷题笔记_图片\调表2.png" alt="调表2" style="zoom:67%;" />

- 增删改查

1. 增-插入节点
   - 从最高层开始-找到小于待插入节点的最右节点
   - 当前层数小于待插入节点的层数->下一层->找到小于待插入节点的最右节点
   - 到达剩余层数相同的节点位置->插入节点
2. 查-与插入时的定位方法相同
3. 删-找到待删除节点以后->删除该节点-连接前后节点

- 复杂度估计->节点的层数取决于投骰子-每一层出现的概率是一个等比数列

<img src=".\算法与数据结构刷题笔记_图片\调表3.png" alt="调表3" style="zoom:50%;" />

- **未完成内容-搜索二叉树的3种实现-AVL树的实现-SB树-红黑树**

# 三、中级班

## 打表法

### 题目1

- 题目

<img src=".\算法与数据结构刷题笔记_图片\打表法题目1_0.png" alt="打表法题目1_0" style="zoom:50%;" />

- 解题思路

1. 贪心策略
   - 尽可能用8个的袋子装-装不下的再考虑用6个的袋子
   - 结束时机->当剩余数量>=最小公倍数的时候且无法解决就停止--同样都是24个肯定优先用8个的袋子装
2. 打表法--结果

- 实现代码

```java
// 贪心
public class Problem02_AppleMinBags {
public static int minBags(int apple) {
    if (apple < 0) {
    	return -1;
    }
    int bag6 = -1;
    int bag8 = apple / 8;
    int rest = apple - 8 * bag8;
    while (bag8 >= && rest < 24) {
    	int restUse6 = minBagBase6(rest);
        if (restUse6 != -1) {
        	bag6 = restUse6;
        	break;
        }
    	rest = apple - 8 * (--bag8);
    }
    return bag6 == -1 ? -1 : bag6 + bag8;
}
// 如果剩余苹果rest可以被装6个苹果的袋子搞定，返回袋子数量
// 不能搞定返回-1
    public static int minBagBase6(int rest) {
    	return rest % 6 == ? (rest / 6) : -1;
    }
```

```java
// 打表法
public static int minBagAwesome(int apple) {
	if ((apple & 1) = 0){ // 如果是奇数，返回-1
		return -1;
    }
	if (apple < 18) {
		return apple == 0 ? 0 : (apple == 6 || apple == 8) ? 1
			: (apple == 12 || apple == 14 || apple == 16) ? 2 : -1;
    }
	return (apple - 18) / 8 + 3;
}
```

### 两只羊吃草

- 题目：两只羊吃草-每次只能吃4^n，谁最后吃完谁赢-输入N返回谁赢(两只羊都绝顶聪明)
- 解题思路：先手的羊尝试所有可能->有一次能赢就赢了--所有尝试结果都没有赢-后手胜利
- 实现代码

```java
// 尝试方法 -- 贪心尝试
public static String winner1(int n) {
//0  1  2  3  4
//后 先  后  先  先
    if (n<5) {
        return (n ==0 || n == 2) ? "后手": "先手";
    }
	// n>= 5时
	int base = 1; // 先手决定吃的草	
	// 有问题
    while (base <= n) {
    // 当前一共n份草，先手吃掉的是base份，n - base 是留给后手的草
    // 母过程 先手 在子过程里是 后手
        if (winner1(n - base).equals("后手")) {
            return "先手";//子过程的后手赢-对应父过程的先手赢
        }
        if (base>n / 4){ // 防止base*4之后溢出
            break;
        }
        base *= 4;
    }
    return"后手";
}
```

```java
// 打表
public static String winner2(int n) {
    if (n % 5 == 0 || n % 5 == 2) {
    	return"后手";
	} else {
		return"先手";
    }
}
```

## 前缀树

### 题目1

- 题目

<img src=".\算法与数据结构刷题笔记_图片\中级班_前缀树1_0.png" alt="中级班_前缀树1_0" style="zoom:50%;" />

- 解题思路：前缀树+深度优先遍历

<img src=".\算法与数据结构刷题笔记_图片\中级班_前缀树1_1.png" alt="中级班_前缀树1_1" style="zoom: 50%;" />

- 实现代码

```java
// 左神 -- 生成前缀树
public static Node generateFolderTree(String[] folderPaths) {
	Node head = new Node(""); // 系统根目录，前缀树头节点
	for(String foldPath: folderPaths) { // 拿出每一个绝对路径
		String[] paths = foldPath.split("\\\\"); // java 特性，用一个"”做分割的意思
		Node cur = head;
		for (int i = 0; i < paths.length; i++) {
			if (!cur.nextMap.containsKey(paths[i])) {
				cur.nextMap.put(paths[i], new Node(paths[i]));
            }
			cur = cur.nextMap.get(paths[i]);
        }
    }
	return head;
}
```

```java
// 左神 -- 图的深度优先遍历
// head节点，当前在level层
public static void printProcess(Node node, int level) {
if (level != 0) {
	// 2* (level - 1)
	System.out.printin(get2nSpace(level) + node.name);
		for (Node next : node.nextMap.values()) {
			printProcess(next, level + 1);
        }
}
```



## 二分法

- 二分法模板

```java
// target在数组分布范围内时，arr[0] <= target <= arr[arr.length-1]
int[] arr = new int[]{0,1,4,4,5,8,10,22,50,50,50,100,110};
int l = 0, r = arr.length, pos = 0;
int tar = 50;
while (l <= r) {
    int mid = (l+r) >> 1;
    if (arr[mid] > tar) {
        r = mid - 1;
    } else {
        pos = mid; // pos是 <= target 的最后一个
        l = mid + 1;
    }
}
//
int l = 0, r = arr.length, pos = 0;
int tar = 50;
while (l <= r) {
    int mid = (l+r) >> 1;
    if (arr[mid] >= tar) {
        r = mid - 1;
    } else {
        pos = mid; // pos是 < target 的最后一个
        l = mid + 1;
    }
}
```

### [leetcode_69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```java
// 二分法
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x, ans = 0;
        while (l <= r) {
            int mid = (r-l)/2+l;
            if ((long) mid*mid > (long) x) {
                r = mid - 1;
            } else {
                ans = mid;
                l = mid + 1;
            }
        }
        return ans;
    }
}
```

### [leetcode_35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```java
// 二分法
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        int mid;
        while (left <= right){
            mid = (left + right)/2;
            if (nums[mid] >= target){
                right = mid - 1;
            } else{
                left = mid + 1;
            }
        }
        return left;
    }
}
```

### [leetcode_34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

- 题目思路

nums有序，有重复，target不一定在数组中

- 二分法模板题

```java
// 模板解法
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0 || nums[0] > target || nums[nums.length - 1] < target) {
            return new int[] {-1,-1};
        }
        int[] ans = new int[2];
        ans[0] = getFirst(nums, target);
        ans[1] = getLast(nums, target);
        return ans;
    }
    public int getFirst(int[] nums, int target) {
        int l = 0, r = nums.length-1;
        while (l <= r) {
            int mid = l + (r-l)/2;
            if (nums[mid] >= target) {
                r = mid-1;
            } else {
                l = mid+1;
            }
        }
        return nums[l] == target? l:-1;
    }
    public int getLast(int[] nums, int target) {
        int l = 0, r = nums.length-1;
        while (l <= r) {
            int mid = l + (r-l)/2;
            if (nums[mid] > target) {
                r = mid-1;
            } else {
                l = mid+1;
            }
        }
        return nums[l-1] == target? l-1:-1;
    }
}
```

```java
// 二分模板 -- 找到target最左位置
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0 || nums[0] > target || nums[nums.length - 1] < target) {
            return new int[] {-1,-1};
        }
        int[] ans = new int[2];
        ans[0] = getFirst(nums, target);
        if (ans[0] != -1) {
            int idx = ans[0];
            while (idx < nums.length && nums[idx] == target) {
                idx++;
            }
            ans[1] = idx-1;
        } else {
            ans[1] = -1;
        }
        return ans;
    }
    public int getFirst(int[] nums, int target) {
        int l = 0, r = nums.length-1;
        while (l <= r) {
            int mid = l + (r-l)/2;
            if (nums[mid] >= target) {
                r = mid-1;
            } else {
                l = mid+1;
            }
        }
        return nums[l] == target? l:-1;
    }
}
```



## 滑动窗口

- 滑动窗口问题注意题目需要的答案是最值，所有情况的数组，还是所有情况的数量->分别可以有不同的优化

### 绳子最多覆盖的点

- 题目

```java
给定一个有序数组arr，代表数轴上从左到右有n个点arr[0]、arr[1]...arr[n-1]，给定一个正数L，代表一根长度为L的绳子，求绳子最多能覆盖其中的几个点。
```

- 解题思路

1. 滑动窗口+贪心策略
   - 遍历窗口右端覆盖其中一个节点的所有情况
2. 双指针+贪心
   - 两个指针一个节点一个节点的移动->单调移动不回退

- 实现代码

```java
// 滑动窗口
public class Problem01_CordCoverMaxPoint {
    // 长度为L的绳子最多覆盖几个点，请保证arr有序
    public static int maxPoint(int[] arr, int L) {
        int res = 1;
        for (int i = 0; i < arr.length; i++) {
            int nearest = nearestIndex(arr, i, arr[i] - L);
            res = Math.max(res, i - nearest + 1);
        }
        return res;
    }
// 在arr[0..R]范围上，找满足>=value的最左位置
    public static int nearestIndex(int[] arr, int R, int value) {
        int L = 0;
        int index = R;
        while (L <= R) {
            int mid = L + ((R - L) >>1);
            if (arr[mid] >= value) {
                index = mid;
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        return index;
    }
}
```

### [leetcode_396. 旋转函数](https://leetcode.cn/problems/rotate-function/)

```java
// 前缀和+滑动窗口 -- 时间复杂度 O(n) 空间复杂度O(n)
class Solution {
    public int maxRotateFunction(int[] nums) {
        int len = nums.length;
        int sum = 0;
        int[] pre = new int[len];
        for (int num:nums) sum+=num;
        int ans = 0, cur = 0;
        for (int i=0; i < len; i++) {
            cur += i*nums[i];
            pre[i] = sum - nums[i];
        }
        ans = cur;
        for (int i=0; i<len;i++) {
            cur -= pre[i];
            cur += nums[i]*(len-1);
            if (cur > ans) ans=cur;
        }
        return ans;
    }
}
```

```java
// 使用sum优化掉前缀和
class Solution {
    public int maxRotateFunction(int[] nums) {
        int len = nums.length;
        int sum = 0;
        int ans = 0, cur = 0;
        for (int i=0; i < len; i++) {
            cur += i*nums[i];
            sum += nums[i];
        }
        ans = cur;
        for (int i=0; i<len;i++) {
            cur += nums[i]*(len);
            cur -= sum;
            if (cur > ans) ans=cur;
        }
        return ans;
    }
}
```

### [leetcode_1984. 学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

```java
// 滑动窗口找最大值
class Solution {
    public int minimumDifference(int[] nums, int k) {
        if (k == 1) { return 0; }
        Arrays.sort(nums);
        int ans = Integer.MAX_VALUE, cur = 0;
        for (int i=0; i <= nums.length-k; i++) {
            cur = nums[i+k-1] - nums[i];
            if (ans > cur) ans = cur;
        }
        return ans;
    }
}
```

### [leetcode_424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

```java
// 滑动窗口选择符合条件的最大值
// 选择条件：窗口内所有字母 - 数量最多的字母 <= k
class Solution {
    public int characterReplacement(String s, int k) {
        char[] arr = s.toCharArray();
        int ans = 0;
        int[] cnt = new int[26];
        for (int l=0, r= 0; r < arr.length; r++) {
            cnt[arr[r]-'A']++;
            while (!check(cnt, k)) {
                cnt[arr[l]-'A']--;
                l++;
            }
            if (ans < r-l+1) {
                ans = r-l+1;
            }
        }
        return ans;
    }
    public boolean check(int[] cnt, int k) {
        int sum = 0, max = 0;
        for (int c:cnt) {
            sum += c;
            if (max < c) max = c;
        }
        return sum - max <= k;
    }
}
```

```java
// 常数优化 cntMax一直统计出现最多的字符
class Solution {
    public int characterReplacement(String s, int k) {
        char[] arr = s.toCharArray();
        int ans = 0, cntMax=0;
        int[] cnt = new int[26];
        for (int l=0, r= 0; r < arr.length; r++) {
            cnt[arr[r]-'A']++;
            cntMax = Math.max(cntMax, cnt[arr[r]-'A']);
            while (r-l+1-cntMax > k) {
                cnt[arr[l]-'A']--;
                l++;
            }
            if (ans < r-l+1) {
                ans = r-l+1;
            }
        }
        return ans;
    }
}
```

### [leetcode_992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

- 解题思路

1. 找到其左边「最远」满足出现 k 个不同字符的下标，记为 p。这时候形成的区间为 [p, i]
2. 找到其左边「最远」满足出现 k - 1 个不同字符的下标，记为 j。这时候形成的区间为 [j, i]
3. 那么对于 j - p 其实就是代表以 nums[i] 为右边界（必须包含 num[i]），不同字符数量「恰好」为 k 的子数组数量

```java
class Solution {
    public int subarraysWithKDistinct(int[] nums, int k) {
        int len = nums.length;
        int[] lower = new int[len], upper = new int[len];
        find(lower, nums, k);
        find(upper, nums, k - 1);
        int ans = 0;
        for (int i = 0; i < len; i++) ans += upper[i] - lower[i];
        return ans;
    }
    public void find(int[] arr, int[] nums, int k) {
        int len = nums.length;
        int[] cnt = new int[len+1];
        int sum = 0;
        for (int r=0, l=0; r < len; r++) {
            int right = nums[r];
            if (cnt[right] == 0) sum++;
            cnt[right]++;
            while (sum > k) {
                int left = nums[l];
                cnt[left]--;
                if (cnt[left] <= 0) sum--;
                l++;
            }
            arr[r] = l;
        }
    }
}
```

```java
// 空间复杂度优化 -- 只用常数几个变量
class Solution {
    public int subarraysWithKDistinct(int[] nums, int k) {
        int len = nums.length;
        return find(nums, k-1) - find(nums, k);
    }
    public int find(int[] nums, int k) {
        int len = nums.length;
        int[] cnt = new int[len+1];
        int sum = 0, all = 0;;
        for (int r=0, l=0; r < len; r++) {
            int right = nums[r];
            if (cnt[right] == 0) sum++;
            cnt[right]++;
            while (sum > k) {
                int left = nums[l];
                cnt[left]--;
                if (cnt[left] <= 0) sum--;
                l++;
            }
            all += l;
        }
        return all;
    }
}
```

### [leetcode_438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

- 解题思路

1. cnt数组记录p数组字母出现的次数
2. a记录不同字母的个数
3. b记录窗口内字符与p出现频率一样的字符

```java
// 一个额外数组
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        char[] arrS = s.toCharArray();
        char[] arrP = p.toCharArray();
        int sLen = arrS.length;
        int pLen = arrP.length;
        List<Integer> ans = new ArrayList<>();
        if (sLen < pLen) return ans;
        int[] cntNum = new int[26];
        int a = 0, b = 0;
        for (char c: arrP) {
            cntNum[c - 'a']++;
            if (cntNum[c - 'a'] == 1) a++;
        }
        for (int r=0, l = 0; r < sLen; r++) {
            cntNum[arrS[r]-'a']--;
            if (cntNum[arrS[r]-'a'] == 0) b++;
            if (r-l+1 > pLen) {
                cntNum[arrS[l]-'a']++;
                if (cntNum[arrS[l]-'a'] == 1) b--;
                l++;
            }
            if (a==b) ans.add(l);
        }
        return ans;
    }
}
```

### [leetcode_1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

- 解题思路

1. 转化为固定范围内的滑动窗口

```java
// 形参窗口在计算
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int len = cardPoints.length;
        int sum = 0;
        for (int num:cardPoints) sum += num;
        int cur = 0, min = Integer.MAX_VALUE;
        for (int r=0, l = 0; r<len; r++) {
            cur += cardPoints[r];
            if (r - l + 1 > len - k){
                cur -= cardPoints[l++];
            }
            if (r - l + 1 == len - k) {
                min = Math.min(min, cur);
            }
        }
        return sum - min;
    }
}
```

```java
// 先构成窗口在计算
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int len = cardPoints.length;
        int sum = 0;
        int min = 0, cur = 0;
        for (int num:cardPoints) sum += num;
        for (int i=0; i < len-k; i++) {
            cur += cardPoints[i];
        }
        min = cur;
        for (int r=len-k, l = 0; r<len; r++, l++) {
            cur += cardPoints[r];
            cur -= cardPoints[r-len+k];
            min = Math.min(min, cur);
        }
        return sum - min;
    }
}
```

### [leetcode_2024. 考试的最大困扰度](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/)

```java
// 滑动窗口
class Solution {
    public int maxConsecutiveAnswers(String answerKey, int k) {
        int max = 0, min = Integer.MAX_VALUE;
        char[] arr = answerKey.toCharArray();
        int tCnt = 0, fCnt = 0;
        for (int r=0, l=0; r < arr.length; r++) {
            if (arr[r] == 'T') tCnt++;
            else fCnt++;
            min = Math.min(fCnt, tCnt);
            while (min > k) {
                if (arr[l] == 'T') tCnt--;
                else fCnt--;
                l++;
                min = Math.min(fCnt, tCnt);
            }
            max = Math.max(max, fCnt+tCnt);
        }
        return max;
    }
}
```

### [leetcode_713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

```java
// 滑动窗口
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k <= 1) return 0;
        int ans = 0, cur = 1;
        for (int r=0, l=0; r<nums.length; r++) {
            cur *= nums[r];
            while (cur >= k) cur /= nums[l++];
            ans += r-l+1;
        }
        return ans;
    }
}
```

### [leetcode_42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

- 解题思路

1. 最好不要用找局部波谷的方法
2. 把问题分解为找自己位置头上能装多少水的问题
   - 找到左右最大值小的一个
3. 此时依赖左右的最大值
   - 优化空间复杂度为O(1)
   - LR两个指针向中间结算--同时记录左边最大的和右边最大的值--先结算leftMax和rightMax小的一边--结果受小的一边影响

<img src=".\算法与数据结构刷题笔记_图片\接雨水.png" alt="接雨水" style="zoom:50%;" />

```java
// 由小的一边结算当前位置
class Solution {
    public int trap(int[] height) {
        if (height.length <= 1) return 0;
        int l = 0, r = height.length-1;
        int leftMax = height[0], rightMax = height[height.length-1];
        int ans = 0;
        while (l < r) {
            if (leftMax < rightMax) {
                ans += leftMax - height[l++];
                leftMax = Math.max(leftMax, height[l]);
            } else {
                ans += rightMax - height[r--];
                rightMax = Math.max(rightMax, height[r]);
            }
        }
        return ans;
    }
}
```

## 预处理数组技巧

- 预处理数组技巧-用空间换时间-把有效信息存起来

#### 字符变换问题

- 解题思路

1. 朴素思想：从左侧没有G->到右侧没有R所有情况中改变次数最少的就是答案-->单指针-左边的全部变G右边全部变R
   - 时间复杂度O(n^2)
2. 优化->遍历一次就拿到指针左右G和R的分布情况-辅助数组a[]统计0-i范围上R的数量-辅助数组b[]统计0-i范围上G的数量--空间换时间

#### [leetcode_1139. 最大的以 1 为边界的正方形](https://leetcode.cn/problems/largest-1-bordered-square/)

```java
// 朴素思路 -- if - else 判断
class Solution {
    public int largest1BorderedSquare(int[][] grid) {
        int r = grid.length, c = grid[0].length;
        if (r == 1 && c == 1) {
            return grid[r-1][c-1];
        }
        int[][] right = new int[r][c];
        int[][] down = new int[r][c];
        int ans = 0;
        for (int i=r-1; i>=0; i--) {
            for (int j=c-1; j>=0; j--){
                if (grid[i][j] == 1){
                    if (i==r-1 && j==c-1) {
                        right[i][j] = grid[i][j];
                        down[i][j] = grid[i][j];
                    } else if (i==r-1) {
                        right[i][j] = right[i][j+1] + 1;
                        down[i][j] = grid[i][j];
                    } else if (j==c-1) {
                        right[i][j] = grid[i][j];
                        down[i][j] = down[i+1][j] + 1; 
                    } else{
                        right[i][j] = 1 + right[i][j+1];
                        down[i][j] = 1 + down[i+1][j];
                    }
                }
                int border = Math.min(right[i][j], down[i][j]);
                while (border > 0 && (right[i+border-1][j] < border || down[i][j+border-1] < border)) {
                    border--;
                }
                ans = Math.max(ans, border);
            }
        }
        return ans*ans;
    }
}
```

```java
// 多给一行一列作为dp的边界 -- 常用的规避边界判断的方法
class Solution {
    public int largest1BorderedSquare(int[][] grid) {
        int r = grid.length, c = grid[0].length;
        if (r == 1 && c == 1) {
            return grid[r-1][c-1];
        }
        int[][] right = new int[r+1][c+1];
        int[][] down = new int[r+1][c+1];
        int ans = 0;
        for (int i=r-1; i>=0; i--) {
            for (int j=c-1; j>=0; j--){
                if (grid[i][j] == 1){
                    right[i][j] = 1 + right[i][j+1];
                    down[i][j] = 1 + down[i+1][j];
                }
                int border = Math.min(right[i][j], down[i][j]);
                while (border > 0 && (right[i+border-1][j] < border || down[i][j+border-1] < border)) {
                    border--;
                }
                ans = Math.max(ans, border);
            }
        }
        return ans*ans;
    }
}
```

#### [leetcode_470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/)

```java
class Solution extends SolBase {
    public int rand10() {
        int r = rand7();
        int c = rand7();
        int idx = r + (c-1)*7;
        while (idx > 40) {
            r = rand7();
            c = rand7(); 
            idx = r + (c-1)*7;
        }
        return 1 + (idx-1) % 10;
    }
}
```



- 相关拓展

![rand7](.\算法与数据结构刷题笔记_图片\rand7.png)

- 解题思路

1. 题目1
   - 二进制拼接->先把随机生成的方法转化为生成随机二进制数--运行7对应的二进制位即可
   - 进制转化法->把4(0-4->1-5)进制转化为6进制(0-5->1-6)
   - 这种思想是错的->随机两次--出现和为0-出现和为3的概率是不一样的-->但是把数转换为10进制所有数出现的概率是相同的
2. 题目2
   - 思路和上面类似
3. 题目3
   - 运行f函数两次->00，11重来->01和10的概率相同

## 动态规划

#### [leetcode_96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

- 解题思路

1. 尝试左树为i个节点-右树为n-1-i个节点的所有情况
2. basecase-n=0，1，2

```java
// 改动态规划
class Solution {
    public int numTrees(int n) {
        if (n == 1) return 1;
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for (int r = 2; r <= n; r++) {
            int cur = 0;
            for (int i=0; i<r;i++) {
                cur += dp[i] * dp[r-i-1];
            }
            dp[r] = cur;
        }
        return dp[n];
    }
}
```

#### 空间压缩技巧

- 把原本依赖位置的二维dp数组优化为一位的dp数组

1. 优化额外空间复杂度
2. 按原本二维dp数组短的一边更新
3. 位置依赖比较较近时都可以优化

#### 严格递推公式的题目

- 严格递推公式的题目：O(logN)优化--除了第一项外-每一项都有递推公式---矩阵快速幂

##### [leetcode_509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

- 矩阵快速幂解法

<img src=".\算法与数据结构刷题笔记_图片\斐波那契数列_快速幂.png" alt="斐波那契数列_快速幂" style="zoom: 33%;" />

- 实现代码

```java
public static int fi(int n) {
    if (n<1) {
    	return 0;
    }
    if (n==1 || n== 2) {
    	return 1;
    }
    int[][] base ={{ 1, 1 },
    				{1, 0}};
    int[][] res = matrixPower(base, n-2);
    return res[0][0] + res[1][0];
}
public static int[][] matrixPower(int[][] m, int p) {
    int[][] res = new int[m.length][m[0].length];
    for (int i = 0; i < res.length; i++) {
    	res[i][i] = 1;
    }
    int[][] tmp = m;
    for (;p != 0; p>>= 1) {
    	if ((p & 1) != 0) {
            res = muliMatrix(res, tmp);
        }
    	tmp = muliMatrix(tmp, tmp);
    }
    return res;
}
public static int[][] muliMatrix(int[][] m1, int[][] m2) {
    int[][] res = new int[m1.length][m2[0].length];
	for (int i=0; i < m1.length; i++) {
		for (int j = 0; j< m2[0].length; j++) {
			for (int k = 0; k < m2.length; k++) {
				res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
	return res;
}
```

- 左神讲解

1. 快速幂

![快速幂1](.\算法与数据结构刷题笔记_图片\快速幂1.png)

2. 矩阵快速幂

系数是单位矩阵--推广到矩阵

<img src=".\算法与数据结构刷题笔记_图片\矩阵快速幂1.png" alt="矩阵快速幂1" style="zoom: 33%;" />

几阶的式子：矩阵就是n-几次方

<img src=".\算法与数据结构刷题笔记_图片\矩阵快速幂2.png" alt="矩阵快速幂2" style="zoom: 33%;" />

##### 题目：斐波那契数列

- 题目

![斐波那契数列1](.\算法与数据结构刷题笔记_图片\斐波那契数列1.png)

![斐波那契数列2](.\算法与数据结构刷题笔记_图片\斐波那契数列2.png)

- 解题思路--暴力解法--打表->发现是斐波那契数列
  - 暴力递归--F(i)->前面为1后面为F(i-1)

<img src=".\算法与数据结构刷题笔记_图片\斐波那契数列3.png" alt="斐波那契数列3" style="zoom: 50%;" />

## 背包问题

### 牛客网_牛牛的背包问题

- 解题思路：转移方程

1. 我使用i位置的数
2. 我不使用i位置的数
3. dp [ i ] [ j ]表示：i个物体容量为j的方法数量

<img src=".\算法与数据结构刷题笔记_图片\牛客网_牛牛的背包问题.png" alt="牛客网_牛牛的背包问题" style="zoom:50%;" />

### [牛牛找工作_牛客网](https://www.nowcoder.com/questionTerminal/46e837a4ea9144f5ad2021658cb54c4d)

- 题目

<img src=".\算法与数据结构刷题笔记_图片\牛牛找工作.png" alt="牛牛找工作" style="zoom: 67%;" />

- 解题思路

1. 背包问题的解决方法
2. 有序表：将难度从小到大排序--难道相同将报酬从大到小排序--只保留报酬高的工作--找自己能力范围内工资最高的工作就行

- 实现代码

```java
public static int[] getMoneys(Job[] job, int[] ability) {
    Arrays.sort(job, new JobComparator());
    // 难度为key的工作，最优钱数是多少，有序表
    TreeMap<Integer，Integer> map = new TreeMap<>();
    map.put(job[0].hard, job[0].money);
    Job pre = job[0]; // pre 之前组的组长
    for (int i = 1; i < job.length; i++) {
    	if (job[i].hard != pre.hard && job[i].money > pre.money) {
            pre = job[i];
            map.put(pre.hard, pre.money);
		}
    }
    int[] ans = new int[ability.length];
    for (int i = 0; i < ability.length; i++) {
        Integer key = map.floorKey(ability[i]);
        ans[i] = key != null ? map.get(key) : 0;
    }
    return ans;
}
```

### 01背包问题

- 解题思路

1. 所有位置的物品考虑选和不选两种情况
2. basecase--遍历完所有位置

#### leetcode_416. 分割等和子集

​	背包问题转化--拿几个数能实现总和的一半

#### leetcode_494. 目标和--衍生变体问题1049

#### leetcode_879. 盈利计划--三维dp

#### leetcode_1049. 最后一块石头的重量 II

### 完全背包问题

#### leetcode_322. 零钱兑换

#### 中级提升班_9_10:30_CC主播问题

- 解题思路

1. 递归方法--递归方法无法完成--递归内部有循环--且缺少让递归停止的basecase
2. **引入平凡解作为base判断--增加限制条件(如只+2的情况--人气值的变化范围不超过end的两倍)

<img src=".\算法与数据结构刷题笔记_图片\CC主播问题_思路.png" alt="CC主播问题_思路" style="zoom:50%;" />

#### 区间DP

##### [leetcode_877. 石子游戏](https://leetcode.cn/problems/stone-game/)

- 思路：与lc486一致

```java
// 暴力递归--超时
class Solution {
    public boolean stoneGame(int[] piles) {
        return dfs(0, piles.length-1, piles) >= 0;
    }
    public int dfs(int l, int r, int[] piles) {
        if (l == r) {
            return piles[l];
        }
        int first = piles[l] - dfs(l+1, r, piles);
        int last = piles[r] - dfs(l, r-1, piles);
        return Math.max(first, last);
    }
}
```

```java
// 改动态规划
class Solution {
    public boolean stoneGame(int[] piles) {
        int len = piles.length;
        int[][] dp = new int[len][len];
        for (int i=0; i < len; i++) {
            dp[i][i] = piles[i];
        }
        for (int l = len-2; l>=0; l--) {
            for (int r = l+1; r < len; r++) {
                dp[l][r] = Math.max(piles[l] - dp[l+1][r], piles[r] - dp[l][r-1]);
            }
        }
        return dp[0][len-1] > 0;
    }
}
```

```java
// 博弈论
/*
由于石子堆数为偶数，因此先手的最开始局面必然是 [奇数,偶数][奇数, 偶数][奇数,偶数]，即必然是「奇偶性不同的局面」；当先手决策完之后，交到给后手的要么是 [奇数,奇数][奇数,奇数][奇数,奇数] 或者 [偶数,偶数][偶数,偶数][偶数,偶数]，即必然是「奇偶性相同的局面」；后手决策完后，又恢复「奇偶性不同的局面」交回到先手 ...
不难归纳推理，这个边界是可以应用到每一个回合。
因此先手只需要在进行第一次操作前计算原序列中「奇数总和」和「偶数总和」哪个大，然后每一次决策都「限制」对方只能选择「最优奇偶性序列」的对立面即可。
*/
class Solution {
    public boolean stoneGame(int[] piles) {
        return true;
    }
}

```

#### 数位 DP

##### [leetcode_357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/)

```java
// 乘法原理 -- 枚举可能性
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        if (n < 1) return 1;
        int ans = 10, last = 9, cur = 0;
        for (int i = 2; i <= n; i++) {
            cur = last * (10-i+1);
            ans += cur; last = cur;
        }
        return ans;
    }
}
```

## 范围内尝试模型

### [leetcode_1711. 大餐计数](https://leetcode.cn/problems/count-good-meals/)

```java
// 可能的范围内依次尝试 -- hashmap去重
class Solution {
    public int countPairs(int[] deliciousness) {
        int MOD = (int) 1e9 + 7;
        Map<Integer, Integer> map = new HashMap<>();
        int max = 0;
        long ans = 0;
        for (int num: deliciousness) {
            map.put(num, map.getOrDefault(num, 0)+1);
            max = Math.max(max, num);
        }
        for (int num: map.keySet()) {
            for (int i=1; i <= max*2; i <<= 1) {
                int other = i - num;
                if (map.containsKey(other)) {
                    if (other == num) ans += 1l * map.get(num) * (map.get(num) - 1);
                    else ans += 1l * map.get(num) * map.get(other);
                }
            }
        }
        ans >>= 1;
        return (int) (ans % MOD);
    }
}
```

```java
// 每次添加数的时候再与前面进行尝试
class Solution {
    private static final int MOD = (int) 1e9 + 7;
    public int countPairs(int[] deliciousness) {
        int min = deliciousness[0], max = min;
        for (int deli : deliciousness) {
            if (deli > max) {
                max = deli;
            } else if (deli < min) {
                min = deli;
            }
        }
        long ans = 0;
        int[] hash = new int[max - min + 1];
        for (int deli : deliciousness) {
            for (int k = 1; ; k <<= 1) {
                int t = k - deli;
                if (t < min) {
                    continue;
                }
                if (t > max) {
                    break;
                }
                ans += hash[t - min];
            }
            ++hash[deli - min];
        }
        return (int) (ans % MOD);
    }
}
```

### [leetcode_532. 数组中的 k-diff 数对](https://leetcode.cn/problems/k-diff-pairs-in-an-array/)

```java
//  双指针+排序
class Solution {
    public int findPairs(int[] nums, int k) {
        Arrays.sort(nums);
        int len = nums.length;
        int ans = 0;
        for (int i=0, j=0; i < len; i++) {
            if (i==0 || nums[i] != nums[i-1]) {
                while (j < len && (nums[j] < nums[i] + k || j <= i)) {
                    j++;
                }
                if (j < len && nums[j] == nums[i] + k) {
                    ans++;
                }
            }
        }
        return ans;
    }
}
```

```java
// hashmap
class Solution {
    public int findPairs(int[] nums, int k) {
        Set<Integer> Visited = new HashSet<>();
        Set<Integer> ans = new HashSet<>();
        for (int num: nums) {
            if (Visited.contains(num-k)) {
                ans.add(num-k);
            }
            if (Visited.contains(num+k)) {
                ans.add(num);
            }
            Visited.add(num);
        }
        return ans.size();
    }
}
```



## 字符串/括号

### [牛客网_缺失的括号](https://www.nowcoder.com/questionTerminal/cb9c921685574659937629a4d64b091f)

- 题目

![缺失的括号](.\算法与数据结构刷题笔记_图片\缺失的括号.png)

- 解题思路

1. 怎么判断是否为有效括号
   - count指针遇见左括号++右括号--：为负值是失效
   - 结束时count指针为0
2. ans记录多的右括号，count记录中间过程和最后多的左括号

- 实现代码

```java
import java.util.Scanner;
// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        String s = in.nextLine();
        char[] cs = s.toCharArray();
        int cnt = 0, ans = 0;
        for (int i=0; i < cs.length; i++) {
            if (cs[i] == '(') cnt++;
            else {
                if (cnt <= 0) ans++;
                else cnt--;
            }
        }
        System.out.print(ans + cnt);
    }
}
```

### [牛客网_括号匹配深度](https://www.nowcoder.com/questionTerminal/a2d5b1875bb0408384278f40d1f236c9)

- 题目

![括号匹配深度](.\算法与数据结构刷题笔记_图片\括号匹配深度.png)

- 解题思路：count指针移动，最大值就是最大深度

### [leetcode_20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```java
// 只使用栈
class Solution {
    public boolean isValid(String s) {
        Deque<Character> stack = new ArrayDeque<>();
        for(Character c : s.toCharArray()){
            if (c == '(' || c == '[' || c== '{') {
                stack.push(c);
            } else {
                if(stack.isEmpty()) return false;
                char peek = stack.pop();
                if (c == ')') {
                    if (peek != '(') return false;
                } else if (c == ']') {
                    if (peek != '[') return false;
                } else {
                    if (peek != '{') return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
```

```java
// 辅助栈 + hashmap ---- 代码比较少
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<>();
        map.put('(', ')');
        map.put('[', ']');
        map.put('{', '}');
        map.put('?', '?');
        if (s.length() > 0 && !map.containsKey(s.charAt(0))) return false;
        Deque<Character> stack = new ArrayDeque<>();
        stack.add('?');
        for(Character c : s.toCharArray()){
            if(map.containsKey(c)) stack.push(c);
            else if(map.get(stack.pop()) != c) return false;
        }
        return stack.size() == 1;
    }
}
```



### [leetcode_22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

### [leetcode_32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

- 解题思路：

1. 以某一个位置结尾的尝试：求出每个位置结尾的字串的大小
2. dp[i]-以i位置的元素结尾最大的字串长度多大
3. 遇到左括号-直接为0

![最长有效括号_解题思路](.\算法与数据结构刷题笔记_图片\最长有效括号_解题思路.png)

- 代码

```java
class Solution {
    public int longestValidParentheses(String s) {
        char[] cs = s.toCharArray();
        int len = cs.length;
        if (len <= 1) return 0;
        int[] dp = new int[len];
        int max = -1;
        for (int i=1; i<len; i++) {
            if (cs[i] == ')') {
                int pre = i - dp[i-1] -1;
                if (pre >= 0 && cs[pre] == '(') {
                    dp[i] = dp[i-1] + 2 + (pre > 0 ? dp[pre-1]: 0); // pre位置之前的是否能够加入
                }
            }
            max = Math.max(max, dp[i]);
        }
        return max;
    }
}
```

### [leetcode_678. 有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/)

```java
class Solution {
    public boolean checkValidString(String s) {
        char[] cs = s.toCharArray();
        int len = cs.length;
        if (len == 1) return cs[0] == '*';
        int leftMin = 0, leftMax = 0;
        for (int i=0; i < len; i++) {
            if (cs[i] == '(') {
                leftMin++;
                leftMax++;
            } else if (cs[i] == ')') {
                leftMin = Math.max(leftMin-1, 0);
                leftMax--;
            } else {
                leftMin = Math.max(leftMin-1, 0);
                leftMax++;
            }
            if (leftMax < 0) return false;
        }
        return leftMin == 0;
    }
}
```

### [leetcode_301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)

```java
// 回溯 + 剪枝
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> removeInvalidParentheses(String s) {
        int left = 0, right = 0;
        for (char c: s.toCharArray()) {
            if (c == '(') {
                left++;
            } else if (c == ')'){
                if (left == 0) right++;
                else left--;
            } 
        }
        dfs(s, 0, left, right);
        return ans;
    }
    public void dfs(String str, int cur, int left, int right) {
        if (left == 0 && right == 0) {
            if (isValue(str)) {
                ans.add(str);
            }
            return;
        }
        for (int i= cur; i < str.length(); i++) {
            if (i != cur && str.charAt(i) == str.charAt(i-1)) {
                continue;
            }
            if (left + right > str.length() - i) {
                return;
            }
            if (left > 0 && str.charAt(i) == '(') {
                dfs(str.substring(0, i) + str.substring(i+1), i, left-1, right);
            }
            if (right > 0 && str.charAt(i) == ')') {
                dfs(str.substring(0, i) + str.substring(i+1), i, left, right-1);
            }
        }
    }
    public boolean isValue(String s) {
        int cnt = 0;
        for (char c: s.toCharArray()) {
            if (c == '(') {
                cnt++;
            } else if (c == ')') {
                cnt--;
                if (cnt < 0) return false;
            } 
        }
        return cnt == 0;
    }
}
```

### [牛客网_数字字符转化为字母组合的种数](https://www.nowcoder.com/questionTerminal/6a5d7615332c49eb810c374dd6f37857?f=discussion)

- 解题思路：动态规划

1. i位置的字符能不能自己组成字符-和下一个位置组成字符
2. 递归返回i位置往后能组成字母的情况总数

- 实现代码

```java
// 左神--暴力递归
public static int process(char[] str, int index) {
	if (index == str.length) {
    	return 1;
    }
// index及其后续是还有数字字符的
// 0..
    if(str[index] == '0') { // 开头为
    	return 0;
    }
// index及其后续是还有数字字符的，且不以0开头，以1~9开头
	int res = process(str, index + 1);// 做了一个决定，就让str[index]自己作为一个部
    if (index == str.length - 1) { // 除了index之外，后续没有字符串了
    	return res;
    }
// index+1依然没越界
// index和index+1 共同构成一个部分 <27
    if (((str[index] - '0') * 10 + str[index + 1] - '0') < 27){
    	res += process(str, index + 2);
    }
    return res;
}
```

```java
// 动态规划
public static int dpways(int num) {
    if (num < 1) {
        return 0;
    }
	char[] str = String.valueOf(num).toCharArray();
	int N = str.length;
	int[] dp = new int[N + 1];
    dp[N] =1;
    dp[N - 1] = str[N -1] == '0' ? 0 : 1;
    for (int i= N -2;i >= 0; i--) {
        if (str[i] =='0') {
        	dp[i] = 0;
        } else {
    		dp[i] = dp[i + 1]
    				+ (((str[i]- '0') * 10 + str[i + 1] - '0') < 27 ? dp[i + 2] : 0);
        }
    }
	return dp[0];
}
```

### [leetcode_316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

```java
//单调栈
class Solution {
    public String removeDuplicateLetters(String s) {
        int[] arr = new int[26];
        boolean[] contains = new boolean[26];
        char[] chars = s.toCharArray();
        for (char c: chars) {
            arr[c-'a']++;
        }
        StringBuilder sb = new StringBuilder();
        for (char ch: chars) {
            if (!contains[ch - 'a']) {
                while (sb.length() > 0 && sb.charAt(sb.length()-1) > ch) {
                    if (arr[sb.charAt(sb.length()-1) - 'a'] > 0) {
                        contains[sb.charAt(sb.length()-1) - 'a'] = false;
                        sb.deleteCharAt(sb.length()-1);
                    } else {
                        break;
                    }
                }
                contains[ch-'a'] = true;
                sb.append(ch);
            }
            arr[ch-'a']--;
        }
        return sb.toString();
    }
}
```



## 排序/查找

#### 栈排序

- 题目

![栈排序](.\算法与数据结构刷题笔记_图片\栈排序.png)

- 解题思路

1. 辅助栈永远保持上小下大的顺序
2. 遇到大于的辅助栈顶的数，全部弹回原栈，把该数放到最下面

- 代码

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
    s=[]
    while nums:
    	cur = nums.pop()
    	if not s or cur <= s[-1]:
    		s.append(cur)
    	else:
            while s and s[-1] < cur:
            	nums.append(s.pop())
            s.append(cur)
    return s[::-1]
```

#### leetcode_240. 搜索二维矩阵 II

```java
// z字查找 -- 从右到左 从上到下
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int r = matrix.length, c = matrix[0].length;
        if (r < 1 || c < 1) { return false;}
        int cr = 0, cc = c-1;
        while (cr < r && cc >=0) {
            if (matrix[cr][cc] == target) {
                return true;
            } else {
                if (matrix[cr][cc] > target) cc--;
                else cr++;
            }
        }
        return false;
    }
}
```



## 二叉树递归

### 最大权值和

- 题目

```java
// 二叉树每个结点都有一个int型权值，给定一棵二叉树，要求计算出从根结点到
// 叶结点的所有路径中，权值和最大的值为多少。
```

- 解题思路

1. 注意：路径的定义-每道题的路径定义不太一样-本题目-根节点到叶节点
2. 二叉树递归的方法

- 实现代码

```java
public static void p(Node x,int pre) {
	if(x.left == null 8& x.right == null){// 当前的x是叶节点
		maxSum = Math.max(maxSum, pre + x.value);
    }
	if(x.left !=null) {
		p(x.left, pre + x.value);
    }
	if(x,right!=nul1) {
		p(x.right, pre +x.value);
    }
}
public static int process2(Node x) {
	if(x.left == null && x.right == null) (
		return x.value;
        }
	int next = Integer.MIN_VALUE;
	if(x.left != null) {
		next = process2(x.left);
    }
	if(x.right != null) {
		next = Math.max(next, process2(x.right));
    }
	return x.value + next;
}
```

### leetcode_426. 将二叉搜索树转化为排序的双向链表

- 双向链表节点结构和二叉树节点结构是一样的，如果你把last认为是left，next认为是next的话。
  给定一个搜索二叉树的头节点head，请转化成一条有序的双向链表，并返回链表的头节点。
- 解题思路

1. 中序递归遍历
2. 递归-输入某节点-输出以该节点为根转化为双向有序表的
3. basecase：节点为None

- 实现代码

```java
// LCR 155. 将二叉搜索树转化为排序的双向链表
// 二叉树递归拿信息 -- 注意编程思路
class Solution {
    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        Node[] info = dfs(root);
        info[0].left = info[1];
        info[1].right = info[0];
        return info[0];
    
    }
    public Node[] dfs(Node root) {
        if (root == null) return new Node[]{null, null};
        Node[] leftInfo = dfs(root.left);
        Node[] rightInfo = dfs(root.right);
        if (leftInfo[1] != null) {
            leftInfo[1].right = root;
        }
        root.left = leftInfo[1];
        root.right = rightInfo[0];
        if (rightInfo[0] != null) {
            rightInfo[0].left = root;
        }
        return new Node[]{leftInfo[0] != null ? leftInfo[0]: root, rightInfo[1] != null ? rightInfo[1]: root};
    }
}
```

```java
// 双指针优化 -- 中序遍历
class Solution {
    Node tail, head;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        dfs(root);
        head.left = tail;
        tail.right = head;
        return head;
    }
    public void dfs(Node root) {
        if (root == null) return;
        dfs(root.left);
        if (tail != null) tail.right = root;
        else head = root;
        root.left = tail;
        tail = root;
        dfs(root.right);
    }
}
```



### leetcode_333. 最大 BST 子树(会员题目)

- 题目：找到一棵二叉树中，最大的搜索二叉子树，返回最大搜索二叉子树的节点个数。
- 变体：返回最大搜索二叉子树的节点
- 解题思路
  - 子树--是以某个根节点出发的整个树
  - 1.跟根节点x无关--左树是不是--右树是不是
  - 2.跟根节点x有关--整棵二叉树是不是搜索二叉树
    - 判断条件--左右树均为搜索二叉树--左边最大小于x-右边最小大于x
- 实现代码

1. 二叉树递归套路--输入根节点--返回左右树是否搜索二叉树-左右树的最大最小值-搜索二叉树的大小
2. basecase--结点为空

```java
// 左神代码
public static class Info {
    public Node maxBSTHead;
    public boolean isBST;
    public int min;
    public int max;
    public int maxBSTSize;
    
    public Info(Node head, boolean is, int mi, int ma, int size) {
        maxBSTHead = head;
        isBST = is;
        min = mi;
        max = ma;
        maxBSTSize = size;
    }
	public static Info process(Node x){
        if(x == null){
        	return new Info(null, true, Integer.MAX_VALUE, Integer.MIN_VALUE, 0);
        }
    }
```

### leetcode_112. 路径总和

### leetcode_113. 路径总和 ||

### 从前序与中序遍历构建后序遍历

- 解题思路

1. 利用前中后序遍历的性质：前序-中左右-；中序-左中右；后序--左右中
2. 用中序数组的头节点位置对数组进行切分--给定pre-in的范围--在范围内构造
3. 优化--用hashmap存一下节点在中序数组的位置

- 实现代码

```java
// 左神代码
public static void set(int[] pre, int[] in, int[] pos,
        int prei, int prej,
        int ini, int inj,
        int posi, int posj,
        HashMap<Integer，Integer> inMap) {
    if (prei > prej) {
    	return;
    }
    if (prei == prej){ // 只剩下一个数了，直接填
        pos[posi] = pre[prei];
        return;
    }
	pos[posj] = pre[prei];
	int find = inMap.get(pre[prei]);
// in ini..find-1 find+1...inj
    set(pre, in, pos, prei + 1, prei + find - ini, ini, find - 1, posi, posi + find - ini
    set(pre, in, pos, prei + find - ini + 1, prej, find + 1, inj, posi + find ini, pos
}
```

### [leetcode_105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
// 二叉树递归
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder.length == 1) return new TreeNode(preorder[0]);
        int len = inorder.length;
        for (int i=0; i < len; i++) {
            map.put(inorder[i], i);
        }
        return process(preorder, 0, len-1, 0, len-1);

    }
    public TreeNode process(int[] preorder, int preL, int preR, int inL, int inR) {
        if (preL > preR) {return null;}
        int rootPre = preL, rootIn = map.get(preorder[rootPre]);
        TreeNode root = new TreeNode(preorder[rootPre]);
        int leftSize = rootIn - inL;
        root.left = process(preorder,preL+1, preL+leftSize, inL, rootIn-1);
        root.right = process(preorder,preL+leftSize+1, preR, rootIn+1, inR);
        return root;
    }
}
```

### leetcode_222. 完全二叉树的节点个数

- 解题思路

1. 先判断完全二叉树的深度--最左节点深度
2. 看看根节点的右节点的左边是否能达到相同深度
   - 没有达到最深层--右边是满二叉树
   - 达到了最深层

```java
// 深度计算
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        TreeNode l = root.left, r = root.right;
        int leftHigh = 0, rightHigh = 0;
        while (l != null) {
            leftHigh++;
            l = l.left;
        }
        while (r != null) {
            rightHigh++;
            r = r.right;
        }
        if (rightHigh == leftHigh) return (2 << leftHigh) - 1;
         else return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```



## 数据结构：扩展

- 栈和队列的互相转换
  - 如何仅用队列结构实现栈结构?
  - 如何仅用栈结构实现队列结构?
- 图的深度优先遍历(通常用栈)--要求你用队列做-->用队列拼一个栈出来
- 图的宽度优先遍历(通常用队列)--要求你用栈做-->用栈拼一个队列出来

### leetcode_232. 用栈实现队列

- 解题思路

1. push栈弹出的时候必须全部弹出
2. pop栈有元素的时候，push栈不能弹进来

### leetcode_225. 用队列实现栈

- 解题思路

1. 队列1弹出的时候--弹出只省最后一个--其他的放队列2
2. pop栈有元素的时候，push栈不能弹进来

### leetcode_155. 最小栈

- 题目：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。
  - 要求:
  - 1.pop、push、getMin操作的时间复杂度都是0(1);
  - 2.设计的栈类型可以使用现成的栈结构
- 解题思路

1. 准备两个栈--data和min
2. 一个新的数据add进入data--min也添加两个栈顶的最小值--min中永远存的是当前最小值
3. pop时也同时删除

## 子串/子序列问题

### leetcode_3. 无重复字符的最长子串

- 解题思路

1. 以i位置结尾最长的子串大小
2. 限制条件
   - 上一次i位置字符出现的位置
   - i-1位置结尾的最长子串

- 实现代码

````java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || "".equals(s)) { // 避免出现为空的情况
            return 0;
        }
        char[] cs = s.toCharArray();
        int[] map = new int[128];
        Arrays.fill(map, -1);
        int last = -1;
        int ans = -1;
        for (int i=0; i < cs.length; i++) {
            last = Math.max(last, map[cs[i]]);
            ans = Math.max(ans, i-last);
            map[cs[i]] = i;

        }
        return ans;
    }
}

````

### leetcode_72. 编辑距离(必考题目)**

- 解题思路

1. str1前缀长度为i的字符串编辑为str2前缀长度为j的字符串的代价(最低的代价)
2. 插入--删除--替换--三个操作
   - 1.把str1[i-1]变为跟str2一样，再把str1[i]删除
     		dp[ i - 1 ] [ j ] + del
   - 2.把str1[i]变为跟str2[j-1]一样，再把str2[i]加上
     		dp[ i ] [ j - 1 ] + add
   - 3.str1[1-1]变为str2[j-1]--把str1[i]替换为str2[j]--最后的字符相等没有代价(第四中情况--有得题目拷贝有代价)
3. ![编辑距离](.\算法与数据结构刷题笔记_图片\编辑距离.png)

- 实现代码

```java
// 二维DP
class Solution {
    public int minDistance(String word1, String word2) {
        char[] w1 = word1.toCharArray();
        char[] w2 = word2.toCharArray();
        int len1 = w1.length, len2 = w2.length;
        if (len1 == 0 && len2 == 0) return 0;
        int[][] dp = new int[len1+1][len2+1];
        for (int i=1; i <= len1; i++) {
            dp[i][0] = i;
        }
        for (int i=1; i <= len2; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= len1; i++) {
            for (int j=1; j <= len2; j++) {
                if (w1[i-1] == w2[j-1]) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(dp[i-1][j-1] + 1, Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1)); // 替换/删除/插入
                }
            }
        }
        return dp[len1][len2];
    }
}
```

```java
// 一维dp
class Solution {
    public int minDistance(String word1, String word2) {
        char[] w1 = word1.toCharArray();
        char[] w2 = word2.toCharArray();
        int len1 = w1.length, len2 = w2.length;
        if (len1 == 0 && len2 == 0) return 0;
        int[] dp = new int[len2+1];
        for (int i=1; i <= len2; i++) {
            dp[i] = i;
        }
        for (int i = 1; i <= len1; i++) {
            dp[0] = i;
            int pre = dp[0]-1;
            for (int j=1; j <= len2; j++) {
                int cur = dp[j];
                if (w1[i-1] == w2[j-1]) {
                    dp[j] = pre;
                } else {
                    dp[j] = Math.min(pre, Math.min(dp[j], dp[j-1])) + 1; // 替换/删除/插入
                }
                pre = cur;
            }
        }
        return dp[len2];
    }
}
```

## 数组的调整

### [leetcode_54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)：螺旋打印数组

- 解题思路：一圈一圈的输出-用左上角和右下角的点的位置确定圈的范围

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int r = matrix.length, c = matrix[0].length;
        List<Integer> ans = new ArrayList<>();
        int leftX = 0, leftY = 0, rightX = r-1, rightY = c-1;
        while (true) {
            for (int i=leftY; i <= rightY; i++) ans.add(matrix[leftX][i]);
            if (++leftX > rightX) break;
            for (int i=leftX; i <= rightX; i++) ans.add(matrix[i][rightY]);
            if (--rightY < leftY) break;
            for (int i=rightY; i>=leftY; i--) ans.add(matrix[rightX][i]);
            if (--rightX < leftX) break;
            for (int i=rightX; i >= leftX; i--) ans.add(matrix[i][leftY]);
            if (++leftY > rightY) break;
        }
        return ans;
    }
}
```

### [leetcode_48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

- 解题思路：一圈一圈-再一个位置一个位置的换

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        if (n==1) return;
        for (int x=0; x < (n >> 1);x++) {
            for (int y=0; y < ((n+1)>>1); y++) {
                int tmp = matrix[x][y];
                matrix[x][y] = matrix[n-y-1][x];
                matrix[n-y-1][x] = matrix[n-1-x][n-1-y];
                matrix[n-1-x][n-1-y] = matrix[y][n-1-x];
                matrix[y][n-1-x] = tmp;
            }
        }
    }
}
```

### zigzag打印二维数组

- 解题思路：两个指针-一个往右再往下-一个往下再往右
- 代码实现

```java
public static void printMatrixZigZag(int[][] matrix) {
    int ar = 0;
    int ac = 0;
    int br = 0;
    int bc = 0;
    int endR = matrix.length - 1;
    int endC = matrix[0].length - 1;
    boolean fromUp = false;
    while (ar != endR + 1) {
        printLevel(matrix, ar, ac, br， bc, fromUp);
        ar = ac == endC ? ar + 1 : ar;
        ac = ac == endC ? ac : ac + 1;
        bc = br == endR ? bc + 1 : bc;
        br = br == endR ? br : br +1;
        fromUp = !fromUp;
    }
    System.out.printIn();
}
```

### [leetcode_135. 分发糖果](https://leetcode.cn/problems/candy/)

```java
// 一次遍历数组
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] left = new int[n];
        for (int i=0; i < n; i++) {
            if (i > 0 && ratings[i] > ratings[i-1]) {
                left[i] = left[i-1] + 1;
            } else {
                left[i] = 1;
            }
        }
        int right = 0;
        int ans = 0;
        for (int i=n-1; i >= 0; i--) {
            if (i < n-1 && ratings[i] > ratings[i+1]) {
                right++;
            } else {
                right = 1;
            }
            ans += Math.max(right, left[i]);
        }
        return ans;
    }
}
```

### [leetcode_517. 超级洗衣机](https://leetcode.cn/problems/super-washing-machines/)

- 解题思路

1. 首先判断衣服是否能均分
2. 根据某一位置i的洗衣机情况分析
   - 右边衣服的整体数量：与目标的差值
   - 左边衣服的整体数量：与目标的差值

<img src=".\算法与数据结构刷题笔记_图片\leetcode_517. 超级洗衣机.png" alt="leetcode_517. 超级洗衣机" style="zoom: 33%;" />

- 实现代码

```java

class Solution {
    public int findMinMoves(int[] machines) {
        int len = machines.length;
        int sum = 0;
        for (int n:machines) sum+=n;
        if (sum%len != 0) return -1;
        int avg = sum / len;
        int ls = 0, rs = sum, ans = 0;
        for (int i=0; i <len; i++) {
            rs -= machines[i];
            int leftRest = (ls - i*avg);
            int rightRest = (rs - (len-i-1)*avg);
            if (leftRest < 0 && rightRest < 0) {
                ans = Math.max(Math.abs(leftRest) + Math.abs(rightRest), ans);
            } else {
                ans = Math.max(Math.max(Math.abs(leftRest), Math.abs(rightRest)), ans);
            }
            ls += machines[i];
        }
        return ans;
    }
}
```

### [leetcode_442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)

- 解题思路：有限几个变量--实现数据i+1放到i位置上去
- 实现代码

```java
// 有限几个变量 -- 空间复杂度 O(1)
// hashmap统计出现次数 -- 空间复杂度 O(n)
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        int len = nums.length;
        List<Integer> ans = new ArrayList<>();
        for (int i=0; i < len; i++) {
            while (nums[i] != nums[nums[i]-1]) {
                swap(nums, i, nums[i]-1);
            }
        }
        for (int i=0; i < len; i++) {
            if (nums[i]-1 != i) {
                ans.add(nums[i]);
            }
        }
        return ans;
    }
    public void swap(int[] nums, int idx1, int idx2) {
        int temp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = temp;
    }
}
```

### [leetcode_26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int cnt = 0;
        for (int num: nums) {
            if (cnt < 1 || nums[cnt-1] != num) nums[cnt++] = num;
        }
        return cnt;
    }
}
```

### [leetcode_80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

- 思路：充分利用有序的特点

```java
// 删除有序数组重复项 -- 通解
class Solution {
    public int removeDuplicates(int[] nums) {
        return process(nums, 2);
        
    }
    public int process (int[] nums, int k) {
        int u = 0;
        for (int num: nums) {
            if (u < k || nums[u-k] != num) nums[u++] = num;
        }
        return u;
    }
}
```

### [leetcode_209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```java
// 滑动窗口朴素思想 -- 手写 -- coding有待提升
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int len = nums.length;
        int l=0, r=0;
        int sum = 0;
        int ans = Integer.MAX_VALUE;
        while (r < len) {
            if (sum < target) {
                sum += nums[r];
                r++;
            } else {
                ans = Math.min(ans, r-l);
                sum -= nums[l];
                l++;
            }
        }
        while (l < len) {
            if (sum >= target) {
                ans = Math.min(ans, r-l);
                sum -= nums[l];
                l++;
            } else {
                break;
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
```

```java
// 代码优化
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int len = nums.length;
        int l=0, r=0;
        int sum = 0;
        int ans = Integer.MAX_VALUE;
        while (r < len) {
            if (sum < target) {
                sum += nums[r++];
            }
            while (sum >= target) {
                ans = Math.min(ans, r-l);
                sum -= nums[l++];
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
```

```java
// 前缀和 + 二分法
```

## 累加和问题

### leetcode_53. 最大子数组和

- 解题思路：思想很重要

1. 动态规划
2. 最大最长子串

- 实现代码

```java
// 尝试以i结尾的最大情况 -- 动态规划
// 1. min -- 以 i 之前结尾的子数组最小值
// 2. cur -- 以 0-i 子串的值
// 3. 此时 cur - min 是以i结尾的最大值
class Solution {
    public int maxSubArray(int[] nums) {
        int len = nums.length;
        if (len == 1) return nums[0];
        int min = 0, cur = 0, max=Integer.MIN_VALUE;
        for (int num: nums) {
            cur += num;
            max = Math.max(max, cur-min);
            min = Math.min(min, cur);
        }
        return max;
    }
}
```

```java
// 动态规划 -- 参考
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}
```



### 牛客网_子矩阵的最大累加和问题

- 题目：给定一个整型矩阵，返回子矩阵的最大累计和。
- 解题思路：延续leetcode_53的思想--子矩阵压缩为子数组--在行的方向上压缩数组**

1. 行方向上所有存在的情况查找累加和最大的矩阵
2. 多行矩阵的累加和--0-1行的所有子矩阵的最大累加和--因为需要包含每一列的所有数据直接把列方向的数据压在一起

- 实现代码

```java
// 左神代码
public class Problem87_SubMatrixMaxSum {
	public static int maxSum(int[][] m) {
    	if (m == null || m.length == 0 || m[0].length == 0) {
			return 0;
        }
        int max = Integer.MIN_VALUE;
        int cur = 0;
        int[] s = null;
        for (int i = 0;i != m.length; i++){ // 开始的行号i
            s = new int[m[e].length]; //
            for (int j = i;j != m.length; j++){ // 结束的行号，i~j行是我讨论的范
                cur = 0:
                for (int k = 0; k != s.length; k++) {
                    s[k] += m[j][k];
                    cur += s[k];
                    max = Math.max(max, cur);
                    cur = cur < 0 ? 0 : cur;
                }
            }
        }
		return max;
    }
}
```



### leetcode_面试题 17.24. 最大子矩阵

```java
// 二维 最大子数组和 的转化
class Solution {
    public int[] getMaxMatrix(int[][] matrix) {
        int row = matrix.length, col = matrix[0].length;
        int[] curNow = null;
        int[] ans = new int[4];
        int max = Integer.MIN_VALUE;
        for (int top=0; top < row; top++) {
            curNow = new int[col];
            for (int bot=top; bot < row; bot++) {
                int left = 0, cur = 0;
                for (int j = 0; j < col; j++) {
                    curNow[j] += matrix[bot][j];
                    cur += curNow[j];
                    if (max < cur) {
                        max = cur;
                        ans[0] = top;
                        ans[1] = left;
                        ans[2] = bot;
                        ans[3] = j;
                    }
                    if (cur < 0) {
                        cur = 0;
                        left = j+1;
                    }
                }
            }
        }
        return ans;
    }
}
```

## 排序

### leetcode_347. 前 K 个高频元素

- 解题思路

1. 小根堆方法
   - 统计词频
   - 小根堆大小为K--记录到目前为止最大的k个词频-堆顶是门槛--额外空间O(k)
2. 大根堆方法-准备词数大小的大根堆直接比词频--额外空更大--最差情况O(n)

- 实现代码

```java
// 堆排序 -- 时间复杂度O(nlogn)
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int[] ans = new int[k];
        Map<Integer, Integer> map = new HashMap<>();
        for (int num: nums) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }
        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> (map.get(a) - map.get(b)));
        for (Integer key: map.keySet()) {
            if (heap.size() < k) {
                heap.add(key);
            } else if (map.get(key) > map.get(heap.peek())) {
                heap.remove();
                heap.add(key);
            }
        }
        int i=0;
        while (!heap.isEmpty()) {
            ans[i++] = heap.remove();
        }
        return ans;
    }
}
```

```java
// 手写堆 - 手写hashmap
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int max = nums[0], min = nums[0];
        for (int num :
                nums) {
            if (min > num)
                min = num;
            if (max < num)
                max = num;
        }
        int[] countMap = new int[max - min + 1];
        for (int num : nums) {
            countMap[num - min]++;
        }
        int[] arr = new int[k];
        int min_count=countMap[0],min_count_idx=0;
        for (int i = 0; i < countMap.length; i++) {
            if(min_count>countMap[i]){
                min_count=countMap[i];
                min_count_idx=i;
            }
        }
        for (int i = 0; i < arr.length; i++) {
            arr[i] = min_count_idx+min;
        }
        int key, value;
        for (int i = 0; i < countMap.length; i++) {
            key = i;
            value = countMap[key];
            insert(arr, key, value, countMap, min);
        }
        return arr;
    }

    public void insert(int[] arr, int key, int value, int[] countMap, int min) {
        int parent = 0, k = 0;
        if (countMap[arr[parent] - min] > value)
            return;
        for (int child = 0; child < arr.length; parent = child, child = 2 * child + 1) {
            if (child + 1 < arr.length && countMap[arr[child + 1] - min] < countMap[arr[child] - min])
                child += 1;
            if (countMap[arr[child] - min] <= value) {
                arr[parent] = arr[child];
            } else
                break;
        }
        arr[parent] = key + min;
    }
}
```



### 扩展：实现一个随时可以查看top-k的结构

- 解题思路

1. 数据结构
   - 词频率表(key，value)
   - 堆[初始长度]按词频统计的小根堆-堆位置map(key，value堆位置)
2. 添加某一个词频时-先看map里是否存在-不存在则创建一个Node，在添加至map，查看是否能进入堆--若存在则用map找到Node
3. 检查堆-preIndex任然为-1
   - 不在堆上
     - 堆满时：大于堆顶->入堆--从0位置heapify
     - 堆没满时：入堆
   - 在堆上--直接调整heapify

- 实现代码

```java
// 主程序
public void add(String str) {
    Node curNode = null;
    int preIndex = -1;
    if (!strNodeMap.containsKey(str)) {
        curNode = new Node(str，1);
        strNodeMap.put(str， curNode);
        nodeIndexMap.put(curNode， -1);
    } else {
        curNode = strNodeMap.get(str);
        curNode.times++;
        preIndex = nodeIndexMap.get(curNode);
    }
    if (preIndex == -1) {
        if (index == heap.length) {
            if (heap[0].times < curNode.times) {
                nodeIndexMap.put(heap[0], -1);
                nodeIndexMap.put(curNode, 0);
                heap[0] = curNode;
                heapify(0, index);
            }
        } else {
            nodeIndexMap.put(curNode, index);
            heap[index] = curNode;
            heapInsert(index++);
        } else {
    		heapify(preIndex，index);
        }
    }
}
```

```java
// 数据结构
// 1. Node是存储的数据结构
    // 堆上放的东西是node类型的实例
public static class Node {
    public String str;
    public int times;
    public Node(String s, int t) {
        str = s;
        times = t;
    }
}
// 2. 三个数据结构
public static class TopKRecord {
    private HashMap<String, Node> strNodeMap;
    private Node[] heap;
    private HashMap<Node, Integer> nodeIndexMap;
    private int index;
    public TopKRecord(int) {
    	heap = new Node[K];
    	index = 0;
    	strNodeMap = new HashMap<String, Node>();
    	nodeIndexMap = new HashMap<Node, Integer>();
    }
}
```

```java
// swap 方法
private void swap(int index1, int index2) {
    nodeIndexMap.put(heap[index1], index2);
    nodeIndexMap.put(heap[index2], index1);
    Node tmp = heap[index1];
    heap[index1] = heap[index2];
    heap[index2] = tmp;
}
```

```java
// heapify 方法
private void heapInsert(int index) {
    while (index != 0) {
        int parent = (index - 1) / 2;
        if (heap[index].times < heap[parent].times) {
            swap(parent, index);
            index = parent;
        } else {
            break;
        }
    }
}
```

```java
// heapinsert
private void heapify(int index, int heapSize) {
    int l = index*2 + 1;
    int r = index *2 + 2;
    int smallest = index;
	while (l < heapSize) {
		if (heap[l].times < heap[index].times) {
			smallest = 1;
        }
        if (r < heapSize && heap[r].times < heap[smallest].times) {
        	smallest = r;
        }
        if (smallest != index) {
        	swap(smallest，index);
        } else {
        	break;
        }
        index = smallest;
        l = index *2 + 1;
        r = index*2 + 2;
    }
}
```

## 其他未处理题目

### 题目1

- 题目：

![其他未处理题目1_0](.\算法与数据结构刷题笔记_图片\其他未处理题目1_0.png)

- 解题思路

1. 两个集合的平均值相等时--不在进行magic操作
2. 两个集合平均值不相等时--只能从平均值大的集合拿数到平均值小的集合里去-拿两个平均值之间的数且小集合中不存在该数--从最小的开始拿就可以保证进行的次数尽可能的多(贪心策略)
3. 保证两个集合没有重复的值--且不能为空

- 代码

```java
public Class Problem82_MagicOp {
// 请保证arr1无重复值、arr2中无重复值，且arr1和arr2肯定有数字
    public static int maxOps(int[] arr1, int[] arr2) {
        double sum1 = 0;
        for (int i = 0; i < arr.length; i++) {
            sum1 += (double) arr1[i];
        }
        double sum2 = 0;
        for (int i = 0; i< arr2.length; i++) {
            sum2 += (double) arr2[i];
        }
        if (avg(sum1, arr1.length) == avg(sum2, arr2.length)) {
            return 0;
        }
        // 平均值不相等
        int[] arrMore = null;
        int[] arrLess = null;
        double sumMore = 0;
        double sumLess = 0;
        if (avg(sum1, arr1.length) > avg(sum2, arr2.length)) {
            arrMore = arr1;
            sumMore = sum1;
            arrLess = arr2;
            sumLess = sum2;
        } else {
            arrMore = arr2;
            sumMore = sum2;
            arrLess = arr1;
            sumLess = sum1;
        }
        Arrays.sort(arrMore);
        HashSet<Integer> setLess = new HashSet<>();
        for (int num : arrLess) {
            setLess.add(num);
        }
        int moreSize = arrMore.length; // 平均值大的集合还剩几个数
        int lessSize = arrLess.length; // 平均值小的集合还剩几个数
        int ops = 0;// 操作了多少次
        for(int i=0; i<arrMore.length; i++) { // 小-> 大
            double cur = (double) arrMore[i];
            if (cur < avg(sumMore, moreSize) 
                && cur > avg(sumLess，lessSize)
                && !setLess.contains(arrMore[i])) {
                sumMore -= cur;
                moreSize--;
                sumLess += cur;
                lessSize++;
                setLess.add(arrMore[i]);
                ops++;
            }
        }
        return ops;
    }
}
```

### 题目2

- 题目

![其他未处理题目2_0](.\算法与数据结构刷题笔记_图片\其他未处理题目2_0.png)

- 解题思路

1. N是质数-只能N-1次2操作实现
2. N是合数-拆分成质数-求和

- 实现代码

```java
// 请保证n不是质数
// 返回:
// 0.所有因子的和,但是因子不包括1
// 1.所有因子的个数，但是因子不包括1
public static int[] divsSumAndCount(int n) {
    int sum = 0;
    int count = 0;
    for (int i = 2; i <= n; i++) {
        while (n % i == 0) {
            sum += i;
            count++;
            n /= i;
        }
    }
	return new int[] { sum, count };
}
public static int minOps(int n) {
    if (n<2) {
    	return 0;
    }
    if (isPrim(n)) {
    	return n - 1;
    }
    // n不是质数
    int[] divSumAndCount = divsSumAndCount(n);
    return divSumAndCount[e] - divSumAndCount[1];
}
```

- 视频：参考-中级提升班-4：https://www.bilibili.com/video/BV13g41157hK/?p=23&vd_source=92b97bb4944743a8ae534b44e1c2b297
  - 1：20

### 牛客网_划分数组

- 题目

![其他未处理题目3_0](.\算法与数据结构刷题笔记_图片\其他未处理题目3_0.png)

- 解题思路

1. 目标问题：|max左-max右|最大
2. 分类讨论
   - 1.arr中的max在左边--右边无论如何都包含最后一个数--直接在最后一个数切
   - 2.同理--arr中的max在右边--只切第一个数

### leetcode_796. 旋转字符串

- KMP和Manacher算法->旋转字符串--判断a是否为b的旋转字符串
- 解题思路

1. 把a处理成a+a--判断b是否为a+a的字串
2. 在a+a中任意长度等于a的子串都是旋转字符串

![其他未处理题目4_1](.\算法与数据结构刷题笔记_图片\其他未处理题目4_1.png)

### 咖啡杯问题

- 数据--arr[]咖啡机的数量和效率--N个客户--洗杯子的效率a(只有一台-一个一个的洗)--杯子自然变干净的时间
- 从开始泡咖啡到最后一个杯子使用完成变干净最少的时间
- 时间节点:P24 22.中级提升班-5 1:50之前
- 解题思路

1. 小根堆--解决做咖啡的时间策略
2. 洗咖啡杯的时间

- 实现代码

```java
// 暴力递归
// basecase--最后一个杯子的时间--做完咖啡和洗杯机空闲-从晚的一步开始--选择洗和挥发中时间少的一步
// 假设洗咖啡的机器，在washLine的时间点才有空
// a洗咖啡的机器洗一杯的时间
// b咖啡杯自然挥发的时间
// 如果要洗完drinks[index...N-1]，返回最早完成所有事情的时间点
// 方法二，洗咖啡杯的方式和原来一样，只是这个暴力版本减少了一个可变参数
public static int process(int[] drinks, int a, int b, int index, int washLine) {
    if (index == drinks.length - 1) {
    	return Math.min(Math.max(washLine, drinks[index]) + a, drinks[index] + b);
    }
	// wash是当前的咖啡杯，决定放到洗咖啡的机器里去洗，什么时候洗完
	int wash = Math.max(washLine,drinks[index]) + a;
	// 洗完剩下所有的咖啡杯最早的结束时间
	int next1 = process(drinks, a, b, index + 1, wash);
	// 需要做完有所事情，所以包括我洗完的时间，和剩下咖啡杯洗完的最早时间.
	int p1 = Math.max(wash, next1);
	// 当前的杯子决定挥发
    int dry = drinks[index] + b;
    int next2 = process(drinks, a, b, index + 1, washline);
    int p2 = Math.max(dry, next2);
    return Math.min(p1, p2);
}
```

### 题目6

- 题目

![其他未处理题目6_0](.\算法与数据结构刷题笔记_图片\其他未处理题目6_0.png)

- 解题思路

1. 统计arr数组中的三种类型的数的个数--奇数的个数a--偶数包含一个2因子的个数b--偶数包含4因子的个数c
2. 分类讨论
   - b!=0时
     - 排列方法：这样最节省4因子的数
     - ![其他未处理题目6_1](.\算法与数据结构刷题笔记_图片\其他未处理题目6_1.png)
     - a=1时，c>=1;a>1时，c>=a-1
       违反了--怎么调整都不可能
   - b==0时
     - 排列方法
     - ![其他未处理题目6_2](.\算法与数据结构刷题笔记_图片\其他未处理题目6_2.png)
     - a=0时，c>=0;a=1时，c>=1;a>1时，c>=a

### 题目7

- 题目：给定一个字符串，如果该字符串符合人们日常书写一个整数的形式，返回int类型的这个数;如果不符合或者越界返回-1或者报错。
- 解题思路：先用负数接所有数字--防止负数保存为正数的时候越界

<img src=".\算法与数据结构刷题笔记_图片\其他未处理题目7_1.png" alt="其他未处理题目7_1" style="zoom:33%;" />

- 代码实现

```java
//    不完整
	if (!isValid(str)) {
        throw new RuntimeException("can not convert");
    }
    boolean neg = str[0] =='-' ? true : false;
    final int minq = Integer.MINVALUE / 10;
    final int minr = Integer.MIN_VALUE % 10;
    int res = 0;
    int cur = 0;
	for (int i = neg ? 1 : ; i < str.length; i++) {
        // str[i] = '0' cur -> 0
        // str[i] = '1' cur -> -1
        // str[i] = '4' cur -> -4
        cur ='0'- str[i];
        // 中途转化过程中，溢出的时候
        if ((res < minq) || (res == minq && cur < minr)) {
            throw new RuntimeException("can not convert");
        }
		res = res *10 + cur;
    }
	// res是，转化数字绝对值的负数表达
	if (!neg && res == Integer.MIN_VALUE) {
		throw new RuntimeException("can not convert");
    }
	retarn neg ? res : -res;
```

### [牛客网_被3整除](https://www.nowcoder.com/practice/51dcb4eef6004f6f8f44d927463ad5e8?tpId=98&tqId=32825&qru=/ta/2019test/question-ranking)

- 题目

<img src=".\算法与数据结构刷题笔记_图片\其他未处理题目8_0.png" alt="其他未处理题目8_0" style="zoom:50%;" />

- 解题思路

1. 被3整除的原理--时间会溢出
2. 打表--秒杀

- 实现代码

```python
// 打表
import sys
for line in sys.stdin:
    a = line.split()
    x1 = (int(a[0]) -1) * 2 // 3
    x2 = int(a[1]) * 2 // 3
    print(x2-x1)
```

### 题目9

- 题目

![其他未处理题目9_0](.\算法与数据结构刷题笔记_图片\其他未处理题目9_0.png)

![其他未处理题目9_1](.\算法与数据结构刷题笔记_图片\其他未处理题目9_1.png)

- 解题思路:

1. 图的宽度优先遍历
2. 汇总所有位置的收益和天数的表

![其他未处理题目9_2](.\算法与数据结构刷题笔记_图片\其他未处理题目9_2.png)



### 题目10

- 题目

![其他未处理题目10_0](.\算法与数据结构刷题笔记_图片\其他未处理题目10_0.png)

- 实现代码

```java
// 贪心
// s中只有'.'或者'X'两种字符
// 路灯可以影响左中右三个位置
// 至少需要多少灯，可以把.都点亮
public static int minLight(String s) {
    char[] str = s.toCharArray();
    int index = 0;
    int light = 0;
	// 当你来到i位置，一定要保证之前的灯，彻底不会影响到i位置
	while (index < str.length) {
        if (str[index] == 'X') {
            index++;
        } else {
            light++;
            if (index + 1 == str.length) {
                break;
            } else {
                if (str[index + 1] =='X') {
                    index = index + 2;
                } else {
                    index = index + 3;
                }
            }
        }
    }
	return light;
}
```

### 牛客网_表达式得到期望结果的组合种数

- 题目

<img src=".\算法与数据结构刷题笔记_图片\其他未处理题目11_0.png" alt="其他未处理题目11_0" style="zoom:50%;" />

- 解题思路

1. 三种运算符都是二元运算符--在符号的左右数据的两边加不同的括号就是不同的排列方式
2. 范围尝试的思路--f(l,r,desire)--在l到r的范围上达到desire的方法有多少种--分别尝试不同位置的符号作为最后结合的符号
3. 通过该符号的性质--获取左右需要的情况--拆分递归
   - 比如：该符号为或--desire为True--左右都需要为True才行--方法数为左右为True的情况相乘

<img src=".\算法与数据结构刷题笔记_图片\其他未处理题目11_1.png" alt="其他未处理题目11_1" style="zoom:50%;" />

- 实现代码

```java
// 暴力递归
// basecase--范围内只有一个字符
public static int p(char[] exp, boolean desired, int L, int R) {
    if (L == R) { // base case
        if (exp[L] == '1') {
        	return desired ? 1 : 0;
        } else { // '0'
        	return desired ? 0 : 1;
        }
    }
    int res = 0;
	if (desired){ // 期待为true
		// i位置尝试L..R范围上的每一个逻辑符号，都是最后结合的
		for (int i = L+1; i < R; i += 2) {
			switch (exp[i]) {
				case '&':
					res += p(exp,true, L,i - 1) * p(exp, true, i + 1, R);
					break;
                case '|':
                    res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
					res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                    res += p(exp, true, L, i - 1) * p(exp，true, i + 1, R); 
					break;
				case '^':
                    res += p(exp, true, L, i - 1)*p(exp, true,i+1,R);
                    res += p(exp,false,L,i - 1)*p(exp,false,i+1,R);
                    break;
            }
        }
    }
	return res;
}
```

```java
// 动态规划
public static int dpLive(String express, boolean desired) {
    char[] str = express.toCharArray();
    int N = str.length;
    int[][] tMap = new int[N][N];
    int[][] fMap = new int[N][N];
	for (int i=0; i < N;i += 2) {
        tMap[i][i] = str[i] == '1' ? 1 : 0;
        fMap[i][i] = str[i] == '0' ? 1 : 0;
    }
    for (int row = N - 3; row >= 0; row -= 2) {
		for (int col = row + 2; col < N; col += 2) {
        // row..col tMap fMap
			for (int i = row + 1; i < col; i += 2) {
				switch (exp[i]) {
                    case '&':
                        tMap[row][col] += tMap[row][i-1] * tMap[i+1][col];
                        break;
                    case '|':
                        tMap[row][col] += tMap[row][i-1] * fMap[i+1][col];
                        tMap[row][col] += fMap[row][i-1] * tMap[i+1][col];
                        tMap[row][col] += tMap[row][i-1] * tMap[i+1][col];
                        break;
                    case '^':
                        tMap[row][col] += tMap[row][i-1] * fMap[i+1][col];
                        tMap[row][col] += fMap[row][i-1] * tMap[i+1][col];
                        break;
            	}
            }
        }
    }
    return desired ? tMap[0][N-1] : fMap[0][N-1];
}
```

### 牛客网_删除多余的字符得到字典序最小的字符串

- 题目

<img src=".\算法与数据结构刷题笔记_图片\其他未处理题目12_0.png" alt="其他未处理题目12_0" style="zoom:50%;" />

- 解题思路：贪心策略

1. 统计词频
2. 遍历字符串--当某个字符第一次为0的时候--剔除左边所有字符-保留该字符左边ascll码最小的字符-并剔除字符串中所有的该字符---从该字符开始继续往后

<img src=".\算法与数据结构刷题笔记_图片\其他未处理题目12_1.png" alt="其他未处理题目12_1" style="zoom:25%;" />

- 实现代码

```java
// 在str中，每种字符都要保留一个，让最后的结果，字典序最小，并返回
public static String remove(String str) {
    if(str == null || str.length() < 2) {
    	return str;
    }
	int[] map = new int[256];
	for(int i = 0; i< str.length(); i++) {
		map[str.charAt(i)]++;
    }
	int minACSIndex = 0;
    for(int i = 0;i < str.length(); i++) {
    	if(--map[str.charAt(i)] == 0) {
    		break;
        } else {
    		minACSIndex = str.charAt(minACSIndex) > str.charAt(i) ? i : minACSIndex;
        }
    }
	return String.valueOf(str.charAt(minACSIndex)) +
		remove(
			str.substring(minACSIndex + 1)
			.replaceAll(String.valueOf(str.charAt(minACSIndex), "");
}
```

### 百度原题

- 题目

![其他未处理题目13_0](.\算法与数据结构刷题笔记_图片\其他未处理题目13_0.png)

- 解题思路

1. f(N)长度为N的字符串的子序列(升序)有多少个

   ```java
   // 长度为len的字符串有多少个
   public static int f(int len) {
       int fum = 0;
       for (int i= 1; i <= 26; i++) {
       	sum += g(i,len);
       }
   	return sum;
   }
   ```

2. g(char, len)以char开头的长度为len的子序列(升序)有多少个

   ```java
   // 必须以1号字符开头、总长度为len的字符串有多少个
   public static int g(int i, int len) {
       int sum = 0;
       if (lem == 1) {
           return 1;
       }
   	for (int j = i+1; j <= 26; j++) {
           Sum += g(j, len - 1);
       }
   	return sum;
   }
   //  末尾不够的会返回0
   ```

3. 长度为x一定包括长度小于x的所有情况 {d,j,r} d之前的左右情况

- 实现代码

```java
public static int kth(String s) {
    char[] str = s.toCharArray();
    int sum = 0;
    int len = str.length;
    for (int i = 1; i < len; i++) {
    	sum += f(i);
    }
	int first = str[]-'a'+1;// 第一个字符
	for (int i=1; i< first; i++) {
		sum += g(i, len);
    }
	int pre = first;
    for (int i=1; i< len; i++) {
    	int cur = str[i] - 'a' + 1;
    	for (int j= pre + 1;j< cur; j++) {
    		sum += g(j, len - i);
        }
    	pre = cur;
    }
    return sum + 1;
}
public static void main(String[] args) {
	String test ="bc";
	System.out.println(kth(test));
}
```



# 四、高级班

## 4_1.题目代练

### 1.第k问题汇总

#### base题目：[leetcode_4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

```java
// 二分法查找 第kth数 -- 时间复杂度 -- O(log(m*n))
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len = nums1.length + nums2.length;
        if ((len & 1) == 1) {
            return getKthMin(nums1, nums2, len/2 + 1);
        } else {
            return getKthMin(nums1, nums2, len/2 + 1)/2.0 + getKthMin(nums1, nums2, len/2)/2.0;
        }
    }
    public int getKthMin(int[] nums1, int[] nums2, int kth) {
        int l1 = nums1.length;
        int l2 = nums2.length;
        int idx1 = 0;
        int idx2 = 0;
        while (true) {
            if (idx1 == l1) return nums2[kth+idx2-1];
            if (idx2 == l2) return nums1[kth+idx1-1];
            if (kth == 1) return Math.min(nums1[idx1], nums2[idx2]);
            int h = kth/2;
            int newIdx1 = Math.min(idx1 + h, l1) - 1;
            int newIdx2 = Math.min(idx2 + h, l2) - 1;
            int n1 = nums1[newIdx1];
            int n2 = nums2[newIdx2];
            if (n1 < n2) {
                kth -= (newIdx1 - idx1) + 1;
                idx1 = newIdx1 + 1;
            } else {
                kth -= (newIdx2 - idx2) + 1;
                idx2 = newIdx2 + 1;
            }
        }
    }
}
```

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len1 = nums1.length, len2 = nums2.length;
        if (len1 <= 0) return (len2 & 1) == 1 ? nums2[len2/2]: (nums2[len2/2]+nums2[len2/2-1])/2.0;
        if (len2 <= 0) return (len1 & 1) == 1 ? nums1[len1/2]: (nums1[len1/2]+nums1[len1/2-1])/2.0;
        int len = nums1.length + nums2.length;
        if ((len & 1) == 1) {
            return getKthMin(nums1, nums2, len/2 + 1);
        } else {
            return getKthMin(nums1, nums2, len/2 + 1)/2.0 + getKthMin(nums1, nums2, len/2)/2.0;
        }
    }
    public int getKthMin(int[] nums1, int[] nums2, int kth) {
        int[] numS = nums1.length < nums2.length ? nums1: nums2;
        int[] numL = nums1.length >= nums2.length ? nums1: nums2;
        int lenS = numS.length;
        int lenL = numL.length;
        if (kth <= lenS) {
            return getUpMid(numS, 0, kth-1, numL, 0, kth-1);
        }
        if (kth > lenL) {
            if (numS[kth-lenL-1] >= numL[lenL-1]) {
                return numS[kth-lenL-1];
            }
            if (numL[kth-lenS-1] >= numS[lenS-1]) {
                return numL[kth-lenS-1];
            }
            return getUpMid(numS, kth-lenL, lenS-1, numL, kth-lenS, lenL-1);
        }
        // if (lenS <= kth && kth <= lenL)
        if (numL[kth-lenS-1] >= numS[lenS-1]) {
            return numL[kth-lenS-1];
        }
        return getUpMid(numS, 0, lenS-1, numL, kth-lenS, kth-1);

    }
    public int getUpMid(int[] nums1, int s1, int e1, int[] nums2, int s2, int e2) {
        // 相同长度范围比较
        int mid1 = 0, mid2 = 0, offset = 0;
        while (s1 < e1) {
            mid1 = (s1 + e1)/2;
            mid2 = (s2 + e2)/2;
            offset = ((e1-s1+1) & 1) ^ 1;
            if (nums1[mid1] > nums2[mid2]) {
                e1 = mid1;
                s2 = mid2 + offset;
            } else if (nums1[mid1] < nums2[mid2]){
                s1 = mid1 + offset;
                e2 = mid2;
            } else {
                return nums1[mid1];
            }
        }
        return Math.min(nums1[s1], nums2[s2]);
    }
}
```



### 2.链表

#### 环形单链表：约瑟夫环

- 题目:给一个环形单链表--给一个数字--从1开始报数--报到该数的人被提出--下一个人继续从1开始

<img src=".\算法与数据结构刷题笔记_图片\约瑟夫环升级_1.png" alt="约瑟夫环升级_1" style="zoom: 50%;" />

- 解题思路

1. 情况模拟--时间复杂度O(M*N)
2. n个节点m个数活下来的节点是谁--设计一个函数-反推原来的编号--剃刀函数关系启发y=x%i

<img src=".\算法与数据结构刷题笔记_图片\约瑟夫环升级_2.png" alt="约瑟夫环升级_2" style="zoom: 33%;" />

<img src=".\算法与数据结构刷题笔记_图片\约瑟夫环升级_3.png" alt="约瑟夫环升级_3" style="zoom: 25%;" />

<img src=".\算法与数据结构刷题笔记_图片\约瑟夫环升级_4.png" alt="约瑟夫环升级_4" style="zoom: 25%;" />

- 注意
  1. 编号是从1开始
  2. 长度为i的环形链表--报数和位置(编号)的关系--编号=((报数-1)%i)+1
  3. 长度为i的环形链表(老)--与长度为i-1的环形链表(新)的关系为--老=((新-1+S)%i+1--S是被杀的编号

<img src=".\算法与数据结构刷题笔记_图片\约瑟夫环升级_5.png" alt="约瑟夫环升级_5" style="zoom:33%;" />

### 3.有序表

### 4.进制变换

### 5.二叉树

#### [牛客网_找到二叉树中符合搜索二叉树条件的最大拓扑结构]([找到二叉树中符合搜索二叉树条件的最大拓扑结构__牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/e13bceaca5b14860b83cbcc4912c5d4a))

- 新概念——拓扑贡献记录

1. 为了找到以当前根节点出发满足搜索二叉树的最大拓扑结构
2. 创建一种记录(拓扑贡献记录)--每个节点贡献了多少个有效结构，本题目就是多少个有效的搜索二叉树结构

<img src=".\算法与数据结构刷题笔记_图片\拓扑贡献记录1.png" alt="拓扑贡献记录1" style="zoom:50%;" />

3. 把一棵树左、右孩子的拓扑贡献记录(分别对左、右孩子负责)改写为对根节点负责的拓扑贡献记录
4. 左孩子的所有左树信息都可以直接传递给根节点，右孩子的右树信息--找到比根节点大的第一个节点开始修改，提出该节点的所有贡献，并往上修改。右孩子的信息同理。
5. 时间复杂度--O(n)----所有节点的左树右边界和所有节点的右树左边界都是O(n)的时间复杂度-->整体时间复杂度就是O(n)。

<img src=".\算法与数据结构刷题笔记_图片\拓扑贡献记录2.png" alt="拓扑贡献记录2" style="zoom:50%;" />

- 解题思路

1. 本题目是搜索二叉子树的超级进阶题目----
2. 二叉树递归套路--传统的二叉树递归套路->把原来的信息整合成需要的信息向上传递-原来的信息舍弃----本题目--整合出自己的信息原来的信息也要保留-->找到所有信息里的最大值
3. 暴力解->滑动查找大于往右小于往左--能不能找到该值--能找到就有这个结构

- 实现代码

```java
//
public static class Record {
    public int l;
    public int r;
    public Record(int left, int right) {
        this.1 = left;
        this.r = right;
    }
}
//
public static int bstToposize2(Node head) {
	Map<Node,Record> map = new HashMap<Node，Record>();
    return posorder(head,map);
}
//
public static int posOrder(Node h，Map<Node，Record> map){
    if (h == null) {
    	return 0;
    }
	int ls = posorder(h.left，map);
    int rs = posorder(h.right，map);
    modifyMap(h.left, h.value，map, true);
    modifyMap(h.right，h.value，map， false);Record lr = map.get(h. left);
	Record rr = map.get(h.right);
	int lbst = lr == nu1l ? 0 : lr.l + lr.r + 1;
    int rbst = rr == null ? 0 : rr.l +rr.r + 1;
    map.put(h, new Record(lbst, rbst));
	return Math.max(lbst + rbst + 1，Math.max(ls，rs)); //找最大值
}
//
public static int modifyMap(Node n, int v，Map<Node，Record> m， boolean s) {
    if (n == null || (!m.containsKey(n))) {
    	return 0;
    }
	Record r = m.get(n);
	if ((s && n.value > v) ll ((!s) && n.value < v)) {
		m.remove(n);
	return r.l + r.r + 1;
    }else {
	int minus = modifyMap(s ? n.right : n.left, v, m, s);
        if (s) {
            r.r = r.r - minus;
        } else {
            r.l = r.l - minus;
        }
	m.put(n, r);
        return minus;
	}
}

```



### 6.数组

### 7.字符串问题

#### [牛客网_公式字符串求值]([公式字符串求值__牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/c590e97ee1f6462d871430feee055d25))

- 解题思路

  - 优先级+压栈的方法->代码量非常大
  - 括号结合/匹配问题的统一递归方法->f(str, i)->返回两个值
  
    1. 遇到右括号或则整个字符的结尾就停止->计算以该位置开始(遇到右括号/字符串结尾结束)的值
  
    2. 返回结尾的位置(上级递归需要位置信息继续往下计算)
  - 两种基本情况->公式内部是否存在括号

  
  1. 不存在括号时->用栈计算
  
     遇到数字用num记录，遇到运算符号，把原来的数字和运算符号依次放入栈中
  
     若栈顶的元素是乘除符号则弹出两个元素(一个符号和一个数字)->进行运算
  
     <img src=".\算法与数据结构刷题笔记_图片\公式字符串求值1.png" alt="公式字符串求值1" style="zoom: 50%;" />
  
  2. 存在括号时->递归函数
  
     遇见左括号(或者字符串结束位置)返回两个信息<img src=".\算法与数据结构刷题笔记_图片\公式字符串求值2.png" alt="公式字符串求值2" style="zoom:50%;" />

- 实现代码

```java
//主函数
public static int getvalue(String str){
	return value(str.tocharArray(), 0)[0]];
}
//请从str[i...]往下算，遇到字符串终止位置或者右括号，就停止
//返回两个值，长度为2的数组
//0)负责的这一段的结果是多少
//1)负责的这一段计算到了哪个位置
public static int[] value( char[] str, int i) {
    LinkedList<String> que = new LinkedList<String>( );
    int num = 0;
    int[] bra = null;
    while (i < str.length && str[i] != ') ') {
        if (str[i] >= '6'&8 str[i] <= '9') {
        	num = num * 10 + str[i++] - '0';
    	} else if ( str[i] != '(') i i/遇到的是运算符号
			addNum( que,num );
    		que.addLast(String.valueof(str[i++]));
            num = 0;
    	} else { //遇到左括号了
            bra = value( str, i +1);
            num = bra[0];
            i = bra[1] + 1;
    	}
    }
    addNum(que,num) ;
    return new int[] {getNum( que), i};
}
public static void addNum(LinkedList<String> que, int num) {
	if (!que.isEmpty()) {
		int cue = 0;
		String top = que.pollLast();
		if (top.equals( "+") ll top.equals("-")) {
			que. addLast(top);
		}else {
			cur = Integer.valueof(que.pollLast());
			num = top.equals("*") ? (cur* num) : (cur / num);
		}
	}
	que.addLast(String.valueof(num));
}
```

#### [leetcode_1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 解题思路

  - 动态规划：dp[i] [j]数组->含义-str1中的数组[0-i]位置的字符，str2中的数组[0-j]位置的字符最长子串为多长->dp数组中的最大值就是答案

  - 最长公共子序列的可能性

    1. 不以i和j结尾 -> dp[i-1] [j-1]
    2. 以i结尾但不以j结尾 -> dp[i] [j-1]
    3. 不以i结尾但以j结尾 -> dp[i-1] [j]
    4. 不以i结尾也不以j结尾(str1[i] == str2[j]才存在这种情况) -> dp[i] [j] + 1

    四种可能性的最大值就是结果

    

#### [牛客网_最长公共子串]([最长公共子串__牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/210741385d37490c97446aa50874e62d))

子串：必须连续

- 解题思路
  - 动态规划: dp[i] [j]数组->含义-str1中的数组以i位置结尾，str2中的数组以j位置结尾的情况下最长子串为多长->dp数组中的最大值就是答案
  - 只要str1[i] != str2[j], dp[i] [j]直接为0->dp数组中存在大量位置为0
  - 转移方程：每个位置只跟左上角的位置有关dp[i] [j] <- dp[i-1] [j-1] 
  - 基本情况：第一行第一列->只用看该位置的字符是否相等<img src=".\算法与数据结构刷题笔记_图片\最长公共子串1.png" alt="最长公共子串1" style="zoom:50%;" />

- 实现代码 

```java
//动态规划--二维dp

```

```java
//有限几个变量
public static String lcst2(String s1,String s2) {
	if ( s1 == null ll s2 == null ll s1.equals("")ll s2.equals("")){
        return "";
    }
	char[] str1 = s1.toCharArray();
	char[] str2 = s2.toCharArray();
    int row = 0;//斜线开始位置的行
    int col = str2.length - 1;//斜线开始位置的列
    int max = 0;//t达到的全局最大值
    int end = 0;//忽略
    while (row < str1.length) {
        int i = row;
        int j = col;
        int len = 0;
		while (i < str1.length && j < str2.length) {
    		if (str1[i] != str2[j]) {
    			len = 0;
    		}else {
    			len++;
            }
    		if ( len > max) {
    			end = i;//记录结束的位置
                max = len;
            }
            i++;
            j++;
        }
        if (col > 0) {
            col--;
        } else {
            row++;
        }
    }
    return s1.substring(end - max + 1, end + 1);
}
```

```java
//最优解->后缀树组
```



```java
//牛客网_最长公共子串
import java.util.Scanner;
// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String str1 = in.nextLine();
        String str2 = in.nextLine();
        char[] c1 = str1.toCharArray();
        char[] c2 = str2.toCharArray();
        int maxLen = 0;
        int maxIdx = 0;
        int r = 0;
        int c = c2.length - 1;
        while (r < c1.length) {
            int len = 0;
            int i = r;
            int j = c;
            while (i < c1.length && j < c2.length) {
                if (c1[i] != c2[j]) {
                    len = 0;
                } else {
                    len++;
                }
                if (len > maxLen) {
                    maxIdx = i;
                    maxLen = len;
                }
                i++; j++;
            }
            if (c > 0) {
                c--;
            } else {
                r++;
            }
        }
        if (maxLen == 0) {
            System.out.print("-1");
        } else {
        System.out.print(str1.substring(maxIdx - maxLen + 1,maxIdx + 1));   
        }
    }
}
```

### 8.递归

#### 汉诺塔进阶问题

- 题目

汉诺塔游戏的要求把所有的圆盘从左边都移到右边的柱子上，给定一个整型数组arr,其中只含有1、2和3，代表所有圆盘目前的状态，1代表左柱，2代表中柱，3代表右柱，arr[i]的值代表第i+1个圆盘的位置。
比如，arr=[3,3,2,1]，代表第1个圆盘在右柱上、第2个圆盘在右柱上、第3个圆盘在中柱上、第4个圆盘在左柱上
如果arr代表的状态是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨迹中的第几个状态;如果arr代表的状态不是最优移动轨迹过程中出现的状态，则返回-1。(圆盘从小到大)

- 解题思路

1. 设定汉诺塔问题的三个杆为 from to other
2. 移动i个圆盘的问题->将第[1,i-1]个圆盘移动到other，此时i位于from
3. i移动到to
4. 将第[1,i-1]个圆盘移动到to
5. i只能位于from和to的两个位置--其他情况都不是最优解

- 实现代码

```java
//参考左神高级班-8--最后一个题目
public static int step1(int[ ]arr) {
    if ( arr == nu11 ll arr.length == 0) {
        return -1;
    }
    return process(arr, arr. length - 1，1，2，3);
}
//目标是:把0~i的圆盘，从from全部挪到to上
//返回，根据arr中的状态arr[0..i]，它是最优解的第几步?
public static int process(int[] arr, int l, int from，int other，int to) {
    if (i == -1) {
    	return 0;
    }
    if (arr[i] != from && arr[i] != to) {
        return -1;
    }
    if (arr[i] == from) {} //第一大步没走完
    	return process(arr, i - 1， from，to, other);
	}else {//arr[i] == to
    	int rest = process(arr, i - 1， other，from，to);
    //第三大步完成的程度
    if ( rest == -1) {
    return -1;
    }
    return (1 << i) + rest;
}
```

### 9.其他题目

#### 牛客网_最短包含字符串的长度

- 解题思路

1. str1的子串包含str2的所有字符即可顺序可以不一致
2. 双指针(滑动窗口)：右指针向右移动--字符是需要字符，需要的字符all-1，需要的字符表该字符-1--一直移动到all为0；左指针开始右移动--移动到欠一个字符时--右指针开始右移--一直重复

- 实现代码

```java
//下来自己写一下
```

#### [leetcode_460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

- 解题思路

1. key-value-操作数-操作时间(每操作一次time++)--先替换操作次数少的-再替换使用时间最早的--set和get方法时间复杂度O(1)

2. 把二维双向链表放在桶内，相同操作数的词放同一个桶；map记录key和对应的key-value的地址；直接使用map找到key-value在双向链表上的位置
3. 操作某一个数--操作数++；断开原来的双向链表；放入现在操作数的桶里(没有就创建)--桶与桶之间双向链表链接
4. 桶的消除-节点的删除重连的coding比较难

<img src=".\算法与数据结构刷题笔记_图片\LFU缓存1.png" alt="LFU缓存1" style="zoom:50%;" />

#### 牛客网_加油站良好出发点问题

#### 

- 解题思路

1. 时间复杂度O(n), 额外空间复杂度O(1)

2. 纯能值-->自己的油数减去该位置到下一位置消耗的油-->把油数组转化为纯能值数组--计算结束再转回去

3. 问题转化为：过程累加和是否小于0

4. 为了不枚举所有情况

   - 引入连通区(左闭右开[A, B))
   - rest是通过连通区域剩余的油,通过联通区剩下的油
   - nedd是当前节点接到联通区的头部至少需要多少油

5. 双指针：以最大的正纯能值位置开始；rest的值大于下一位置的纯能值，右指针右移-移到rest不够满足下一个位置的纯能值；左指针左移(逆时针)，若左扩的纯能值大于need，rest+纯能值-need，若纯能值小于need则need-纯能值

   <img src=".\算法与数据结构刷题笔记_图片\加油站1.png" alt="加油站1" style="zoom:50%;" />

6. 联通区头部往前扩展，都没有良好出发点，已经要形成环了，联通区头部往后的部分也一定为非良好点

7. 找到一个良好点只用判断前面的点能不能接到头上

- 实现代码

```java
```

#### [leetcode_134. 加油站](https://leetcode.cn/problems/gas-station/)

```java
// 一次遍历尝试
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;
        int i=0;
        while (i < len) {
            int cur = 0;
            int cnt = 0;
            while (cnt < len) {
                int j = (i + cnt) % len;
                cur += gas[j] - cost[j];
                if (cur < 0) break;
                cnt++;
            }
            if (cnt == len) return i;
            else i += cnt + 1;
        }
        return -1;
    }
}
```



#### 牛客网_找到搜索二叉树中两个错误的节点

#### [leetcode_99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)

- 解题思路

1. 搜索二叉树中序遍历->结果是从小到大
2. 第一次降序的前一个节点和后一次降序的后一个节点(可能只有一个降序的位置)
3. 拓展：出现多次降序--错误节点不止两个；出现降序次数小于两次，不一定只有两个节点

	比如：12345--13425就是234三个节点位置错了

4. 若根据前面的策略找到两个位置交换后不能还原，证明不止两个位置出错

- 进阶：交换两个节点的地址位置

1. 情况考虑(e1是中序遍历的第一个节点，e2是中序遍历的第二个节点)
   - e1和e2谁是整个树的头节点
   - e1和e2是否相邻？谁是父节点？
   - e2不会是e1的左孩子；e1不会是e2的右孩子

- 实现代码

二叉树代码的标杆题目--一定自己动手先写一下--最后一个视频的1：27

```java
```

## 牛客网_矩形重叠

- 解题思路-

1. 从最大重合线段数开始：先把开始位置的线段排序，把第一个开头对应的结束位置放入有序表；处理第二个开头，把有序表小于等于2的结尾全部扔掉，添加这个数的结尾--有序表里面的数就是此时的答案
2. 线段重叠问题的时间复杂的O(N*logN)，有序表的增删改查时间复杂度O(logN)
3. 矩形重叠问题：某个重叠矩形的底一定是某个矩形的底
4. 把矩形的底边排序；容器里面只保留上边比当前位置的底边高的矩形
5. 把容器内的矩形的左右边界当作线段处理

## 4_2.技巧总结 

#### 1.双指针技巧

##### 牛客网_船渡人问题

给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数limit，代表一艘船的载重。以下是坐船规则，1）每艘船最多只能做两人;2）乘客的体重和不能超过limit。返回如果同时让这N个人过河最少需要几条船。

- 解题思路

  - 先排序(最好使用计数排序-时间复杂度O(n))-找到小于等于limit/2的位置；没有小于等于limit/2的数->有多少人就多少船；没有大于limit/2的数->有多少人/2就多少船；

  - 找到limit/2的位置，左边为L指针，右边为R指针->判断[L] + [R]的情况

  - [L] + [R] > limit -> L解决不了右边任何一个数 -> L--(左移)

  - [L] + [R] <= limit -> R右移一直到[L] + [R] > limit的前一个位置--L左移选择对应数量的数字去匹配(贪心策略) -> 直到匹配完所有的数字

  - 剩余的<=部分的数字两个一条船 -- 剩余的>部分的数字自己一条船

  - 最后：滑动的过程匹配a条船 - ＜=部分b条船未匹配 - >部分c条船未匹配需要船数->a + b/2(向上取整) + c

    <img src=".\算法与数据结构刷题笔记_图片\船渡人问题.png" alt="船渡人问题" style="zoom:50%;" />

- 实现代码

```java
//核心代码
//保证输入minBoat的数据已经排序过
public static int minBoat(int[ ] arr， int limit) {
    if ( arr == nul1 ll arr.length == 0) {
        return 0;
    }
    //判断--看看是否存在大于limit的值
    if (arr[0] > limit / 2) {
        return arr.length;
    }
    //判断--没有大于limit / 2的值直接返回
    if (arr[arr.length - 1] <= limit / 2) {
		return (arr.length+1) / 2;//常用技巧(数据+1)/2--向上取整
	}

    
	int lessR = -1;
    for(int i = arr. length - 1; i >= 0; i--) {
    	if ( arr[i] <= ( limit / 2)) {
            lessR = i;
            break;
    	}
    }
    if ( lessR == -1) {//没有<=区域直接返回长度
    	return arr. length;   
    }
    int L = lessR;
    int R = lessR +1;
    int lessUnused = 0;//记录叉号的个数--l+1-x就是对数的个数
    while (L >= 0) {
    	int solved = 0;
		while (R < arr. length && arr[L] + arr[R] <= limit) {
    		R++;
    		solved++;
        }
    	if (solved == 0) {
    		lessUnused++;
    		L--;
    	}else {
    		L = Math.max(-1，L - solved);//判断左边的数够不够
        }
    }
    int lessAll = lessR + 1;//左半区总个数 <= limit /2的区域
    int lessUsed = lessAl1 - lessUnused; //画对号的量
    int moreUnsolved = arr.length - lessR - 1 - lessUsed; // > limit/2区中，没搞定的数量
    return lessUsed + (( lessUnused + 1) >> 1) + moreUnsolved;
}
```

#### 2.范围内尝试的模型

- **尝试模型**：在范围内尝试->核心思想：考虑在一个范围的开头和结尾考虑情况能不能把问题解决

1. 在str[i-j]的范围内，某个标准的结果是多少。
2. 一切在范围上尝试的模型都是考虑开头怎么样和结尾怎么样。

- 相关题目

1. leetcode_516. 最长回文子序列

2. [leetcode_1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)
3. 牛客网_添加最少的字符让字符串变为回文字符串（1）

##### [leetcode_516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

- 最长公共子串问题->字符串加自己的逆序串求最长公共子序列->获得原字符串的最长回文子序列

- 解题思路

  1. dp数组dp[i] [j]表示str字符串i-j位置的最长回文子序列
  2. 此时dp数组的左下角位置无效-->对角线位置全部为1；第二对角线上-->两个字符相等为2不相等为1。这两种情况就是basecase。
  3. 在范围内尝试，考虑开头和结尾的情况。

  - 不以i开头，不以j结尾：dp[i+1] [j-1]
  - 以i开头，不以j结尾：dp[i] [j-1]
  - 不以i开头，以j结尾：dp[i+1] [j]
  - 以i开头，以j结尾：此时str[i] == str[j]，dp[i+1] [j-1] + 2

  4. 从右下角往上填写dp数组

<img src=".\算法与数据结构刷题笔记_图片\最长回文子序列.png" alt="最长回文子序列" style="zoom:50%;" />

##### 牛客网_添加最少的字符让字符串变为回文字符串（1）

- 解题思路

1. 在范围内尝试的模型

2. 在str[i] [j]的范围内至少添加几个字符让字符串变为回文

3. 此时dp数组的左下角位置无效-->对角线位置全部为0；第二对角线上-->两个字符相等为0不相等为1。这两种情况就是basecase。

4. 在范围内尝试，考虑开头和结尾的情况。

   - 最后搞定i位置：dp[i+1] [j]是回文串，在最后加一个str[i]->dp[i+1] [j] + 1
   - 最后搞定j位置：dp[i] [j-1]是回文串，在开头加一个str[j]->dp[i] [j-1] + 1
   - 同时搞定i和j位置的字符，此时str[i] == str[j]：dp[i+1] [j-1]

5. 如果只需要dp数组上的一个位置的值->可以压缩数组

   如果需要方法数/方案等可以根据完整的数组还原--深度优先遍历

<img src=".\算法与数据结构刷题笔记_图片\添加最少的字符让字符串变为回文字符串1.png" alt="添加最少的字符让字符串变为回文字符串1" style="zoom:50%;" />

##### 牛客网_回文串方案数

- 解题思路

1. dp[i] [j]：从i-j一个有多少种保留方法是回文串。

2. 可能性分析：

   - case1以i开头且以j结尾的方式：

     str[i]和str[j]相等的时候才有情况1，dp[i+1] [j-1] + 1;不相等则为0；

   - case2不以i开头且以j结尾的方式

   - case3不以i开头且不以j结尾的方式

   - case4以i开头且以不j结尾的方式

   dp[i] [j-1]包括case3和case4；dp[i+1] [j]包括case2和case3；dp[i+1] [j-1]包含 case3；所以dp[i] [j-1]+dp[i+1] [j]-dp[i+1] [j-1]包括case2、case3和case4


##### [leetcode_44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

##### [leetcode_10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

- 解题思路

1. '.'匹配任意单个字符，*匹配零个或多个前面的那一个元素
2. 递归套路：从左往右尝试的模型->f(str, exp, si, ei)--表示从str[si到结尾]能不能匹配exp[ei到结尾]
3. 转移情况
   - [ei+1]位置不是*，si位置和ei位置必须能匹配
   - [ei+1]位置是*
4. 改动态规划：basecase没有完全填好(basecase信息不全/位置依赖的信息不够--隐藏在其他判断位置上)->根据原题意思填好所有能填的位置--本题目至少需要倒数第一行和倒数最后两列的位置的值

<img src=".\算法与数据结构刷题笔记_图片\正则表达式匹配1.png" alt="正则表达式匹配1" style="zoom:50%;" />

- 实现代码

```java
//(左神视频讲解的题目)注意本题目*前面必须要有字符才有效--leetcode_10. 正则表达式匹配
//判断是否有效
public static boolean isValid(char[ ] s, char[ ] e) {
    for (int i = 0; i < s.length; i++) {
        if (s[i] =='*' || s[i] == '.') {
        	return false;
        }
    }
	for (int i = 0; i < e.length; i++) {
		if (e[i] == '*' && (i == 0 || e[i - 1] == '*')) {
    		return false;
		}
	}
    return true;
}
//主函数
public static boolean isMatch(String str，string exp){
    if ( str == nul1 ll exp == nu11) {
    	return false;
    }
    char[] s = str.toCharArray();
    char[] e = exp.toCharArray();
	return isValid(s, e) ? process(s, e, 0，0) : false;
}
//递归函数
//必须保证ei压中的不是*
public static boolean process(char[] s， char[] e, int si， int ei){
    if (ei == e.length) { // base caseexp己经耗尽了
    	return si == s.length;
    }
//可能性一，ei+1位置，不是*
//str[si]必须和exp[ei]配出来,并且后续能走通
    if (ei + 1 == e.length || e[ei + 1] != '*') {
		return si != s.length && (e[ei] == s[si] || e[ei] == '.')
			&& process(s, e, si + 1, ei + 1);
	}
//可能性二，ei +1位置是*
    while (si != s.length &8 (e[ei] == s[si] ll e[ei] == '.')) {
        if (process(s, e, si, ei + 2)) i
        	return true;
        }
    	si++;//尝试不同情况
    }
    return process(s, e, si, ei + 2);
}
```

```java
//DP方法
public static boolean isMatchDP(String str，String exp) {
    if ( str == nul1 ll exp == nul1) {
    	return false;
    }
    char[] s = str.toCharArray();
    char[] e = exp.toCharArray();
    if (!isValid(s, e)) {
    return false;
    }
    boolean[][] dp = initDPMap(s, e);
    for (int i = s.length - 1; i > -1; i--) {
    	for (int j = e.length - 2; j > -1; j--) {
    		if (e[j + 1] != '*') {
    		dp[i][j] = (s[i] == e[j] ll e[j] == '. ' ) &8 dp[i + 1][j+ 1];
            } else {
                int si = i;
                while (si != s.length && (s[si] == e[j] ll e[j] == '. ' )) {
                    if (dp[si][j + 2]) {
                        dp[i][j] = true;
                        break;
                    }
                    si++;
                }
                if ( dp[i][j] ! = true) {
                    dp[i][j] = dp[si][j + 2];
        		}
            }
        }
    }
}
public static boolean[][] initDPMap(char[] 1s， char[] e) {
    int slen = s.length;
    int elen = e.length;
	boolean[][] dp = new boolean[slen + 1][elen + 1];
    dp[slen][elen] = true;
    for (int j = elen - 2; j > -1; j = j - 2) {
        if (e[j] != '*’ && e[j + 1] == '*') {
            dp[slen][j] = true;
        } else {
            break;
        }
	}
    if ( slen > 0 && elen > 0) {
        if ((e[elen - 1] == '.' || s[slen - 1] == e[elen - 1])) {
            dp[slen - 1][elen - 1] = true;
        }
    }
	return dp;
}
```

##### 牛客网_旋变字符串

##### [leetcode_87. 扰乱字符串](https://leetcode.cn/problems/scramble-string/)

- 基本思路

1. 旋变字符串：任意左右分解的结果，是否交换位置组成的结果互为旋变字符串

<img src=".\算法与数据结构刷题笔记_图片\旋变字符串1.png" alt="旋变字符串1" style="zoom:50%;" />

2. 两个字符串的字符种类和数量一样->不一定互为旋变字符串--举例cadb就不是abcd的旋变串-怎么换位置和切分都不行
3. 范围上尝试的模型：str1[l1, r1]和str2[l2,r2]范围上是否互为旋变串->思维递归--两个字符串的长度必须一样，降维l1和l2和长度，三个参数
4. 可能性分类
   - 根据第一刀切的情况进行分类：左边为1个字符的情况---str1[0]和str2[0]是否互为旋变串&&str1[1-N-1]和str2[1-N-1]是否互为旋变串--或者str1[0]和str2[N]是否互为旋变串&&str1[1-N-1]和str2[0-N-2]是否互为旋变串-->左边为n个字符的情况依次类推----有一个为true就是可以
5. 改动态规划->用l1和l2作为每层的横纵坐标，size作为层数，第一层依赖自己，高层的位置依赖底层的位置----一定要确定递归什么位置碰不到--不会用到的递归状态改动态规划的时候也别填

- 实现代码

```java
//主程序
public static boolean isScramble1(String s1，String s2) {
    if ((s1 == null && s2 != nul1) || (s1 != null &8 s2 == null)){
        return false;
    }
    if (s1 == null && s2 == null) {
    return true;
    }
	if (s1.equals(s2)) {
        return true;
    }
	char[] str1 = s1.toCharArray();
    char[str2 = s2.toCharArray( );
    if ( ! sameTypeSameNumber(str1，str2)) {
        return false;I
    }
    int N = s1.length();
	return process(str1,str2，0，0，N);
}
//递归函数
public static boolean process(char[] str1，char[] str2，int L1，int L2，int size){
    if (size == 1) {
    return str1[L1] == str2[L2];
    }
	//枚举每一种情况，有一个计算出互为旋变就返回true。都算不出来最后返回false
    for (int leftPart = 1; leftPart < size; leftPart++) {
        if (
        //如果1左对2左，并且1右对2右
        (process(str1, str2, L1, L2, leftPart)
        &&
        process(str1, str2, L1 + leftPart, L2 + leftPart, size - leftPart))
        ||
        //如果1左对2右，并且1右对2左
        ( process( str1, str2, L1, L2 + size - leftPart, leftPart)
        &&
        process(str1, str2, L1 + leftPart, L2， size - leftPart))) {
			return true;
        }
	}
	return false;
}
```

```java
//动态规划
publlc static boolean dp(string s1,string s2){
    if ((s1 == null 8& s2 != null) || (sl != null && s2 == null)) {
		return false;
    }
    if (s1 == null && s2 == null){
        return true;
    }
    if (sl.equals(s2){
        return true;
    }
        char[] str1 = s1.toCharArray();
        char[] str2 = s2.tocharArray():
    if (!sameTypeSonmeNumber(str1,str2)) {
        return false ;
    }
    int N = s1.1ength( );
    bonleon[][][] dp = net boolean[N][N][N+1];
    for (int L1 = 0; L1 < N; L1++) {
        for (int L2 = 0; L2 <N; L2++) {
        	dp[L1][L2][1] = str1[L1] == str2[L2];
        }
    }
    for (int size = 2; size <= N; size++) { //面所在的层数为size
        for (int L1 = ; L1 <= N - size; L1++) {
            for (int L2 = 0; L2 <= N - size; L2++) {
                dp[L1][L2][size] = false;
                for (int leftpart = 1; leftPart< size; leftPart++) {
                    if (
                    //如果左1对左2，并且右1对右2
                    (dp[L1][L2][leftPart] && dp[L1 + leftPart][L2 + leftPart][size - leftPart]) ||
                     
					//如果左1对右2，并且右1对左2
                    (dp[L1][L2 + size - leftPart][leftPart] && dp[L1 + leftPart, L2, size - leftPart]))
                        dp[L1][L2][size] = true;
                    	break;
                    }
                }
			}
        }
    }
}
public static boolean sameTypeSameNumber( char[] str1，char[] str2) {
    if ( str1.length != str2.length) {
    	return false;
    }
    int[ ] map = new int[256];
    for (int i = ; i < str1.length; i++) {
    	map[str1[i]]++;
    }
    for (int i = ; i < str2.length; i++) {
        if (--map[str2[i]] < 0) {
            return false;
        }
    }
	return true;
}

```



#### 3.从左往右的尝试模型

- 尝试模型：考虑以i开头到结尾在这个范围内能不能解决这个问题

##### [leetcode_LCR 094. 分割回文串 II](https://leetcode.cn/problems/omKAoA/)

- 解题思路：

1. 从左往右的尝试模型：str[i...]以i开头到结尾的最少切割回文次数是多少
2. 比如:str[0]是回文则情况数为1+dp[1];str[0-1]是回文则情况数为1+dp[2];计算所有情况找到最小的一个

<img src=".\算法与数据结构刷题笔记_图片\分割回文串2.png" alt="分割回文串2" style="zoom:50%;" />

3. f(i)函数：尝试把i...end的字符串，才分成str[i...mid]和str[mid+1...end]两个部分的所有情况都进行尝试

4. 验证str[i...mid]部分是否是回文：直接遍历验证->时间复杂度-O(n) -->优化--范围尝试技巧

- dp[i] [j]：表示str在i-j范围内是不是回文->做下半区没用
- 对角线位置都是T，第二对角线两个字符相等是T，不相等F
- 普遍位置，i位置和j位置相等看dp[i+1] [j-1]位置是不是回文；i位置和j位置不相等不是回文。



- 实现代码

```java
//主函数
public static int mincut(String str) {
    if ( str == null || str.equals("")) {
    	return 0;
    }
    char[] chas = str.tocharArray();
    int len = chas.length;
    int[] dp = new int[len + 1];
    dp[len] = 0;
    dp[len-1] = 1;
    boolean[][] p = record(chas) ;
    for (int i = len - 2; i >= 0; i--) {
    	dp[i] = chas.length - i;
    	for (int j = i; j < len; j++) {//i..j
    		if (p[i][j]) {
				dp[i] = Math.min(dp[i], dp[j + 1] +1);
            }
    	}
    }
    return dp[0];
}
//生成是否是回文的数组
public static boolean[][] record( char[ ] str) {
	boolean[][]record = new boolean[str.length][str.length];
    record[ str.length - 1][str.length - 1] = true;
	for (int i = 0; i < str.length - 1; i++) {
		record[i][i] = true;
		record[i][i + 1] = str[i] == str[i +1];
    }
	for (int row = str.length - 3; row >= 0; row--) {
		for (int col = row + 2; col <'str.length; col++) {
			record[row][col] = str[row] == str[col] &8 record[ row + 1][col - 1];
		}
	}
	return record;
}
```



##### 牛客网_子数组的最大异或和

- 解题思路

1. 前缀树+贪心
2. 尝试以i结尾的子数组最大的异或和为多少--尝试i之前所有的情况-->最烂的思考方式(最烂的思路)
3. 最大异或和：[0, s-1] ^ [s, i] = [0, i] -> [s, i]  =  [0, i]  ^ [0, s-1]  ---> 还是没法优化前缀计算的for循环----时间复杂度--O(n^2)

4. 利用前缀树加速获取最大异或和的位置---->找到某个前缀结果--当前抑或结果为1的位置前缀结果为0，当前抑或结果为0的位置前缀结果为1--从高位选到地位

- 实现代码

```java
//前缀树实现
public static class Node {
    public Node[] nexts = new Node[2];
}
//把所有前缀异或和，加入到NumTrie，并按照前缀树组织
public static class NumTrie {
	public Node head = new Node();
    public void add(int num) {
		Node cur = head;
        for (int move = 31; move >= 0; move--) {// move:向右位移多少位
            int path = ((num >> move) & 1);
            //从最后一位开始往前缀树上挂东西
            cur.nexts[path] = cur.nexts[path] == null
                ? new Node() : cur.nexts[path];//节点存在挂上去-不存在就新建
            cur = cur.nexts[path];
        }
	}
	//sum最希望遇到的路径，最大的异或结果返回 O(32)
    //有符号位时，希望遇到符号位相同的值；无符号位时，所有位置希望遇到不同的值(2进制)
    public int maxXor(int sum) {
		Node cur = head;
		int res = 0; //最后的结果( num^最优选择)所得到的值
        for (int move = 31; move >= 0; move--) {
            //当前位如果是0，,path就是整数e;
            //当前位如果是1、 path就是整数1;
			int path = (sum >> move) & 1; // num第move位置上的状态提取出来
            //sum该位的状态，最期待的路
			int best = move == 31 ? path : (path ^ 1);
            //best :最期待的路->实际走的路--没有最希望的路就走唯一的路
			best = cur.nexts[best] != null ? best : (best ^ 1);
            //path num第move位的状态, best是根据path实际走的路
            res |= (path ^ best) << move;
			cur = cur.nexts[best];
		}
		return res;
	}
}


//主函数--选择异或和最大的部分
public static int maxXorSubarray(int[] arr) {
    if (arr == null || arr.length == 0) {
    	return 0;
    }
    int max = Integer.MIN_VALUE;
    int sum = 0;//一个数都没有的时候,异或和为0
    NumTrie numTrie = new NumTrie();
	numTrie.add(0) ;	
    for (int i = 0; i < arr.length; i++) {
        sum ^= arr[i];//sum -> 0~i异或和
        //numTrie装着所有:一个数也没有、0~0、0~1、0~2、O~i-1
        max = Math.max (max,numTrie.maxXor( sum) );
    	numTrie.add(sum);
    }
    return max;
}

```



#### 4.动态规划_斜率优化

##### 裂开的方法数

```java
/*
题目
给定一个正数n，求裂开的方法数。(递增)
给定一个正数1，裂开的方法有一种，(1)
给定一个正数2，裂开的方法有两种，(1和1)、(2)
给定一个正数3，裂开的方法有三种，(1、1、1)、(1、2)、(3)
给定一个正数4，裂开的方法有五种，(1、1、1、1)、(1、1、2)、(1、3)、(2、2) 、(4)
动态规划优化状态依赖的技巧。
*/
```

- 解题思路

1. 递归方法--处理函数f(pre, rest)--拆分的最小值为pre拆分的结果为rest
2. 递归改动态规划
3. 斜率优化->dp过程存在枚举行为--使用对应位置的表达式取代枚举行为

<img src=".\算法与数据结构刷题笔记_图片\动态规划斜率优化1.png" alt="动态规划斜率优化1" style="zoom:50%;" />

- 实现代码

```java
//递归方法
public static int ways1(int n) {
    if (n< 1) {
    	return 0;	
    }
	return process(1, n);
}
public static int process(int pre, int rest) i
    if (rest == 0) {
    	return 1;//之前裂开的方案，构成了1种有效方法
    }
    if (pre > rest) {
        return 0;
    }
	int ways = 0;
	for (int i = pre; i <= rest; i++) { // i : rest第一个裂开的部分，值是多少
		ways += process( i, rest - i);
	}
	return ways;
} 
```

```java
//递归改动态规划
public static int ways2(int n) {
    if (n < 1) {
    	return 0;
    }
	int[][] dp = new int[n + 1][n + 1];
    for (int pre = 1; pre < dp.length; pre++) {
    	dp[pre][0] = 1;
    }
    for (int pre = n; pre > 0; pre-- ) {
    	for (int rest = pre; rest <= n; rest++) {
			for (int i = pre; i <= rest; i++) {
				dp[pre][ rest] += dp[i][rest - i];
			}
		}
	}
	return dp[1][n];
}
```

```java
//枚举行为的斜率优化
//dp[pre][rest]依赖dp[pre][rest-pre]位置开始的斜对角求和
//dp[pre+1][rest]可以取代dp[pre][rest-pre](不包括)之后的位置
//则dp的枚举行为优化为dp[pre][rest] = dp[pre][rest-pre] + dp[pre+1][rest]
//把枚举行为的O(n)的时间复杂度-->优化为O(1)
public static int ways3(int n) i
    if (n < 1){
    return 0;
    }
	int[][] dp = new int[n + 1][n + 1];
    for (int pre = 1; pre < dp.length; pre++) {
    	dp[pre][0] = 1;
    }
    for (int pre = 1; pre < dp.length; pre++) {
        dp[pre][pre] = 1;
    }
    for (int pre = n - 1; pre > 0; pre--) i
    for (int rest = pre + 1; rest <= n; rest++) {
    	dp[pre][rest] = dp[pre + 1][rest] + dp[pre][rest - pre];
    }
	return dp[1][n];
}
```

<img src=".\算法与数据结构刷题笔记_图片\公式字符串求值2.png" alt="公式字符串求值2" style="zoom:50%;" />

#### 5.二叉树递归套路

- 思路

1. 二叉树递归套路可以解决所有的面试阶段的二叉树问题

- 相关题目

1. [牛客网_找到二叉树中符合搜索二叉树条件的最大拓扑结构]([找到二叉树中符合搜索二叉树条件的最大拓扑结构__牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/e13bceaca5b14860b83cbcc4912c5d4a))

#### 6.尝试模型的选择策略

- 基本思路

1. 当遇到一道完全没思路的题目，不知道怎么尝试就把所有知道的尝试模型试一遍：范围内的尝试模型；从左往右的尝试模型；两个字符串一个为行一个为列的尝试模型。--参数类型尽量少，参数的数量也尽量少

##### [leetcode_312. 戳气球](https://leetcode.cn/problems/burst-balloons/)

- 解题思路

1.尝试模型：所有的气球都尝试最后打爆

- 实现代码

```java
//暴力递归
public static int maxcoins1( int[ ]arr) {
    if ( arr == null || arr.length == 0) {
    	return 0;
    }
    if ( arr.length == 1) {
    	return arr[0];
    }
    int N = arr.length;
    int[] help = new int[N + 2];//两头都补1，完美解决边界问题
    help[0] = 1;
	help[N + 1] = 1;//3,2,5
    // 0 1 2
    // 3 2 5 1
	//01 2 3 4
	//f(1,3)
    for (int i = 0; i < N; i++) {
    	help[i + 1] = arr[i];
    }
	return process(help,1，N);
}
//打爆arr[L..R]范围上的所有气球，返回最大的分数
//假设arr[L-1]和arr[R+1]一定没有被打爆
//尝试的方式:每一个位置的气球都最后打爆
public static int process(int[ ] arr, int L, int R) {
    if (L == R) {//如果arr[L..R]范围上只有一个气球，直接打爆即可
        return arr[L -r1]* arr[L] * arr[R + 1];
    }
	//最后打爆arr[L]的方案，和最后打爆arr[R]的方案，先比较一下
    int max = Math.max(
        arr[L - 1]* arr[L] * arr[R + 1] + process(arr，L + 1，R),
        arr[L - 1] * arr[R] * arr[R + 1] + process(arr，L, R - 1));
	//尝试中间位置的气球最后被打爆的每一种方案
    for (int i = L + 1; i < R; i++) {
    max = Math.max(max,
                   arr[L - 1] * arr[i] *arr[R + 1] + process(arr，L, i - 1)
                   + process( arr, i + 1，R));
    }
	return max;
}
```



### 4_3.经典算法

#### 1.BFPRT算法：Top K问题

- 基本思路

1.荷兰国旗问题的思路解决

- 随机选择一个数v
- 做partition->数组分为三个部分大于小于等于v
- 看看k在不在=v的部分->在就直接返回
- 不在=v的部分，就在大于小于v的部分继续partition -->master公式估算复杂度--平均时间复杂度O(n) --->笔试的时候可以直接这样做

2.时间复杂度严格为O(n)的方法--BFPRT算法

假设原问题的解决方法为f(arr, K)

- **有讲究**的选择一个数
  - 先把数组分为5个数一组，不够五个就剩下的数单独一组
  - 找到每一组的中位数(上中位数)->Marr数组
  - 求Marr的中位数->递归调用f(Marr,Marr.length/2)->返回值就是选出的数
- partition
- 是否命中->未命中左右选一边进递归

时间复杂度估计：

- 假设进小于部分的递归：最差情况小于最多有多少个->Marr中至少有1/2的数比中位数大-整个数组中至少有3N/10
- 整体过程

1. 分组-O(n)
2. 分组的中位数-O(n)
3. f(Marr, arr.length/2)-T(N/5)
4. partition-O(n)
5. T(7N/10)

<img src=".\算法与数据结构刷题笔记_图片\TopK算法.png" alt="TopK算法" style="zoom:50%;" />



- 实现代码

```java
//选择中位数
public static int select(int[] arr, int begin, int end,int i) {
	if (begin == end) {
		return arr[begin];
    }
	//分组＋组内排序＋组成newarr +选出newarr的上中位数pivot
    int pivot = medianOfMedians(arr, begin, end);//获取划分值
	//根据pivot做划分值<p ==p >p(三个部分)，返回等于区域的左边界和右边界
    //pivotRange[0]等于区域的左边界
	//pivotRange[1]等于区域的右边界
	int[] pivotRange = partition( arr, begin,end， pivot);
    if (i >= pivotRange[] &8 i <= pivotRange[1]) {
		return arr[i];
	} else if (i < pivotRange[e]) {
		return select( arr, begin, pivotRange[0] - 1,i);
    }else i
		return select( arr, pivotRange[1] + 1，end， i);
	}
}
//获取划分值
public static int medianOfMedians(int[] arr, int begin，int end) {
    int num = end - begin + 1;
    int offset = num % 5 == 0 ? 0 : 1;
    int[ ] mArr = new int[num / 5 + offset];
    for (int i = 0; i < mArr.length; i++) {
        int beginI = begin + i* 5;
        int endI = beginI + 4;
		mArr[i] = getMedian(arr, beginI，Math.min(end，endI)) ;
	}
	return select(mArr, 0, mArr.length - 1, mArr.length / 2);
}
//
public static int[] partition(int[] arr，int begin，int end，int pivotValue){
    int small = begin - 1;
    int cur = begin;
    int big = end + 1;
    while (cur != big) {
		if (arr[cur] < pivotValue) {
            swap(arr, ++small, cur++);
        }else if (arr[cur] > pivotValue) {
            swap(arr, cur,--big);
		}else {
			cur++;
        }
    }
    int[]range = new int[2];
	range[0] = small + 1;
    range[1] = big - 1;
    return range;
}
//
public static int getMedian(int[ ] arr, int begin, int end) {
    insertionSort(arr, begin, end);
    int sum = end + begin;
    int mid = (sum / 2) + (sum % 2);
    return arr[mid];
}

```

##### 牛客网_在两个排序数组中找到第k小的数

##### [leetcode_4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

- 解题思路

1. 朴素思路--时间复杂度O(K)：两个有序数组--双指针--找出第k小的数

2. 二分思想--时间复杂度O(logN*logM)

   - 假设第K小的数在A中，找到A中点位置的数mid--算出前面数的个数---在到B中二分找mid的位置--算出mid前面数的个数--两个部分加起来不够k则在剩余部分继续二分--A中不存在第300小则假设在B中存在--再尝试一次

3. 最优解思路：求上中位数(偶数个数中-中位数的两个数字小的一个)

   - case1：两个数组都是偶数--比较中点(上中位数)

     - 上中位数位置的数不相等--让大的数的数组的右边和小的数的数组左边去比较--递归

       <img src=".\算法与数据结构刷题笔记_图片\TopK_1.png" alt="TopK_1" style="zoom:33%;" />

     - 上中位数位置的数相等--上中位数位置的值就是上中位数的值

       <img src=".\算法与数据结构刷题笔记_图片\TopK_2.png" alt="TopK_2" style="zoom:33%;" />

   - case2：两个数组都是奇数--比较中点(上中位数)

     - 中点位置相等时：上中位数就是中点的值
     - 中点位置不相等时：剩下的大的数组的左边和小的数组的右边不等长--手动比较减少一个
       	<img src=".\算法与数据结构刷题笔记_图片\TopK_3.png" alt="TopK_3" style="zoom:33%;" />

4. 第K小的数分类：两个数组m和n(m<=n)

   - 1<=K<=m：两个数组只比较第一个数到第K个数的位置->求上中位数出结果

   - m<k<=n：排除不可能的位置--长的数组会多一个--比较排除

     <img src=".\算法与数据结构刷题笔记_图片\TopK_4.png" alt="TopK_4" style="zoom:33%;" />

   - n<K<=m+n：两个数组只比较有可能成为第K小的部分--然后再验证比较分别再剔除一个最小的数--调递归

     <img src="C:\Users\97359\Desktop\数据结构与算法_24_3_28\算法与数据结构刷题笔记Markdown\算法与数据结构刷题笔记_图片\TopK_5.png" alt="TopK_5" style="zoom:33%;" />
     		

- 实现代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len1 = nums1.length, len2 = nums2.length;
        if (len1 <= 0) return (len2 & 1) == 1 ? nums2[len2/2]: (nums2[len2/2]+nums2[len2/2-1])/2.0;
        if (len2 <= 0) return (len1 & 1) == 1 ? nums1[len1/2]: (nums1[len1/2]+nums1[len1/2-1])/2.0;
        int len = nums1.length + nums2.length;
        if ((len & 1) == 1) {
            return getKthMin(nums1, nums2, len/2 + 1);
        } else {
            return getKthMin(nums1, nums2, len/2 + 1)/2.0 + getKthMin(nums1, nums2, len/2)/2.0;
        }
    }
    public int getKthMin(int[] nums1, int[] nums2, int kth) {
        int[] numS = nums1.length < nums2.length ? nums1: nums2;
        int[] numL = nums1.length >= nums2.length ? nums1: nums2;
        int lenS = numS.length;
        int lenL = numL.length;
        if (kth <= lenS) {
            return getUpMid(numS, 0, kth-1, numL, 0, kth-1);
        }
        if (kth > lenL) {
            if (numS[kth-lenL-1] >= numL[lenL-1]) {
                return numS[kth-lenL-1];
            }
            if (numL[kth-lenS-1] >= numS[lenS-1]) {
                return numL[kth-lenS-1];
            }
            return getUpMid(numS, kth-lenL, lenS-1, numL, kth-lenS, lenL-1);
        }
        // if (lenS <= kth && kth <= lenL)
        if (numL[kth-lenS-1] >= numS[lenS-1]) {
            return numL[kth-lenS-1];
        }
        return getUpMid(numS, 0, lenS-1, numL, kth-lenS, kth-1);

    }
    public int getUpMid(int[] nums1, int s1, int e1, int[] nums2, int s2, int e2) {
        // 相同长度范围比较
        int mid1 = 0, mid2 = 0, offset = 0;
        while (s1 < e1) {
            mid1 = (s1 + e1)/2;
            mid2 = (s2 + e2)/2;
            offset = ((e1-s1+1) & 1) ^ 1;
            if (nums1[mid1] > nums2[mid2]) {
                e1 = mid1;
                s2 = mid2 + offset;
            } else if (nums1[mid1] < nums2[mid2]){
                s1 = mid1 + offset;
                e2 = mid2;
            } else {
                return nums1[mid1];
            }
        }
        return Math.min(nums1[s1], nums2[s2]);
    }
}
```

##### [leetcode_215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```java
// 桶排序
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for (int num: nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }
        int[] cnt = new int[max-min+1];
        for (int num: nums) {
            cnt[num-min]++;
        }
        int curK = 0;
        for (int i = cnt.length-1; i >= 0; i--) {
            curK += cnt[i];
            if (curK >= k) return min + i;
        }
        return min;
    }
}
```

```java
// 归并
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return getK(nums, 0, nums.length-1, k);
    }
    public int getK(int[] nums, int l, int r, int k) {
        int mid = nums[l];
        int less = l-1;
        int more = r+1;
        for (int i = l; i < more;) {
            if (nums[i] < mid) swap(nums, i++, ++less);
            else if (nums[i] > mid) swap(nums, i, --more);
            else i++;
        }
        if (k <= r-more+1) return getK(nums, more, r, k);
        if (k > r-less) return getK(nums, l, less,k-(r-less));
        return mid;
    }
    public void swap(int[] nums, int idx1, int idx2) {
        int temp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = temp;
    }
}
```



#### 2.完美洗牌问题

##### 牛客网_完美洗牌问题(1)

- 解题思路

1. 左边的数去向的位置2i，右边的数去向的位置2*(i-N)-1----(i是第几个数>=1)
2. 通过将某一个位置数据拿出来再放到对应位置，完成所有数的调整。但是可能数据不是一个大环，而是多个小环，环与环之间一定不相交。有没有一种方法能够找到所有环的出发点？
3. 若原数组长度为N(偶数)，若N = 3^k - 1，则不同环的出发点为3^(K - 1)(k>=1)
4. 把其他普遍情况拆分为多个满足3^k - 1的数的组合----其他普遍情况的N，找到3^k - 1 <= N的数，先让3^k - 1结果完成3情况的处理-->让3^k - 1位置的数先靠在一起，使用轮转数组的方法。剩下靠在一起的数重复上述步骤-->找最接近3^k - 1的数-->处理
5. 

<img src=".\算法与数据结构刷题笔记_图片\完美洗牌问题1.png" alt="完美洗牌问题1" style="zoom:50%;" />

- 实现代码

```java
//
//数组的长度为len，调整前的位置是i，返回调整之后的位置
//下标不从e开始,从1开始
public static int modifyIndex1(int i， int len) {
    if (i <= len / 2) {
    	return 2 * i;}
    else {
		return 2 *(i - ( len / 2)) - 1;
	}
}
//数组的长度为len，调整前的位置是i，返回调整之后的位置
//下标不从0开始，从1开始
public static int modifyIndex2(int i, int len) {
	return (2 * i) % (len + 1);
}
//主函数
//数组必须不为空,且长度为偶数
public static void shuffle(int[ ]arr) {
    if (arr != null &8 arr.length != 0 && (arr.length & 1) == 0) {
    	shuffLe( arr, 0, arr.length - 1);
	}
}
//
public static void shuffle(int[ ] arr,int L, int R) {
    while (R - L + 1 > 0) {//切成一块一块的解决，每一块的长度满足(3^k)-1
        int len = R - L + 1;
        int base = 3;
        int k = 1;
	//计算小于等于1en并且是离len最近的，满足(3^k )-1的数l/也就是找到最大的k，满足3^k <= len+1
		while (base <= (len + 1) / 3) {
            base *= 3;
            k++;
        }
		//当前要解决长度为base-1的块,一半就是再除2
        int half = (base - 1) / 2;
		//[L..R]的中点位置
		int mid = (L + R)/ 2;
		//要旋转的左部分为[L+half. ..mid]，右部分为arr[mid+1..mid+half]
        //注意在这里，arr下标是从0开始的
		rotate(arr, L + half, mid, mid + half);
		//旋转完成后，从L开始算起，长度为base-1的部分进行下标连续推
    	cycles(arr，L, base - 1，k);
		//解决了前base-1的部分，剩下的部分继续处理
        L = L + base - 1;
	}
}
//从start位置开始，往右len的长度这一段，做下标连续推
//出发位置依次为1,3,9...
public static void cycles(int[ ] arr， int start，int len，int k) {
//找到每一个出发位置trigger，一共k个
//每一个trigger都进行下标连续推
//出发位置是从1开始算的，而数组下标是从e开始算的。
    for (int i = 0, trigger = 1; i < k; i++, trigger *= 3) {
        int preValue = arr[trigger + start - 1];
        int cur = modifyIndex2(trigger，len);
        while (cur l= trigger) {
            int tmp = arr[cur + start - 1];
            arr[cur + start - 1] = preValue;
            preValue = tmp;
            cur = modifyIndex2(cur, len);
        }
        arr[cur + start - 1]= preValue;
    }
}

```

##### [leetcode_324. 摆动排序 II_wiggleSort](https://leetcode.cn/problems/wiggle-sort-ii/)

- 题目概述

把一个无序数组调整为a<=b>=C<=d>=e...这样大于小于交替的排列--额外空间复杂度O(n)

- 解题思路

1. 堆排序--额外空间复杂度O(n)
2. N是偶数->直接完美洗牌；N是奇数->第一个位置的数不懂->后面的数组直接完美洗牌

##### [leetcode_189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

- 题目概述：把数组右边部分和左边部分交换位置

- 解题思路

把右边逆序，再把左边逆序，最后整体逆序。


# 五、算法题笔记

## A、LeetCode

### [leeetcode_64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

```java
//1.动态规划
class Solution {
    public int minPathSum(int[][] grid) {
        int lenR = grid.length;
        int lenC = grid[0].length;
        if (lenR == 1 && lenC == 1) {return grid[0][0];}
        int[][] dp = new int[lenR+1][lenC+1];
        for (int c = 0; c <= lenC; c++){
            dp[0][c] = Integer.MAX_VALUE;
        }
        for (int r = 1; r <= lenR; r++){
            dp[r][0] = Integer.MAX_VALUE;
        }
        dp[0][1] = 0;
        dp[1][0] = 0;
        for (int c = 1; c <= lenC; c++){
            for (int r = 1; r <= lenR; r++){
                dp[r][c] = Math.min(dp[r-1][c], dp[r][c-1])+grid[r-1][c-1];
            }
        }
        return dp[lenR][lenC];
    }
}
```

```java
//2.coding优化
class Solution {
    public int minPathSum(int[][] grid) {
        int lenR = grid.length;
        int lenC = grid[0].length;
        if (lenR == 1 && lenC == 1) {return grid[0][0];}
        int[][] dp = new int[lenR][lenC];
        for (int c = 0; c < lenC; c++){
            for (int r = 0; r < lenR; r++){
                if (c == 0 && r == 0) {dp[0][0] = grid[0][0];}
                else if (c == 0){
                    dp[r][c] = dp[r-1][c] + grid[r][c];
                }
                else if (r == 0){
                    dp[r][c] = dp[r][c-1] + grid[r][c];
                } else{
                    dp[r][c] = Math.min(dp[r-1][c], dp[r][c-1]) + grid[r][c];
                }

            }
        }
        return dp[lenR-1][lenC-1];
    }
}
```

```java
//3.coding在优化--不使用额外的空间--直接在原来的基础上修改
```



### [leetcode_75. 颜色分类---荷兰国旗问题](https://leetcode.cn/problems/sort-colors/)

1. 荷兰国旗问题：num<=k的数放右边，num>k的数放左边

- 解决思路：单指针移动扫描

2. 荷兰国旗升级问题：num<k的数放右边，num=k的数放中间，num>k的数放左边	(时间复杂度O(n),额外空间O(1))

- 解决思路：双指针扫描，left和right
- 当nums[i]<k时，nums[i]和left交换(小于k区域的下一位置)，left++
- 当nums[i]==k时，i啥也不做，i++
- 当nums[i]>k时，nums[i]和left交换(大于k区域的下一位置)，right--

```java
//0.荷兰国旗升级问题思路--双指针
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        int left = -1;
        int right = len;
        int i = 0;
        while (i < right){
            if (nums[i] == 0){
                swap(nums, i, left+1);
                left++;
            }
            if (nums[i] == 2){
                swap(nums, i, right-1);
                right--;
            } else{
                i++;
            }
        }
    }
    public void swap(int[] nums, int i1, int i2){
        int temp = nums[i1];
        nums[i1] = nums[i2];
        nums[i2] = temp;
    }
}
```

```java
//1.单指针
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        int key = 0;
        for (int i = 0; i < len; i++){
            if (nums[i] == 0){
                swap(nums, key, i);
                key++;
            }
        }
        for (int i = key; i < len; i++){
            if (nums[i] == 1){
                swap(nums, key, i);
                key++;
            }
        }
    }
        
    public void swap(int[] nums, int i1, int i2){
        int temp = nums[i1];
        nums[i1] = nums[i2];
        nums[i2] = temp;
    }
}
```

```java
//2.双指针--官方题解思路--思路比较烂
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        int left = 0;
        int right = len-1;
        for (int i = 0; i <= right; i++){
            while (i <= right && nums[i] == 2){
                swap(nums, i, right);
                right--;
            }
            if (nums[i] == 0){
                swap(nums, left, i);
                left++;
            }
        }
    }
    public void swap(int[] nums, int i1, int i2){
        int temp = nums[i1];
        nums[i1] = nums[i2];
        nums[i2] = temp;
    }
}
```

### [leetcode_152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

```java
//1.动态规划--子数组经典思维方式-以i结尾的子序列情况如何---需要考虑负数相乘(最小值)-正数相乘(最大值)
class Solution {
    public int maxProduct(int[] nums) {
        int len = nums.length;
        if (len == 1){ return nums[0];}
        int[] dpMax = new int[len];
        int[] dpMin = new int[len];
        dpMax[0] = nums[0];
        dpMin[0] = nums[0];
        for (int i = 1; i < len; i++){
            dpMax[i] = Math.max(dpMax[i-1]*nums[i], Math.max(dpMin[i-1]*nums[i], nums[i]));
            dpMin[i] = Math.min(dpMax[i-1]*nums[i], Math.min(dpMin[i-1]*nums[i], nums[i]));
        }
        int max = Integer.MIN_VALUE;
        for (int num: dpMax){
            max = Math.max(max, num);
        }
        return max;
    }
}
```

### [leercode_142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```java
//1.环形链表--找到换的入口
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```

### [leetcode_215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

- 解题思路

1. 题目要求时间复杂度为O(N)
2. 快速排序选择方法--平均时间复杂度O(N)--空间复杂度O(logN)
3. 堆排序选择方法--时间复杂度O(NlogN)
4. 计数排序--时间复杂度O(N)
5. BFPRT算法***

- 实现代码

```java
//
```

```java
//计数排序
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int num: nums) {
            max = Math.max(max, num);
            min = Math.min(min, num);
        }
        int[] count = new int[max-min+1];
        for (int num: nums) {
            count[num-min]++;
        }
        int maxK = 0;
        for (int i=count.length-1; i >= 0; i--) {
            maxK += count[i];
            if (maxK >= k) {
                return i + min;
            }
        }
        return min;
    }
}
```



### [leetcode_287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

```java
//1.对应的数字换到对应的位置
class Solution {
    public int findDuplicate(int[] nums) {
        int len = nums.length;
        int idx = 0;
        while (idx < len){
            if (nums[idx] == idx + 1){
                idx++;
            }
            if (nums[idx] != idx + 1 && nums[nums[idx]-1] != nums[idx]){
                swap(nums, idx, nums[idx]-1);
            } 
            if (nums[idx] != idx + 1 && nums[nums[idx]-1] == nums[idx]){
                return nums[idx];
            }
        }
        return 0;
    }
    public void swap(int[] nums, int i1, int i2){
        int temp = nums[i1];
        nums[i1] = nums[i2];
        nums[i2] = temp;
    }
}
```

```java
//2.快慢指针--Floyd 判圈算法
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
}
```

### [leetcode_LCP 30. 魔塔游戏](https://leetcode.cn/problems/p0NxJO/)

- 解题思路

1. 暴力递归改动态规划？？？？改不起动态规划？？？--血量没有上限-动态规划比较难写

- 实现代码

```java
//暴力递归
class Solution {
    public int magicTower(int[] nums) {
        int len = nums.length;
        int sum = 1;
        for (int num: nums) {
            sum += num;
        }
        if (sum <= 0) {
            return -1;
        }
        return process(nums, 0, 1);
    }
    public int process(int[] nums, int idx, int cur) {
        if (idx == nums.length) {
            return 0;
        }
        if (cur + nums[idx] > 0) {
            return Math.min(process(nums, idx + 1, cur) + 1,
                            process(nums, idx + 1, cur + nums[idx]));
        } else {
            return process(nums, idx + 1, cur) + 1;
        }  
    }
}
```

```java
//优先级队列+贪心
class Solution {
    public int magicTower(int[] nums) {
        int len = nums.length;
        int sum = 1;
        for (int num: nums) {
            sum += num;
        }
        if (sum <= 0) {
            return -1;
        }
        long cur = 1;
        int count = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int num: nums) {
            if (num < 0) {
                pq.offer(num);
            
                if (cur + num <= 0) {
                    count++;
                    cur -= pq.poll();
                }
            }
            cur += num;
        }
        return count;
    }

}
```

### [leetcode_1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/) 

- 解题思路

  以某一位置结尾进行尝试

- 实现代码

```java
//动态规划
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] c1 = text1.toCharArray();
        char[] c2 = text2.toCharArray();
        int l1 = c1.length;
        int l2 = c2.length;
        int[][] dp = new int[l1+1][l2+1];
        for (int i = 0; i < l1; i++){
            for (int j = 0; j < l2; j++){
                if (c1[i] == c2[j]) {
                    dp[i+1][j+1] = dp[i][j] + 1;
                } else {
                    dp[i+1][j+1] = Math.max(dp[i+1][j], dp[i][j+1]);
                }
            }
        }
        return dp[l1][l2];
    }
}
```

### [leetcode_79. 单词搜索](https://leetcode.cn/problems/word-search/)

- 解题思路

回溯法+剪枝

- 实现代码

```java
//简单递归回溯+数组记录是否计算过剪枝
class Solution {
    public boolean exist(char[][] board, String word) {
        int r = board.length, c = board[0].length;
        boolean[][] isVisited = new boolean[r][c];
        boolean res = false;
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                res = cheak(board, isVisited, word, i, j, 0);
                if (res) {
                    return true;
                }
            }
        }
        return false;

    }
    public boolean cheak(char[][] board, boolean[][] isVisited, String word,int i, int j, int idx) {
        //最后一个不相等返回false--最后一个相等返回true
        if (board[i][j] != word.charAt(idx)){
            return false;
        } else if (idx == word.length() - 1){
            return true;
        }
        int h = board.length, w = board[0].length;
        isVisited[i][j] = true;
        int[][] dir = {{0,-1}, {0,1}, {-1,0}, {1,0}};
        boolean res = false;
        for (int[] dirNow: dir) {
            int nowI = i + dirNow[0], nowJ = j + dirNow[1];
            if (nowI > -1 && nowI < h && nowJ > -1 && nowJ < w) {
                if (!isVisited[nowI][nowJ]) {
                    res |= cheak(board, isVisited, word, nowI, nowJ, idx + 1);
                }
            }
        }
        isVisited[i][j] = false;
        return res;
    }
}
```

```java
//把额外数组优化掉--用符号代替
class Solution {
    public boolean exist(char[][] board, String word) {
        int r = board.length, c = board[0].length;
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (cheak(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }
    public boolean cheak(char[][] board, String word,int i, int j, int idx) {
        if (idx == word.length()) {
            return true;
        }
        int h = board.length, w = board[0].length;
        if (i < 0 || j < 0 || i >= h || j >= w){
            return false;
        }
        if (board[i][j] != word.charAt(idx)) {
            return false;
        }
        char c = board[i][j];
        board[i][j] = '!';
        boolean res = cheak(board, word, i, j+1, idx + 1)|
                        cheak(board, word, i, j-1, idx + 1)|
                        cheak(board, word, i+1, j, idx + 1)|
                        cheak(board, word, i-1, j, idx + 1);
        board[i][j] = c;
        return res;
    }
}
```

### [leetcode_39. 组合总和](https://leetcode.cn/problems/combination-sum/)

- 解题思路

回溯法

- 实现代码

```java
//选择和不选择的回溯--注意List的抽象类的实现方法和使用方法
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> comb = new ArrayList<>();
        dfs(candidates, ans, comb, target, 0);
        return ans;
    }
    public void dfs(int[] candidates, List<List<Integer>> ans, List<Integer> comb, int rest, int idx) {
        if (idx >= candidates.length) {
            return;
        }
        if (rest == 0) {
            ans.add(new ArrayList<Integer>(comb));
            return;
        }
        dfs(candidates, ans, comb, rest, idx + 1);
        if (rest - candidates[idx] >= 0){
            comb.add(candidates[idx]);
            dfs(candidates, ans, comb, rest - candidates[idx], idx);
            comb.remove(comb.size()-1);
        }
    }
}
```

### [leetcode_74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

- 解题思路

二分法查找

- 实现代码

```java
//把二维的递增数组--拉伸为1维数组
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int h = matrix.length, w = matrix[0].length;
        int low = 0, high = h * w - 1;
        while (low <= high) {
            int mid = (high - low)/2 + low;
            int x = matrix[mid/w][mid%w];
            if (x < target) {
                low = mid + 1;
            } else if (x > target){
                high = mid - 1;
            } else {
                return true;
            }
            
        }
        return false;
    }
}
```

### [leetcode_1870. 准时到达的列车最小时速](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/)

- 解题思路

二分查找

- 实现代码

```java
class Solution {
    public int minSpeedOnTime(int[] dist, double hour) {
        int l = dist.length;
        if (hour <= (double)l - 1) {
            return -1;
        }
        int left = 1, right =  (int) Math.pow(10, 7);
        while(left < right) {
            int mid = (right - left) / 2 + left;
            if (check(dist, mid, hour)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
    public boolean check(int[] dist, int speed, double hour) {
        double t = 0;
        for (int i = 0; i < dist.length-1; i++) {
            t += (dist[i] - 1) / speed + 1;
        }
        t += (double) dist[dist.length-1] / speed;
        return t <= hour; 
    }
}
```

### [leetcode_7. 整数反转](https://leetcode.cn/problems/reverse-integer/)

- 解题思路

数位的运算

- 实现代码

```java
//数位运算
class Solution {
    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            if (res < Integer.MIN_VALUE / 10 || res > Integer.MAX_VALUE / 10) {
                return 0;
            }
            int temp = x % 10;
            x /= 10;
            res = res * 10 + temp;
        }
        return res;
    }
}
```

### 暴力递归/动态规划

#### [leetcode_688. 骑士在棋盘上的概率](https://leetcode.cn/problems/knight-probability-in-chessboard/)

- 解题思路

暴力递归改动态规划

- 实现代码

```java
// 暴力递归--超时
class Solution {
    int[][] dirs = new int[][]{{-1,-2},{-1,2},{1,-2},{1,2},{-2,1},{-2,-1},{2,1},{2,-1}};
    public double knightProbability(int n, int k, int row, int column) {
        return dfs(n,k,0,row, column) / Math.pow(8, k);
    }
    public double dfs(int n, int k, int step, int r, int c) {
        if (r >= n || r < 0 || c >= n || c < 0) {
            return 0;
        }
        if (step == k) {
            return 1;
        }
        return dfs(n,k, step + 1, r - 1, c - 2) + 
        dfs(n,k, step + 1, r - 1, c + 2) + 
        dfs(n,k, step + 1, r + 1, c - 2) + 
        dfs(n,k, step + 1, r + 1, c + 2) + 
        dfs(n,k, step + 1, r - 2, c - 1) + 
        dfs(n,k, step + 1, r - 2, c + 1) + 
        dfs(n,k, step + 1, r + 2, c + 1) + 
        dfs(n,k, step + 1, r + 2, c - 1);
    }
}
```

#### [leetcode_2304. 网格中的最小路径代价](https://leetcode.cn/problems/minimum-path-cost-in-a-grid/)

```java
// 动态规划
class Solution {
    public int minPathCost(int[][] grid, int[][] moveCost) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < n; i++) {
            dp[m-1][i] = grid[m-1][i];
        }
        for (int r = m-2; r >=0; r--) {
            for (int c = 0; c < n; c++) {
                dp[r][c] = Integer.MAX_VALUE;
                for (int cIdx = 0; cIdx < n;cIdx++) {
                    dp[r][c] = Math.min(dp[r][c], dp[r+1][cIdx] + moveCost[grid[r][c]][cIdx]+grid[r][c]);
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            ans = dp[0][i] < ans ? dp[0][i]: ans;
        }
        return ans;
    }
}
```

```java
// 常数优化
class Solution {
    public int minPathCost(int[][] grid, int[][] moveCost) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[m-1] = grid[m-1].clone();
        for (int r = m-2; r >=0; r--) {
            for (int c = 0; c < n; c++) {
                dp[r][c] = Integer.MAX_VALUE;
                int len;
                for (int cIdx = 0; cIdx < n;cIdx++) {
                    len = dp[r+1][cIdx] + moveCost[grid[r][c]][cIdx]+grid[r][c];
                    if (dp[r][c]>len) {
                        dp[r][c] = len;
                    }
                }
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if (dp[0][i] < ans) {
                ans = dp[0][i];
            }
        }
        return ans;
    }
}
```

#### [leetcode_808. 分汤](https://leetcode.cn/problems/soup-servings/)

```java
// 动态规划
class Solution {
    public double soupServings(int n) {
        n = (int) Math.ceil((double) n / 25);
        if (n >= 179) {return 1.0;}
        double[][] dp = new double[n+1][n+1];
        dp[0][0] = 0.5;
        for (int j = 1; j <= n; j++) {
            dp[0][j] = 1.0;
        }
        for (int i=1; i <= n; i++) {
            for (int j=1; j<=n; j++) {
                dp[i][j] = (dp[Math.max(0, i-4)][j] + dp[Math.max(0, i-3)][Math.max(0, j-1)] + dp[Math.max(0, i-2)][Math.max(0, j-2)]
                + dp[Math.max(0, i-1)][Math.max(0, j-3)]) / 4.0;
            }
        }
        return dp[n][n];
    }
}
```

```java
// 记忆化搜索
class Solution {
    double[][] memo;
    public double soupServings(int n) {
        n = (n + 24) / 25;
        if (n >= 200) {
            return 1d;
        }
        memo = new double[n + 1][n + 1];

        for (int i = 0; i < n + 1; i++) {
            Arrays.fill(memo[i], -1d);
        }
        return dfs(n, n);
    }

    /**
     * A -> i ml
     * B -> j ml
     * 的结果
     */
    double dfs(int i, int j) {
        // base case
        if (i <= 0 && j <= 0) {
            return 0.5;
        }
        if (i <= 0) {
            return 1d;
        }
        if (j <= 0) {
            return 0d;
        }
        if (memo[i][j] >= 0d) {
            return memo[i][j];
        }
        double res = (dfs(i - 4, j) + dfs(i - 3, j - 1) + dfs(i - 2, j - 2) + dfs(i - 1, j - 3)) * 0.25;
        memo[i][j] = res;
        return res;
    }
}
```

#### [leetcode_50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N >=0 ? pow(x, N) : 1.0 / pow(x, -N);
    }
    public double pow(double x, long N) {
        if (N == 0) {return 1.0;}
        double y = pow(x, N/2);
        return N % 2 == 0? y*y : y*y*x;
    }
}
```

### 滑动窗口

## [leetcode_2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/)

```java
// 区间尝试/滑动窗口 -- 以某个位置开始的情况尝试
class Solution {
    public long subArrayRanges(int[] nums) {
        int len = nums.length;
        if (len <= 0) return 0;
        long ans = 0L;
        for (int i=0; i < len; i++) {
            int min = nums[i], max = nums[i];
            for (int j=i+1; j<len;j++) {
                min = Math.min(min, nums[j]);
                max = Math.max(max, nums[j]);
                ans += max - min;
            }
        }
        return ans;
    }
}
```

```java
// 最优解 -- 单调栈 --- 计算每个位置对答案的贡献
```



#### [leetcode_904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```java
// hashmap进行计数
class Solution {
    public int totalFruit(int[] fruits) {
        Map<Integer, Integer> cnt = new HashMap<>();
        int left = 0;
        int res = 0;
        for (int right = 0; right < fruits.length; right++) {
            cnt.put(fruits[right], cnt.getOrDefault(fruits[right], 0) + 1);
            while (cnt.size() > 2) {
                cnt.put(fruits[left], cnt.get(fruits[left]) - 1);
                if (cnt.get(fruits[left]) == 0) {
                    cnt.remove(fruits[left]);
                }
                left++;
            }
            res = Math.max(res, right - left + 1);
        }
        return res;
    }
}
```

```java
// 数组计数
class Solution {
    public int totalFruit(int[] fruits) {
        int len = fruits.length;
        int left = 0;
        int res = 0;
        int clazz = 0;
        int[] set = new int[len+1];
        for (int right = 0; right < len; right++) {
            if (++set[fruits[right]] == 1) clazz++;
            while (clazz > 2) {
                if (--set[fruits[left]] == 0) {
                    clazz--;
                }
                left++;
            }
            res = Math.max(res, right - left + 1);
        }
        return res;
    }
}
```

#### [leetcode_187. 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/)

```java
// 滑动窗口+哈希表
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        List<String> res = new ArrayList<>();
        int len = s.length();
        if (len < 10 || len > 1e5) {return res;}
        HashSet<String> tmep = new HashSet<>();
        HashSet<String> set = new HashSet<>();
        for (int i = 0; i < len - 9; i++) {
            String str = s.substring(i, i+10);
            if (!tmep.add(str)) {
                set.add(str);
            }
        }
        res.addAll(set);
        return res;
    }
}
```

#### [leetcode_15. 三数之和](https://leetcode.cn/problems/3sum/)

```java
// 排序+范围内尝试
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        int len = nums.length;
        for (int k=0; k < len - 2; k++) {
            if (nums[k] > 0) break;
            if (k > 0 && nums[k] == nums[k-1]) continue;
            int i = k+1, j = len-1;
            while (i < j) {
                int sum = nums[k] + nums[i] + nums[j];
                if (sum > 0) {
                    while (i < j && nums[j] == nums[--j]);
                } else if (sum < 0) {
                    while (i < j && nums[i] == nums[++i]);
                } else {
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[k]);
                    list.add(nums[i]);
                    list.add(nums[j]);
                    ans.add(list);
                    while (i < j && nums[j] == nums[--j]);
                    while (i < j && nums[i] == nums[++i]);
                }
            }
        }
        return ans;
    }
}
```



### 数学

#### 质数

[leetcode_3115. 质数的最大距离](https://leetcode.cn/problems/maximum-prime-difference/)

```java
// 质数判断
class Solution {
    public int maximumPrimeDifference(int[] nums) {
        int len = nums.length;
        if (len <= 1) return 0;
        int left = 0, right = len-1;
        while (!isPrime(nums[left])) {
            left++;
        }
        while (!isPrime(nums[right])) {
            right--;
        }
        return right-left;
    }
    public boolean isPrime(int num) {
        if (num <= 1) return false;
        for (int i=2; i*i <= num; i++) {
            if (num % i == 0) return false;
        }
        return true;
    }
}
```



#### 快速幂

##### [leetcode_50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

```java
class Solution {
    public double myPow(double x, int n) {
        return n < 0 ? 1.0 / pow(x, -n) :  pow(x, n);
    }
    public double pow(double x, int y) {
        if (y == 0) {return 1.0;}
        double m = pow(x, y / 2);
        return (y & 1) == 0 ? m*m : m*m*x;
    }
}   
```

##### [leetcode_372. 超级次方](https://leetcode.cn/problems/super-pow/)

```java
class Solution {
    int MOD = 1337;
    public int superPow(int a, int[] b) {
        int res = 1;
        for (int i=b.length-1; i >= 0; i--) {
            res = (int)(res *(long) nPow(a, b[i]) % MOD);
            a = nPow(a, 10);
        } 
        return res;
    }
    public int nPow(int x, int y) {
        int n = 1;
        while (y != 0) {
            if ((y & 1) == 1) {
                n = (int)((long) n*x % MOD);
            }
            x = (int) ((long)x * x % MOD); // 乘法先用long保存防止溢出
            y = y >> 1;
        }
        return n;
    }
}
```



## B、牛客网

## C、coding技巧

### 向上/向下取整

```java
//相除向上取整
 t += (num - 1) / numM + 1;
```

## D、题目分类列表

### 1.排序题目

#### [leetcode_75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

#### [leetcode_215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)



# Hot 100

## 贪心算法

### [leetcode_763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

```java
// 以字母最后出现的位置为划分点
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        for (int i=0; i < s.length(); i++) {
            last[s.charAt(i)-'a'] = i;
        }
        List<Integer> ans = new ArrayList<>();
        int start = 0, end = 0;
        for (int i=0; i < s.length(); i++) {
            end = Math.max(end, last[s.charAt(i)-'a']);
            if (i==end) {
                ans.add(end-start+1);
                start = end+1;
            }
        }
        return ans;
    }
}
```



## 数学

### [leetcode_136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

```java
// 异或运算
class Solution {
    public int singleNumber(int[] nums) {
        int ans=0;
        for (int num: nums) {
            ans ^= num;
        }
        return ans;
    }
}
```

### [leetcode_31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if (len <= 1) return;
        int i=len-2, j=len-1, k=len-1;
        while (i >=0 && nums[i] >= nums[j]) {
            i--;j--;
        }
        if (i >= 0) { // 不是最后的排列
            while (nums[i] >= nums[k]) k--;
            swap(nums, i, k);
        }
        // 调整为升序
        for (int idx1=j, idx2=len-1; idx1<idx2; idx1++,idx2--) {
            swap(nums, idx1, idx2);
        }
    }
    public void swap(int[] nums, int idx1, int idx2) {
        int temp = nums[idx2];
        nums[idx2] = nums[idx1];
        nums[idx1] = temp;
    }
}
```

## 队列

### [leetcode_994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

```java
// 深度优先遍历 -- 队列
class Solution {
    public int orangesRotting(int[][] grid) {
        int rLen = grid.length;
        int cLen = grid[0].length;
        ArrayDeque<int[]> badOranges = new ArrayDeque<>();
        int cntNew = 0;
        for (int i=0; i < rLen; i++) {
            for (int j=0; j < cLen; j++) {
                if (grid[i][j] == 1) cntNew++;
                if (grid[i][j] == 2) {
                    badOranges.offer(new int[]{i, j});
                }
            }
        }
        int ans = 0;
        while (cntNew > 0 && !badOranges.isEmpty()) {
            ans++;
            int n=badOranges.size();
            for (int i=0; i < n; i++) {
                int[] badOrange = badOranges.poll();
                int r = badOrange[0];
                int c = badOrange[1];
                if (r - 1 >= 0 && grid[r - 1][c] == 1) {
                    grid[r - 1][c] = 2;
                    cntNew--;
                    badOranges.offer(new int[]{r-1, c});
                }
                if (r + 1 < rLen && grid[r + 1][c] == 1) {
                    grid[r + 1][c] = 2;
                    cntNew--;
                    badOranges.offer(new int[]{r+1, c});
                }
                if (c - 1 >= 0 && grid[r][c - 1] == 1) {
                    grid[r][c - 1] = 2;
                    cntNew--;
                    badOranges.offer(new int[]{r, c-1});
                }
                if (c + 1 < cLen && grid[r][c + 1] == 1) {
                    grid[r][c + 1] = 2;
                    cntNew--;
                    badOranges.offer(new int[]{r, c+1});
                }
            }
        }
        if (cntNew > 0) return -1;
        else return ans;
    }
}
```



## 栈

### [leetcode_739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

```java
// 单调栈
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        for (int i=0; i < len; i++) {
            if (stack.isEmpty() || temperatures[stack.peek()] >= temperatures[i]) {
                stack.push(i);
            } else {
                while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                    int idx = stack.pop();
                    ans[idx] = i-idx;
                }
                stack.push(i);
            }
        }
        // while (!stack.isEmpty()) {
        //     int idx = stack.pop();
        //     ans[idx] = 0;
        // }
        return ans;
    }
}
```

```java
// 单调栈代码优化
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        for (int i=0; i < len; i++) {
            while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                int idx = stack.pop();
                ans[idx] = i-idx;
            }
            stack.push(i);
        }
        return ans;
    }
}
```

### [leetcode_394. 字符串解码](https://leetcode.cn/problems/decode-string/)

```java
// 辅助栈过程模拟
class Solution {
    public String decodeString(String s) {
        ArrayDeque<Integer> times = new ArrayDeque<>();
        ArrayDeque<String> strs = new ArrayDeque<>();
        char[] strArr = s.toCharArray();
        int nums = 0;
        StringBuilder sb = new StringBuilder();
        for (char c: strArr) {
            if (c == '[') {
                times.push(nums);
                nums=0;
                strs.push(sb.toString());
                sb = new StringBuilder();
            } else if (c == ']') {
                StringBuilder temp = new StringBuilder();
                int curTime = times.pop();
                for (int i=0; i < curTime; i++) temp.append(sb);
                sb = new StringBuilder(strs.pop() + temp);
            } else if (c >= '0' && c <= '9') nums = nums * 10 + Integer.parseInt(c + "");
            else sb.append(c);
        }
        return sb.toString();
    }
}
```



## 二分法

### [leetcode_33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```java
// 二分法 + 分类讨论 
class Solution {
    public int search(int[] nums, int target) {
        int len = nums.length;
        if (len == 1) return nums[0] == target? 0: -1;
        int l=0, r = len-1;
        while (l <= r) {
            int mid = l + (r-l)/2;
            if (nums[mid] == target) return mid;
            // 分类讨论mid和target的位置
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[len-1] >= target && target > nums[mid]) {
                    l=mid + 1;
                } else {
                    r = mid-1;
                }
            }
        }
        return -1;
    }
}
```

### [leetcode_153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

```java
// 二分查找
class Solution {
    public int findMin(int[] nums) {
        int len = nums.length;
        int l = 0, r = len-1;
        while (l < r) {
            int mid = l + (r-l)/2;
            if (nums[mid] < nums[r]) {
                r = mid;
            } else {
                l = mid+1;
            }
        }
        return nums[l];
    }
}
```



## 缓存

### [leetcode_460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

```java
class LFUCache {
    Map<Integer, Node> cache;
    Map<Integer, LinkedList<Node>> freqMap;
    int capacity;
    int size = 0;
    int min;

    public LFUCache(int capacity) {
        cache = new HashMap<>();
        freqMap = new HashMap<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        Node curNode = cache.get(key);
        if (curNode == null) return -1;
        freqIncrease(curNode);
        return curNode.val;
    }
    void freqIncrease(Node node) {
        LinkedList<Node> list = freqMap.get(node.freq);
        list.remove(node);
        if (list.size() == 0 && node.freq == min) min++;
        node.freq++;
        LinkedList<Node> listp = freqMap.get(node.freq);
        if (listp == null) {
            listp = new LinkedList<>();
            freqMap.put(node.freq, listp);
        }
        listp.addFirst(node);
    }
    
    public void put(int key, int value) {
        if (capacity == 0) return;
        Node curNode = cache.get(key);
        if (curNode != null) {
            curNode.val = value;
            freqIncrease(curNode);
        } else {
            if (capacity == size) {
                LinkedList<Node> minList = freqMap.get(min);
                cache.remove(minList.removeLast().key);
                size--;
            }
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            LinkedList<Node> list1 = freqMap.get(1);
            if (list1 == null) {
                list1 = new LinkedList<>();
                freqMap.put(1, list1);
            }
            list1.addFirst(newNode);
            min=1;
            size++;
        }

    }
    class Node{
        int key;
        int val;
        int freq = 1;
        Node(){};
        Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
}
```



### [leetcode_146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

```java
// hashmap + 手写双端队列
class LRUCache {
    class LinkedNode {
        int key;
        int val;
        LinkedNode prev;
        LinkedNode next;
        LinkedNode(){};
        LinkedNode(int key, int val){
            this.key = key;
            this.val = val;
        };
    }
    private Map<Integer, LinkedNode> map = new HashMap<>();
    private int size;
    private int capacity;
    private LinkedNode head, tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        head = new LinkedNode();
        tail = new LinkedNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        LinkedNode node =  map.get(key);
        if (node == null) return -1;
        moveTohead(node);
        return node.val;
    }
    
    public void put(int key, int value) {
        if (!map.containsKey(key)) {
            LinkedNode curNode = new LinkedNode(key, value);
            map.put(key, curNode);
            addToHead(curNode);
            size++;
            if (size > capacity) {
                LinkedNode last = removeTail();
                map.remove(last.key);
                size--;
            }
        } else {
            LinkedNode curNode = map.get(key);
            curNode.val = value;
            moveTohead(curNode);
        }
    }
    public LinkedNode removeNode(LinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        node.prev = null;
        node.next = null;
        return node;
    }
    public void addToHead(LinkedNode node) {
        node.next = head.next;
        head.next.prev = node;
        node.prev = head;
        head.next = node;
    }
    public LinkedNode removeTail() {
        return removeNode(tail.prev);
    }
    public LinkedNode moveTohead(LinkedNode node) {
        removeNode(node);
        addToHead(node);
        return node;
    }
}
```



## 子串

### [leetcode_209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```java
// 滑动窗口
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int len = nums.length;
        if (len <= 0) return 0;
        int l = 0, r = 0, sum = 0;
        int ans = Integer.MAX_VALUE;
        while (r < len) {
            sum += nums[r];
            while(l <= r && sum >= target) {
                ans = Math.min(ans, r - l + 1);
                sum -= nums[l];
                l++;
            }
            r++;
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
```



### [leetcode_76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```java
class Solution {
    public String minWindow(String s, String t) {
        char[] sArr = s.toCharArray();
        char[] tArr = t.toCharArray();
        int sLen = sArr.length;
        int tLen = tArr.length;
        if (tLen > sLen || tLen <= 0) return "";
        int[] sCnt = new int[128];
        int[] tCnt = new int[128];
        for (int i = 0; i < tLen; i++) {
            tCnt[tArr[i] - 'A']++;
        }
        int l=0, r = 0;
        int ansL = -1, ansR = sLen;
        while (r < sLen) {
            sCnt[sArr[r]-'A']++;
            while(l <= r && check(sCnt, tCnt)) {
                if (r - l < ansR - ansL) {
                    ansR = r;
                    ansL = l;
                };
                sCnt[sArr[l]-'A']--;
                l++;
            }
            r++;
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR+1);
    }
    public boolean check(int[] sCnt, int[] tCnt) {
        int sub = 0;
        for (int i=0; i < sCnt.length; i++) {
            sub = sCnt[i] - tCnt[i];
            if (sub < 0) return false;
        }
        return true;
    }
}
```

## 链表

### [leetcode_19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```java
// 长度遍历
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode first = new ListNode();
        first.next = head;
        int len = 0;
        ListNode cur = first;
        while (cur.next != null) {
            cur = cur.next;
            len++;
        }
        if (len == 1) return head = null;
        cur = first;
        for (int i = 0; i < len-n; i++) cur = cur.next;
        remove(cur.next, cur);
        return first.next;
    }
    public void remove(ListNode node, ListNode pre) {
        pre.next = node.next;
        node.next = null;
    }
}
```

```java
// 双指针
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode first = new ListNode();
        first.next = head;
        ListNode A = first;
        ListNode B = first;
        int cnt = 0;
        while (A.next != null) {
            A = A.next;
            if (cnt >= n) B = B.next;
            else cnt++;
        }
        remove(B.next, B);
        return first.next;
    }
    public void remove(ListNode node, ListNode pre) {
        pre.next = node.next;
        node.next = null;
    }
}
```

### [leetcode_24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```java
// 过程模拟
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null) return head;
        ListNode frist = new ListNode();
        frist.next = head;
        ListNode pre = frist;
        while (pre.next != null && pre.next.next != null) {
            ListNode cur = pre.next;
            ListNode curNxt = pre.next.next; 
            pre.next = curNxt;
            cur.next = curNxt.next;
            curNxt.next = cur;
            pre = cur;
        }
        return frist.next;
    }
}
```

```java
// 递归 -- 太优秀了
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode newHead = head.next;
        head.next = swapPairs(newHead.next);
        newHead.next = head;
        return newHead;
    }
}
```

### [leetcode_23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```java
// 两两合并 -- 归并
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) {
            return null;
        }
        int k = lists.length;
        while (k > 1) {
            int idx = 0;
            for (int i = 0; i < k; i += 2) {
                if (i == k - 1) {
                    lists[idx++] = lists[i];
                } else {
                    lists[idx++] = mix(lists[i], lists[i + 1]);
                }
            }
            k = idx;
        }
        return lists[0];
    }

    public ListNode mix(ListNode head1, ListNode head2) {
        if (head1 == null && head2 == null) return null;
        else if (head1 == null) return head2;
        else if (head2 == null) return head1;
        ListNode first =  new ListNode();
        ListNode tail = first;
        while (head1 != null && head2 != null) {
            if (head1.val < head2.val) {
                tail.next = head1;
                head1 = head1.next;
            } else {
                tail.next = head2;
                head2 = head2.next;
            }
            tail = tail.next;
        }
        if (head1 == null) {
            tail.next = head2;
        } else {
            tail.next = head1;
        }
        return first.next;
    }
}
```

## [leetcode_82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```java
// 过程模拟
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode first = new ListNode(-101);
        first.next = head;
        ListNode pre = first, cur = first.next;
        while (cur != null) {
            if (cur.next != null && cur.next.val == cur.val) {
                while (cur.next != null && cur.next.val == cur.val) {
                            cur = cur.next;
                        }
                        pre.next = cur.next;
                        cur.next = null;
                        cur = pre.next;
            } else {
                pre = pre.next;
                cur = cur.next;
                
            }
        }
        return first.next;
    }
```



## 二叉树

### [leetcode_101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```java
// 深度优先遍历 -- 对称比较
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return dfs(root.left, root.right);
    }
    public boolean dfs(TreeNode r1, TreeNode r2) {
        if (r1 == null && r2 == null) return true;
        if (r1 == null || r2 == null || r1.val != r2.val) return false;
        return dfs(r1.right, r2.left) && dfs(r1.left, r2.right);
    }
}
```

### [leetcode_437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

```java
// 递归 --- 中间不能有间隙 - 不能空格
class Solution {
    int targetSum=0;
    int ans = 0;
    public int pathSum(TreeNode root, int targetSum) {
        this.targetSum = targetSum;
        dfs1(root);
        return ans;
    }
    public void dfs1(TreeNode node){
        if (node == null) return;
        dfs2(node, node.val);
        dfs1(node.left);
        dfs1(node.right);

    }
    public void dfs2(TreeNode node, long cur) {
        if (cur == targetSum) ans++;
        if (node.right != null) dfs2(node.right, cur+node.right.val);
        if (node.left != null) dfs2(node.left, cur+node.left.val);
    } 
}
```

```java
// 前缀和
class Solution {
    int targetSum=0;
    int ans = 0;
    public int pathSum(TreeNode root, int targetSum) {
        this.targetSum = targetSum;
        Map<Long, Integer> record = new HashMap<>();
        record.put(0L, 1);
        return dfs(root, record, 0L);
    }
    public int dfs(TreeNode node,  Map<Long, Integer> record,long cur) {
        if (node == null) return 0;
        int res = 0;
        cur += node.val;
        res += record.getOrDefault(cur - targetSum, 0);
        record.put(cur, record.getOrDefault(cur, 0) + 1);
        res += dfs(node.left, record, cur);
        res += dfs(node.right, record, cur);
        record.put(cur, record.get(cur) - 1);
        return res;
    }
}
```

### [leetcode_124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

```java
// 向左右树拿信息，分为连接和不连接
// 原始思想
class Solution {
    int max = -2000;
    public int maxPathSum(TreeNode root) {
       int[] ans = dfs(root);
       return Math.max(Math.max(ans[0], ans[1]), max);
    }
    public int[] dfs(TreeNode root) {
        if (root == null) return new int[]{-2000, -2000}; // 连 不练
        int[] left = dfs(root.left);
        int[] right = dfs(root.right);
        int con = Math.max(Math.max(left[0] + root.val, right[0] + root.val), root.val);
        int noCon = Math.max(Math.max(left[1], right[1]), right[0] + left[0] + root.val);
        max = Math.max(Math.max(con, noCon), max);
        return new int[]{con, noCon};
    }
}
```

```java
// 优化，不连接的情况只有记录，不用向上传递
class Solution {
    int max = -2000;
    public int maxPathSum(TreeNode root) {
       dfs(root);
       return max;
    }
    public int dfs(TreeNode root) {
        if (root == null) return -2000; 
        int left = dfs(root.left);
        int right = dfs(root.right);
        int con = Math.max(Math.max(left + root.val, right + root.val), root.val);
        int noCon = Math.max(Math.max(left, right), right + left + root.val);
        max = Math.max(Math.max(con, noCon), max);
        return con;
    }
}
```



# 面试经典150题

## 位运算

```java
// 两个数组的公共前缀
class Solution {
    public int rangeBitwiseAnd(int left, int right) {
        int bit = 0;
        while (left < right) {
            left = left >> 1;
            right = right >> 1;
            bit++;
        }
        return left << bit;
    }
}
```



## 链表

### [leetcode_61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

```java
// 遍历长度
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (k == 0 || head == null) return head;
        int len = 0;
        ListNode h = head;
        while (h != null) {
            len++;
            h=h.next;
        }
        k = k % len;
        if (k == 0) return head;
        ListNode zero = new ListNode(0);
        zero.next = head;
        ListNode reHead = null;
        ListNode kLast = zero;
        for (int i=0; i < len-k; i++) {
            kLast = kLast.next;
        }
        reHead = kLast.next;
        ListNode kkLast = kLast;
        for (int i=0;i < k; i++) {
            kkLast = kkLast.next;
        }
        kLast.next = null;
        kkLast.next = head;
        zero.next = null;
        return reHead;
    }
}
```

```java
// 环 -- 分割环
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (k == 0 || head == null || head.next == null) return head;
        int len = 1;
        ListNode last = head;
        while (last.next != null) {
            len++;
            last=last.next;
        }
        k = k % len;
        if (k == 0) return head;
        last.next = head;
        ListNode nowHead = head;
        for (int i=0; i < len-k;i++) {
            last = last.next;
            nowHead = nowHead.next;
        }
        last.next = null;
        return nowHead;
    }
}
```

### [leetcode_25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode prev = new ListNode();
        prev.next = head;
        ListNode first = prev;
        int cnt = 0;
        while (cnt < k && first != null) {
            cnt++;
            first = first.next;
        }
        ListNode second = prev;
        while (first != null) {
            if (cnt % k == 0) {
                ListNode oldHead = second.next;
                ListNode oldNext = first.next;
                second.next = null;
                first.next = null;
                ListNode[] newChain = reverse(oldHead);
                second.next = newChain[0];
                newChain[1].next = oldNext;
                first = newChain[1];
            }
            cnt++;
            first = first.next;
            second = second.next;
        }
        return prev.next;
    }
    public ListNode[] reverse(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode nxt = null;
        while (cur != null) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        return new ListNode[]{pre, head};
    }
}
```



## 数组

### [leetcode_88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

```java
// 额外空间O(1)
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        if (n < 1) return;
        int p1=m-1, p2=n-1;
        int tail = m+n-1;
        while (p1 >= 0 || p2 >= 0) {
            if (p1 == -1) {
                nums1[tail--] = nums2[p2--];
            } else if (p2 == -1) {
                nums1[tail--] = nums1[p1--];
            } else if (nums1[p1] > nums2[p2]) {
                nums1[tail--] = nums1[p1--];
            } else {
                nums1[tail--] = nums2[p2--];
            }
        }
    }
}
```

### [leetcode_151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
         s = s.trim(); 
        char[] cs = s.toCharArray();
        StringBuilder ans = new StringBuilder();
        int i = cs.length-1, j = i;
        while (i >= 0) {
            while (i >= 0 && cs[i] != ' ') i--;
            ans.append(s.substring(i+1, j+1) + " ");
            while (i >= 0 && cs[i] == ' ') i--;
            j=i;
        }
        return ans.toString().trim();
    }
}
```

### [leetcode_27. 移除元素](https://leetcode.cn/problems/remove-element/)

```java
// 双指针
class Solution {
    public int removeElement(int[] nums, int val) {
        int len = nums.length;
        int l = 0, r = len-1;
        while (l <= r) {
            if (nums[l] != val) {
                l++;
            } else {
                swap(nums, l, r--);
            }
        }
        return r+1;
    }
    public void swap(int[] nums, int idx1, int idx2) {
        int temp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = temp;
    }
}
```

### [leetcode_6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)

```java
// 数学规律
class Solution {
    public String convert(String s, int numRows) {
        if (numRows == 1) return s;
        int len = s.length();
        StringBuilder sb = new StringBuilder();
        for (int r = 1; r <= numRows; r++) {
            if (r == 1 || r == numRows) {
                for (int i=r-1; i < len;) {
                    sb.append(s.charAt(i));
                    i += (numRows-1)*2;
                }
            } else {
                boolean down = true;
                for (int i=r-1; i < len;) {
                    sb.append(s.charAt(i));
                    if (down) {
                        i += (numRows-r)*2;
                        down = !down;
                    } else {
                        i += (r-1) * 2;
                        down = !down;
                    }
                }
            }
        }
        return sb.toString();
    }
}
```

```java
// 代码优化
```

### [leetcode_169. 多数元素](https://leetcode.cn/problems/majority-element/)

```java
// 摩尔投票
class Solution {
    public int majorityElement(int[] nums) {
        int x=0, votes = 0;
        for (int num: nums) {
            if (votes == 0) x = num;
            votes += num == x ? 1: -1;
        }
        return x;
    }
}
```

### [leetcode_274. H 指数](https://leetcode.cn/problems/h-index/)

```java
// 排序 -- 空间复杂度 O(1)
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int h = 0, i=citations.length-1;
        while (i >= 0 && citations[i] > h) {
            i--;h++;
        }
        return h;
    }
}
```

```java
// 计数排序 -- 时间复杂度/空间复杂度 O(n)
class Solution {
    public int hIndex(int[] citations) {
        int len = citations.length;
        int[] cnt = new int[len + 1];
        for (int i=0; i < len; i++) {
            if (citations[i] > len) {
                cnt[len]++;
            } else {
                cnt[citations[i]]++;
            }
        }
        int sum = 0;
        for (int i=len; i >= 0; i--) {
            sum += cnt[i];
            if (sum >= i) {
                return i;
            }
        }
        return 0;
    }
}
```

### [leetcode_13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)

```java
// 前一个数比后一个数小就减去这个数
class Solution {
    public int romanToInt(String s) {
        int preNum = cV(s.charAt(0));
        int ans = 0;
        for (int i=1; i < s.length(); i++) {
            int cur = cV(s.charAt(i));
            if (preNum < cur) {
                ans -= preNum;
            } else {
                ans += preNum;
            }
            preNum = cur;
        }
        return ans + preNum;
    }
    public int cV(char c) {
        switch(c){
            case 'I':
                return 1;
            case 'V':
                return 5;
            case 'X':
                return 10;
            case 'L':
                return 50;
            case 'C':
                return 100;
            case 'D':
                return 500;
            case 'M':
                return 1000;
            default:
                return 0;
        }
    }
}
```

### [leetcode_12. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)

```java
class Solution {
    public String intToRoman(int num) {
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        StringBuilder sb = new StringBuilder();
        for (int i=0; i < values.length; i++) {
            while (num >= values[i]) {
                num -= values[i];
                sb.append(symbols[i]);
            }
            if (num == 0) break;
        }
        return sb.toString();
    }
}
```

### [leetcode_58. 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/)

```java
class Solution {
    public int lengthOfLastWord(String s) {
        char[] cs = s.toCharArray();
        int r = cs.length - 1;
        while (r >= 0 && cs[r] == ' ') r--;
        int ans = 0;
        while (r >=0 && cs[r] != ' ') {
            ans++;r--;
        }
        return ans;
    }
}
```

### [leetcode_380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

```java
class RandomizedSet {
    List<Integer> nums;
    Map<Integer, Integer> map;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<>();
        map = new HashMap<>();
        random = new Random();
    }
    
    public boolean insert(int val) {
        if (map.containsKey(val)) return false;
        int idx = nums.size();
        nums.add(val);
        map.put(val, idx);
        return true;
    }
    
    public boolean remove(int val) {
        if (!map.containsKey(val)) return false;
        int idx = map.get(val);
        int last = nums.get(nums.size()-1);
        nums.set(idx, last);
        nums.remove(nums.size()-1);
        map.put(last, idx);
        map.remove(val);
        return true;
    }
    
    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);
    }
}
```

### [leetcode_41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

```java
// 原地hash
class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        if (len == 1) return nums[0] == 1 ? 2 : 1;
        for (int i=0; i < len; i++) {
            while (nums[i] > 0 && nums[i] <= len && nums[i] != nums[nums[i]-1]) {
                swap(nums, i, nums[i]-1);
            }
        }
        for (int i=0; i < len; i++) {
            if (nums[i]-1 != i) return i+1;
        }
        return len+1;
    }
    public void swap(int[] nums, int idx1, int idx2) {
        int temp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = temp;
    }
}
```

### [leetcode_918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

```java
// 最大子数组和最小子数组 组合判断 (kadane 方法)
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int len = nums.length;
        int preMin = 0, preMax = 0, sumNums = 0, maxNums = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for (int num: nums) {
            sumNums += num;
            maxNums = Math.max(maxNums, num);
            preMax = Math.max(preMax + num, num);
            max = Math.max(preMax, max);
            preMin = Math.min(preMin + num, num);
            min = Math.min(preMin, min);
        }
        return Math.max(max, sumNums - min == 0 ? maxNums: sumNums - min);
    }
}
```

```java
// 
```



### 股票问题

#### [leetcode_121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```java
// 单次遍历数组 + 常数变量
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2) return 0;
        int min = prices[0];
        int ans = 0;
        for (int num: prices) {
            min = Math.min(min, num);
            ans = Math.max(ans, num - min);
        }
        return ans;
    }
}
```

#### [leetcode_122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```java
// 暴力递归 -- 超时
class Solution {
    public int maxProfit(int[] prices) {
        return dfs(prices, false, 0, 0);
    }
    public int dfs(int[] prices, boolean hasStock, int idx, int res) {
        if (idx == prices.length) return res;
        if (hasStock) { // 有股票
            return Math.max(dfs(prices, hasStock, idx + 1, res), dfs(prices, !hasStock, idx + 1, res + prices[idx]));
        } else { // 无股票
            return Math.max(dfs(prices, hasStock, idx + 1, res), dfs(prices, !hasStock, idx + 1, res - prices[idx]));
        }
    }
}
```

```java
// 动态规划
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[2][len];
        dp[0][0] = 0;dp[1][0] = -prices[0];
        for (int i=1; i<len; i++) {
            dp[0][i] = Math.max(dp[0][i-1], dp[1][i-1] + prices[i]);
            dp[1][i] = Math.max(dp[1][i-1], dp[0][i-1] - prices[i]);
        }
        return dp[0][len-1];
    }
}
```

```java
// 动态规划 -- 空间压缩
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int a = 0;int b = -prices[0];
        for (int i=1; i<len; i++) {
            int tempA = Math.max(a, b + prices[i]);
            int tempB = Math.max(b, a - prices[i]);
            a = tempA;
            b = tempB;
        }
        return a;
    }
}
```

```java
/** 
贪心 -- 差分优化
参考题解：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/38498/tan-xin-suan-fa-by-liweiwei1419-2/?envType=study-plan-v2&envId=top-interview-150
*/
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        for (int i=1; i < prices.length; i++) {
            int diff = prices[i] - prices[i-1];
            if (diff > 0) ans += diff;
        }
        return ans;
    }
}
```

#### [leetcode_123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

```java
// 暴力递归 -- 超时
class Solution {
    public int maxProfit(int[] prices) {
        return dfs(prices, 0, false, 0, 0);
    }
    public int dfs(int[] prices, int cur, boolean has, int idx, int times) {
        if (times == 2) return cur;
        if (idx == prices.length) return cur;
        if (has) {
            return Math.max(dfs(prices, cur, has, idx + 1, times), dfs(prices, cur + prices[idx], !has, idx + 1, times + 1));
        } else {
            return Math.max(dfs(prices, cur, has, idx + 1, times), dfs(prices, cur - prices[idx], !has, idx + 1, times));
        }
    }
}
```

```java
// 三维动态规划
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][][] dp = new int[3][2][len];// times has idx
        dp[1][1][0] = -prices[0];
        dp[2][1][0] = Integer.MIN_VALUE; // 影响第4种情况
        for (int i=1; i < len; i++) {
            dp[1][1][i] = Math.max(dp[1][1][i-1], -prices[i]); // 第一次操作 持股
            dp[1][0][i] = Math.max(dp[1][0][i-1], dp[1][1][i-1] + prices[i]);// 第一次操作 不持股
            dp[2][1][i] = Math.max(dp[2][1][i-1], dp[1][0][i-1] - prices[i]);// 第二次操作 持股
            dp[2][0][i] = Math.max(dp[2][0][i-1], dp[2][1][i-1] + prices[i]);// 第二次操作 不持股
        }
        return Math.max(dp[1][0][len-1], dp[2][0][len-1]);
    }
}
```

```java
// 官方题解 -- 
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length == 0) {
            return 0;
        }

        int n = prices.length;
        k = Math.min(k, n / 2);
        int[][] buy = new int[n][k + 1];
        int[][] sell = new int[n][k + 1];

        buy[0][0] = -prices[0];
        sell[0][0] = 0;
        for (int i = 1; i <= k; ++i) {
            buy[0][i] = sell[0][i] = Integer.MIN_VALUE / 2;
        }

        for (int i = 1; i < n; ++i) {
            buy[i][0] = Math.max(buy[i - 1][0], sell[i - 1][0] - prices[i]);
            for (int j = 1; j <= k; ++j) {
                buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j] - prices[i]);
                sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);   
            }
        }
        return Arrays.stream(sell[n - 1]).max().getAsInt();
    }
}
```

#### [leetcode_188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

```java
// 动态规划
class Solution {
    public int maxProfit(int k, int[] prices) {
        int len = prices.length;
        if(k == 0 || len < 2) return 0;
        int[][][] dp = new int[k+1][2][len];// times has idx
        for (int j = 1; j <= k; ++j) {
            dp[j][1][0] = -prices[0];
        }
        for (int i=1; i < len; i++) {
            for (int j=1;j<=k;j++) {
                dp[j][1][i] = Math.max(dp[j][1][i-1], dp[j-1][0][i-1] - prices[i]);// 持股
                dp[j][0][i] = Math.max(dp[j][0][i-1], dp[j][1][i-1] + prices[i]);// 不持股
            }
        }
        return dp[k][0][len-1];
    }
}
```

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length == 0) {
            return 0;
        }

        int n = prices.length;
        k = Math.min(k, n / 2);
        int[][] buy = new int[n][k + 1];
        int[][] sell = new int[n][k + 1];

        buy[0][0] = -prices[0];
        sell[0][0] = 0;
        for (int i = 1; i <= k; ++i) {
            buy[0][i] = sell[0][i] = Integer.MIN_VALUE / 2;
        }

        for (int i = 1; i < n; ++i) {
            buy[i][0] = Math.max(buy[i - 1][0], sell[i - 1][0] - prices[i]);
            for (int j = 1; j <= k; ++j) {
                buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j] - prices[i]);
                sell[i][j] = Math.max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);   
            }
        }

        return Arrays.stream(sell[n - 1]).max().getAsInt();
    }
}
```



## 双指针

### [leetcode_167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```java
// 二分法
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        for(int i=0; i < numbers.length; i++) {
            int l = i+1, r = numbers.length - 1;
            while (l <= r) {
                int mid = (r-l) / 2 + l;
                if (numbers[i] + numbers[mid] == target) {
                    return new int[]{i+1, mid+1};
                } else if (numbers[mid] > target - numbers[i]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
        }
        return null;
    }
}
```

```java
// 双指针
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length-1;
        while (l < r) {
             if (numbers[l] + numbers[r] == target) {
                    return new int[]{l+1, r+1};
                } else if (numbers[r] > target - numbers[l]) {
                    r--;
                } else {
                    l++;
                }
        }
        return new int[]{-1, -1};
    }
}
```

### [leetcode_125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

```java
class Solution {
    public boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length()-1;
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) left++;
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) right--;
            if (left < right) {
                if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
                    return false;
                }
                left++;
                right--;
            }
        }
        return true;
    }
}
```

### [leetcode_92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left == right) return head;
        // 使用虚拟0节点避免分类讨论 -- 因为头节点可能被调整
        ListNode zero = new ListNode(0);
        zero.next = head;
        ListNode leftLast = zero;
        for (int i=0; i < left-1; i++) {
            leftLast = leftLast.next;
        }
        ListNode r = leftLast;
        for (int i=0; i < right - (left-1); i++) {
            r = r.next;
        }
        ListNode l = leftLast.next;
        ListNode rightNext = r.next;
        leftLast.next = null;
        r.next = null;
        ListNode newHead = reverse(l);
        leftLast.next = newHead;
        l.next = rightNext;
        return zero.next; 
    }
    public ListNode reverse(ListNode head) {
        ListNode pre = null, next = null;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```

```java
// 单次遍历
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left == right) return head;
        // 使用虚拟0节点避免分类讨论 -- 因为头节点可能被调整
        ListNode zero = new ListNode(0);
        zero.next = head;
        ListNode leftLast = zero;
        for (int i=0; i < left-1; i++) {
            leftLast = leftLast.next;
        }
        ListNode pre = null, cur = leftLast.next;
        for (int i=0; i < right - left + 1; i++) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        leftLast.next.next = cur;
        leftLast.next = pre;
        return zero.next;
    }
}
```



## 哈希表

### [leetcode_49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```jav
// hash表 + 排序
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str: strs) {
            char[] cs = str.toCharArray();
            Arrays.sort(cs);
            String key = new String(cs);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            map.put(key, list);
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

## 动态规划

### [leetcode_139. 单词拆分](https://leetcode.cn/problems/word-break/)

```java
// 动态规划
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        int len = s.length();
        for (String str: wordDict) {
            set.add(str);
        }
        boolean[] dp = new boolean[len + 1];
        dp[0] = true;
        for (int i=1; i <= len; i++) {
            for (int j=1; j <= i && !dp[i]; j++) {
                String sub = s.substring(j-1, i);
                if (set.contains(sub)) {
                    dp[i] = dp[j-1];
                }
            }
        }
        return dp[len];
    }
}
```

### [leetcode_120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int len = triangle.size();
        int[][] dp = new int[len][len];
        dp[0][0] = triangle.get(0).get(0);
        if (len <= 1) return dp[0][0];
        for (int i=1; i < len; i++) {
            dp[i][0] = dp[i-1][0] + triangle.get(i).get(0);
            for (int j=1; j < i; j++) {
                dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + triangle.get(i).get(j);
            }
            dp[i][i] = dp[i-1][i-1]+ triangle.get(i).get(i);
        }
        int ans = dp[len-1][0];
        for (int num: dp[len-1]) {
            ans = Math.min(ans, num);
        }
        return ans;
    }
}
```

### [leetcode_63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

```java
// 二维dp
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int r = obstacleGrid.length;
        int c = obstacleGrid[0].length;
        int[][] dp = new int[r+1][c+1];
        dp[r-1][c] = 1; // dp[r-1][c-1] = 1
        for (int i=r-1; i >= 0; i--) {
            for (int j=c-1; j >= 0; j--) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i+1][j] + dp[i][j+1];
                }
            }
        }
        // System.out.print(Arrays.toString(dp[r-1]));
        return dp[0][0];
    }
}
```

```java
// dp降维
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int r = obstacleGrid.length;
        int c = obstacleGrid[0].length;
        int[] dp = new int[c+1];
        dp[c-1] = 1;
        for (int i=r-1; i >= 0; i--) {
            for (int j=c-1; j >= 0; j--) {
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else {
                    dp[j] += dp[j+1];
                }
            }
        }
        return dp[0];
    }
}
```

### [leetcode_221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

```java
// 动态规划 -- 正方形的动态转移方程
class Solution {
    public int maximalSquare(char[][] matrix) {
        int maxSide = 0;
        int c=matrix.length, r = matrix[0].length;
        int[][] dp = new int[c+1][r+1];
        for (int i = 1; i <= c; i++) {
            for (int j = 1; j <= r; j++) {
                if (matrix[i-1][j-1] == '1') {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
                maxSide = Math.max(maxSide, dp[i][j]);
            }
        }
        return maxSide * maxSide;
    }
}
```

### [leetcode_1277. 统计全为 1 的正方形子矩阵](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/)

```java
// 动态规划
class Solution {
    public int countSquares(int[][] matrix) {
        int r = matrix.length, c = matrix[0].length;
        int ans = 0;
        int[][] dp = new int[r+1][c+1];
        for (int i=1; i <= r; i++) {
            for (int j=1; j <= c; j++) {
                if (matrix[i-1][j-1] == 1) {
                    dp[i][j] =Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                } else {
                    dp[i][j] = 0;
                }
                ans += dp[i][j];
            }
        }
        return ans;
    }
}
```

### [leetcode_403. 青蛙过河](https://leetcode.cn/problems/frog-jump/)

```java
// 暴力递归
class Solution {
    int len;
    Map<Integer, Integer> map;
    public boolean canCross(int[] stones) {
        len = stones.length;
        if (len >= 2 && stones[1] != 1) return false;
        map = new HashMap<>();
        for (int i=0; i < len; i++) {
            map.put(stones[i], i);
        }
        return dfs(stones,1,1);
    }
    public boolean dfs(int[] stones, int step, int idx) {
        // 能跳上的情况
        if (idx == stones.length-1) return true;
        for (int s = step-1; s <= step+1; s++) {
            if (s == 0) continue;
            int next = stones[idx] + s;
            if (map.containsKey(next)) {
                boolean pass = dfs(stones, s, map.get(next));
                if (pass) return true;
            }
        }
        return false;
    }
}
```

```java
// 动态规划
// 核心思路确定step 和 idx 的转移 step和idx/lastIdx有关
class Solution {
    public boolean canCross(int[] stones) {
        int len = stones.length;
        if (len >= 2 && stones[1] != 1) return false;
        boolean[][] dp = new boolean[len][len]; // idx step
        dp[1][1] = true;
        for (int i=2; i < len; i++) {
            for (int j=1; j < i; j++) {
                int step = stones[i] - stones[j];
                if (step <= j+1) dp[i][step] = dp[j][step-1] || dp[j][step] || dp[j][step+1];
            }
        }
        for (int i=0; i<len; i++) {
            if (dp[len-1][i]) return true;
        }
        return false;
    }
}
```



## 区间

### [leetcode_56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

```java
// 排序
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0) return new int[0][2];
        Arrays.sort(intervals, (a, b) -> (a[0] != b[0] ? a[0]-b[0]: a[1]-b[1]));
        List<int[]> ans = new ArrayList<>();
        for (int[] lr: intervals) {
            int l = lr[0], r = lr[1];
            if (ans.size() ==0 || ans.get(ans.size()-1)[1] < l) {
                ans.add(new int[]{l, r});
            } else {
                ans.get(ans.size()-1)[1] = Math.max(ans.get(ans.size()-1)[1], r);
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

### [leetcode_57. 插入区间](https://leetcode.cn/problems/insert-interval/)

```java
// 过程模拟 -- coding问题
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        if (intervals.length <= 0) return new int[][]{newInterval};
        boolean isInsert = false;
        int insertL = newInterval[0], insertR = newInterval[1];
        List<int[]> ans = new ArrayList<>();
        for (int[] lr: intervals) {
            int l = lr[0], r = lr[1];
            if (l > insertR) {
                if (!isInsert) {
                    ans.add(new int[]{insertL, insertR});
                    isInsert = true;
                }
                ans.add(lr);
            } else if (r < insertL) {
                ans.add(lr);
            } else {
                insertL = Math.min(insertL, l);
                insertR = Math.max(insertR, r);
            }
        }
        if (!isInsert) {
                ans.add(new int[]{insertL, insertR});
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

### [leetcode_452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

```java
// 排序 + 贪心
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, (a, b) -> a[1]>b[1]?1:-1); // lambda表达式不要出现减号可能会溢出a[1]-b[1]>0
        int curPos = points[0][1];
        int ans = 1;
        for (int[] posX: points) {
            if (posX[0] > curPos) {
                ans++;
                curPos = posX[1];
            }
        }
        return ans;
    }
}
```



## 矩阵

### [leetcode_289. 生命游戏](https://leetcode.cn/problems/game-of-life/)

```java
// 原地模拟
class Solution {
    public void gameOfLife(int[][] board) {
        int[] dx = {1, 0 ,-1, 1, -1, 1, 0 ,-1};
        int[] dy = {1, 1, 1, 0, 0, -1, -1, -1};
        int r = board.length, c = board[0].length;
        for (int i=0; i < r; i++) {
            for (int j=0; j < c; j++) {
                int sum = 0;
                for (int k=0; k < 8; k++) {
                    int x = i + dx[k];
                    int y = j + dy[k];
                    if ((x >= 0 && x < r) && (y >= 0 && y < c) && Math.abs(board[x][y]) == 1) sum++;
                }
                if ((sum < 2 || sum > 3) && board[i][j] == 1) board[i][j] = -1;
                if (sum == 3 && board[i][j] == 0) board[i][j] = 2;
            }
        }
        for (int i=0; i < r; i++) {
            for (int j=0; j < c; j++) {
                if (board[i][j] > 0) board[i][j] = 1;
                else board[i][j] = 0;
            }
        }
    }
}
```

### [leetcode_36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

```java
// hashmap + 判断 -> 一次遍历
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] col = new int[9][9];
        int[][] area = new int[9][9];
        for (int i=0; i < 9; i++) {
            for (int j=0; j < 9; j++) {
                char cur = board[i][j];
                if (cur == '.') continue;
                int idx = i/3 * 3 + j/3;
                int num = cur - '1';
                rows[i][num]++;
                col[j][num]++;
                area[idx][num]++;
                if (rows[i][num] > 1|| col[j][num] > 1 || area[idx][num] > 1) return false;
            }
        }
        return true;
    }
}
```



## 二叉树

### [leetcode_129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

```java
// 深度优先遍历
class Solution {
    int sum = 0;
    public int sumNumbers(TreeNode root) {
        dfs(root, 0);
        return sum;
    }
    public void dfs(TreeNode cur, int curNum) {
        if (cur.left == null && cur.right == null) {
            sum += curNum*10 + cur.val;
        } else if (cur.left == null) {
            dfs(cur.right, curNum*10 + cur.val);
        } else if (cur.right == null) {
            dfs(cur.left, curNum*10 + cur.val);
        } else {
            dfs(cur.right, curNum*10 + cur.val);
            dfs(cur.left, curNum*10 + cur.val);
        }
    }
}
```

```java
// 深度优先遍历 -- 标准写法
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root, 0);
    }
    public int dfs(TreeNode cur, int preNum) {
        if (cur == null) {
            return 0;
        }
        int sum = preNum*10 + cur.val;
        if (cur.left == null && cur.right == null) {
            return sum;
        } else {
            return dfs(cur.left, sum) + dfs(cur.right, sum);
        }
    }
}
```

### [leetcode_114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

```java
// 后序遍历技巧 -- 反过来链接为链表
class Solution {
    TreeNode pre = null;
    public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.right);
        flatten(root.left);
        root.right = pre;
        root.left = null;
        pre = root;
    }
}
```

### [leetcode_106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
// 递归
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    int[] post = null;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int len = postorder.length;
        post = postorder;
        for (int i=0; i < len; i++) {
            map.put(inorder[i], i);
        }
        TreeNode root = buildTree(0, len-1, 0, len-1);
        return root;
    }
    public TreeNode buildTree(int is, int ie, int ps, int pe) {
        if (ie < is || pe < ps) return null;
        int root = post[pe];
        int rootIdx = map.get(root);
        TreeNode node = new TreeNode(root);
        node.left = buildTree(is, rootIdx-1, ps, ps + rootIdx - is - 1);
        node.right = buildTree(rootIdx + 1, ie, ps + rootIdx - is, pe-1);
        return node;
    }
}
```

### [leetcode_199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

```java
// 二叉树递归
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) return ans;
        dfs(ans, root, 0);
        return ans;
    }
    public void dfs(List<Integer> ans, TreeNode root, int deep) {
        if (root == null) return;
        if (deep == ans.size()) ans.add(root.val);
        dfs(ans, root.right, deep + 1);
        dfs(ans, root.left, deep + 1);
    }
}
```

### [leetcode_230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

```java
// 递归 -- 中序遍历
class Solution {
    int ans = 0;
    int k = 0;
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        dfs(root);
        return ans;
    }
    public void dfs(TreeNode root) {
        if (root == null) return;
        dfs(root.left);
        if (k == 0) return;
        if (--k == 0) ans = root.val;
        dfs(root.right);
    }
}
```

### [leetcode_103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```java
// 队列的特性 + 层序遍历
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        List<List<Integer>> ans = new ArrayList<>();
        if (root != null) queue.add(root);
        while (!queue.isEmpty()) {
            LinkedList<Integer> temp = new LinkedList<>();
            for (int i=queue.size()-1; i >=0; i--) {
                TreeNode node = queue.poll();
                if (ans.size() % 2 == 0) temp.addLast(node.val);
                else temp.addFirst(node.val);
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            ans.add(temp);
        }
        return ans;
    }
}
```

## 堆

### [leetcode_373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

```java
// 多路归并
```



## 栈

### [leetcode_71. 简化路径](https://leetcode.cn/problems/simplify-path/)

```java
// 栈
class Solution {
    public String simplifyPath(String path) {
        int len = path.length();
        if (len <= 1) return "/";
        String[] strs = path.split("/");
        StringBuilder sb = new StringBuilder();
        Deque<String> stack = new ArrayDeque<>();
        for (String str: strs) {
            if ("..".equals(str)) {
                if (!stack.isEmpty()) stack.pollLast();
            } else if (!".".equals(str) && str.length() > 0) stack.offerLast(str);
        }
        if (stack.isEmpty()) {
            sb.append('/');
        } else{
            while(!stack.isEmpty()) {
                sb.append('/');
                sb.append(stack.pollFirst());
            }
        }
        return sb.toString();
    } 
}
```

### [leetcode_150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```java
// 栈模拟波兰表达式
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new ArrayDeque<>();
        for (String token: tokens) {
            if (isNumber(token)) {
                stack.push(Integer.parseInt(token));
            } else {
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch (token) {
                    case "+":
                        stack.push(num1+num2);
                        break;
                    case "-":
                        stack.push(num1-num2);
                        break;
                    case "*":
                        stack.push(num1*num2);
                        break;
                    case "/":
                        stack.push(num1/num2);
                        break;
                }
            }
        }
        return stack.pop();
    }
    public boolean isNumber(String token) {
        return !("-".equals(token) || "+".equals(token) || "*".equals(token) || "/".equals(token));
    }
}
```

## 递归/回溯

### [leetcode_77. 组合](https://leetcode.cn/problems/combinations/)

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;

    }
    public void dfs(int cur, int n, int k) {
        if (temp.size() + (n-cur+1) < k) return;
        if (temp.size() == k) {
            ans.add(new ArrayList<>(temp));
            return;
        }
        dfs(cur+1, n, k);
        temp.add(cur);
        dfs(cur+1, n, k);
        temp.remove(temp.size()-1);
    }
}
```

### [leetcode_148. 排序链表](https://leetcode.cn/problems/sort-list/)

```java
// 快慢指针 + 归并排序
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode fast = head.next, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode temp = slow.next;
        slow.next = null;
        ListNode first = sortList(head);
        ListNode second = sortList(temp);
        ListNode h = new ListNode(0);
        ListNode ans = h;
        while (first != null && second != null) {
            if (first.val < second.val) {
                h.next = first;
                first = first.next;
            } else {
                h.next = second;
                second = second.next;
            }
            h = h.next;
        }
        h.next = first != null ? first: second;
        return ans.next;
    }
}
```

```java
// 桶排序
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        ListNode p = head;
        while (p != null) {
            max = Math.max(max, p.val);
            min = Math.min(min, p.val);
            p = p.next;
        }
        int[] cnt = new int[max - min + 1];
        p = head;
        while (p != null) {
            cnt[p.val - min]++;
            p = p.next;
        }
        p = head;
        for (int i=0; i < cnt.length; i++) {
            while (cnt[i] > 0) {
                cnt[i]--;
                p.val = i + min;
                p = p.next;
            }
        }
        return head;
    }
}
```

## 二分法

### [leetcode_162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```java
// 二分法
class Solution {
    public int findPeakElement(int[] nums) {
        int len = nums.length;
        if (len == 1) return 0;
        int idx = len / 2;
        while (!(compare(nums, idx-1, idx) > 0 && (compare(nums, idx, idx + 1) < 0))) {
            if (compare(nums, idx, idx + 1) > 0) idx++;
            else idx--;
        }
        return idx;
    }
    public int compare(int[] nums, int idx1, int idx2) {
        if (idx2 >= nums.length) return -1;
        if (idx1 < 0) return 1;
        if (nums[idx1] == nums[idx2]) return 0;
        return nums[idx1] > nums[idx2] ? -1: 1;
    }
}  
```

```java
// 比较难想
class Solution {
    public int findPeakElement(int[] nums) {
        int len = nums.length;
        if (len == 1) return 0;
        int l=0, r=len-1;
        while (l < r) {
            int mid = (r-l)/2 + l;
            if (nums[mid] < nums[mid+1]) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l;
    }
}
```

### [leetcode_719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

```java
class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        Arrays.sort(nums);
        int len = nums.length;
        int l=0, r=nums[len-1]-nums[0];
        while (l < r) {
            int mid = (r+l) >> 1;
            if (check(nums, mid) >= k) r = mid;
            else l = mid+1;
        }
        return r;
    }
    public int check(int[] nums, int cur) { // 返回小于等于cur的对数
        int len = nums.length;
        int sum=0;
        for (int i=0, j=1; i < nums.length-1;i++) {
            while (j < len && nums[j]-nums[i] <= cur) j++;
            sum += j-1-i;
        }
        return sum;
    }
}
```



# 技巧总结

1. 二维矩阵题目，考虑以某个点(x,y)为对角线/右下角(从上往下遍历)的情况

# 待完成事项

## 图相关算法+有序表

## 并查集题目

## leetcode_215题的BFPRT算法

## 哈希函数--再看一下视频

## coding

最长公共子串和最长公共子序列问题

Top K问题

二叉树递归的高级问题--最大二叉树的拓扑结构

## 单调栈--复习

## leetcode99

## zigzag打印二维数组

## 什么是容斥原理？

